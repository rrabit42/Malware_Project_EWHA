package android.support.multidex;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;
import android.util.Log;
import java.io.Closeable;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

final class MultiDexExtractor {
  private static final int BUFFER_SIZE = 16384;
  
  private static final String DEX_PREFIX = "classes";
  
  private static final String DEX_SUFFIX = ".dex";
  
  private static final String EXTRACTED_NAME_EXT = ".classes";
  
  private static final String EXTRACTED_SUFFIX = ".zip";
  
  private static final String KEY_CRC = "crc";
  
  private static final String KEY_DEX_CRC = "dex.crc.";
  
  private static final String KEY_DEX_NUMBER = "dex.number";
  
  private static final String KEY_DEX_TIME = "dex.time.";
  
  private static final String KEY_TIME_STAMP = "timestamp";
  
  private static final String LOCK_FILENAME = "MultiDex.lock";
  
  private static final int MAX_EXTRACT_ATTEMPTS = 3;
  
  private static final long NO_VALUE = -1L;
  
  private static final String PREFS_FILE = "multidex.version";
  
  private static final String TAG = "MultiDex";
  
  private static void closeQuietly(Closeable paramCloseable) {
    try {
      paramCloseable.close();
      return;
    } catch (IOException paramCloseable) {
      Log.w("MultiDex", "Failed to close resource", paramCloseable);
      return;
    } 
  }
  
  private static void extract(ZipFile paramZipFile, ZipEntry paramZipEntry, File paramFile, String paramString) throws IOException, FileNotFoundException {
    inputStream = paramZipFile.getInputStream(paramZipEntry);
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("tmp-");
    stringBuilder.append(paramString);
    file = File.createTempFile(stringBuilder.toString(), ".zip", paramFile.getParentFile());
    stringBuilder = new StringBuilder();
    stringBuilder.append("Extracting ");
    stringBuilder.append(file.getPath());
    Log.i("MultiDex", stringBuilder.toString());
    try {
    
    } finally {
      closeQuietly(inputStream);
      file.delete();
    } 
  }
  
  private static SharedPreferences getMultiDexPreferences(Context paramContext) {
    byte b;
    if (Build.VERSION.SDK_INT < 11) {
      b = 0;
    } else {
      b = 4;
    } 
    return paramContext.getSharedPreferences("multidex.version", b);
  }
  
  private static long getTimeStamp(File paramFile) {
    long l2 = paramFile.lastModified();
    long l1 = l2;
    if (l2 == -1L)
      l1 = l2 - 1L; 
    return l1;
  }
  
  private static long getZipCrc(File paramFile) {
    long l2 = ZipUtil.getZipCrc(paramFile);
    long l1 = l2;
    if (l2 == -1L)
      l1 = l2 - 1L; 
    return l1;
  }
  
  private static boolean isModified(Context paramContext, File paramFile, long paramLong, String paramString) {
    SharedPreferences sharedPreferences = getMultiDexPreferences(paramContext);
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(paramString);
    stringBuilder.append("timestamp");
    if (sharedPreferences.getLong(stringBuilder.toString(), -1L) == getTimeStamp(paramFile)) {
      StringBuilder stringBuilder1 = new StringBuilder();
      stringBuilder1.append(paramString);
      stringBuilder1.append("crc");
      if (sharedPreferences.getLong(stringBuilder1.toString(), -1L) == paramLong)
        return false; 
    } 
    return true;
  }
  
  static List<? extends File> load(Context paramContext, File paramFile1, File paramFile2, String paramString, boolean paramBoolean) throws IOException { // Byte code:
    //   0: new java/lang/StringBuilder
    //   3: dup
    //   4: invokespecial <init> : ()V
    //   7: astore #7
    //   9: aload #7
    //   11: ldc 'MultiDexExtractor.load('
    //   13: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   16: pop
    //   17: aload #7
    //   19: aload_1
    //   20: invokevirtual getPath : ()Ljava/lang/String;
    //   23: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   26: pop
    //   27: aload #7
    //   29: ldc ', '
    //   31: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   34: pop
    //   35: aload #7
    //   37: iload #4
    //   39: invokevirtual append : (Z)Ljava/lang/StringBuilder;
    //   42: pop
    //   43: aload #7
    //   45: ldc ', '
    //   47: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   50: pop
    //   51: aload #7
    //   53: aload_3
    //   54: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   57: pop
    //   58: aload #7
    //   60: ldc ')'
    //   62: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   65: pop
    //   66: ldc 'MultiDex'
    //   68: aload #7
    //   70: invokevirtual toString : ()Ljava/lang/String;
    //   73: invokestatic i : (Ljava/lang/String;Ljava/lang/String;)I
    //   76: pop
    //   77: aload_1
    //   78: invokestatic getZipCrc : (Ljava/io/File;)J
    //   81: lstore #5
    //   83: new java/io/File
    //   86: dup
    //   87: aload_2
    //   88: ldc 'MultiDex.lock'
    //   90: invokespecial <init> : (Ljava/io/File;Ljava/lang/String;)V
    //   93: astore #12
    //   95: new java/io/RandomAccessFile
    //   98: dup
    //   99: aload #12
    //   101: ldc 'rw'
    //   103: invokespecial <init> : (Ljava/io/File;Ljava/lang/String;)V
    //   106: astore #11
    //   108: aconst_null
    //   109: astore #9
    //   111: aload #11
    //   113: invokevirtual getChannel : ()Ljava/nio/channels/FileChannel;
    //   116: astore #7
    //   118: new java/lang/StringBuilder
    //   121: dup
    //   122: invokespecial <init> : ()V
    //   125: astore #8
    //   127: aload #8
    //   129: ldc_w 'Blocking on lock '
    //   132: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   135: pop
    //   136: aload #8
    //   138: aload #12
    //   140: invokevirtual getPath : ()Ljava/lang/String;
    //   143: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   146: pop
    //   147: ldc 'MultiDex'
    //   149: aload #8
    //   151: invokevirtual toString : ()Ljava/lang/String;
    //   154: invokestatic i : (Ljava/lang/String;Ljava/lang/String;)I
    //   157: pop
    //   158: aload #7
    //   160: invokevirtual lock : ()Ljava/nio/channels/FileLock;
    //   163: astore #8
    //   165: new java/lang/StringBuilder
    //   168: dup
    //   169: invokespecial <init> : ()V
    //   172: astore #10
    //   174: aload #10
    //   176: aload #12
    //   178: invokevirtual getPath : ()Ljava/lang/String;
    //   181: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   184: pop
    //   185: aload #10
    //   187: ldc_w ' locked'
    //   190: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   193: pop
    //   194: ldc 'MultiDex'
    //   196: aload #10
    //   198: invokevirtual toString : ()Ljava/lang/String;
    //   201: invokestatic i : (Ljava/lang/String;Ljava/lang/String;)I
    //   204: pop
    //   205: iload #4
    //   207: ifne -> 528
    //   210: aload_0
    //   211: aload_1
    //   212: lload #5
    //   214: aload_3
    //   215: invokestatic isModified : (Landroid/content/Context;Ljava/io/File;JLjava/lang/String;)Z
    //   218: istore #4
    //   220: iload #4
    //   222: ifne -> 276
    //   225: aload_0
    //   226: aload_1
    //   227: aload_2
    //   228: aload_3
    //   229: invokestatic loadExistingExtractions : (Landroid/content/Context;Ljava/io/File;Ljava/io/File;Ljava/lang/String;)Ljava/util/List;
    //   232: astore #10
    //   234: aload #10
    //   236: astore_0
    //   237: goto -> 308
    //   240: astore #10
    //   242: ldc 'MultiDex'
    //   244: ldc_w 'Failed to reload existing extracted secondary dex files, falling back to fresh extraction'
    //   247: aload #10
    //   249: invokestatic w : (Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)I
    //   252: pop
    //   253: aload_1
    //   254: aload_2
    //   255: invokestatic performExtractions : (Ljava/io/File;Ljava/io/File;)Ljava/util/List;
    //   258: astore_2
    //   259: aload_0
    //   260: aload_3
    //   261: aload_1
    //   262: invokestatic getTimeStamp : (Ljava/io/File;)J
    //   265: lload #5
    //   267: aload_2
    //   268: invokestatic putStoredApkInfo : (Landroid/content/Context;Ljava/lang/String;JJLjava/util/List;)V
    //   271: aload_2
    //   272: astore_0
    //   273: goto -> 237
    //   276: ldc 'MultiDex'
    //   278: ldc_w 'Detected that extraction must be performed.'
    //   281: invokestatic i : (Ljava/lang/String;Ljava/lang/String;)I
    //   284: pop
    //   285: aload_1
    //   286: aload_2
    //   287: invokestatic performExtractions : (Ljava/io/File;Ljava/io/File;)Ljava/util/List;
    //   290: astore_2
    //   291: aload_0
    //   292: aload_3
    //   293: aload_1
    //   294: invokestatic getTimeStamp : (Ljava/io/File;)J
    //   297: lload #5
    //   299: aload_2
    //   300: invokestatic putStoredApkInfo : (Landroid/content/Context;Ljava/lang/String;JJLjava/util/List;)V
    //   303: aload_2
    //   304: astore_0
    //   305: goto -> 237
    //   308: aload #9
    //   310: astore_1
    //   311: aload #8
    //   313: ifnull -> 364
    //   316: aload #8
    //   318: invokevirtual release : ()V
    //   321: aload #9
    //   323: astore_1
    //   324: goto -> 364
    //   327: astore_1
    //   328: new java/lang/StringBuilder
    //   331: dup
    //   332: invokespecial <init> : ()V
    //   335: astore_2
    //   336: aload_2
    //   337: ldc_w 'Failed to release lock on '
    //   340: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   343: pop
    //   344: aload_2
    //   345: aload #12
    //   347: invokevirtual getPath : ()Ljava/lang/String;
    //   350: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   353: pop
    //   354: ldc 'MultiDex'
    //   356: aload_2
    //   357: invokevirtual toString : ()Ljava/lang/String;
    //   360: invokestatic e : (Ljava/lang/String;Ljava/lang/String;)I
    //   363: pop
    //   364: aload #7
    //   366: ifnull -> 374
    //   369: aload #7
    //   371: invokestatic closeQuietly : (Ljava/io/Closeable;)V
    //   374: aload #11
    //   376: invokestatic closeQuietly : (Ljava/io/Closeable;)V
    //   379: aload_1
    //   380: ifnonnull -> 430
    //   383: new java/lang/StringBuilder
    //   386: dup
    //   387: invokespecial <init> : ()V
    //   390: astore_1
    //   391: aload_1
    //   392: ldc_w 'load found '
    //   395: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   398: pop
    //   399: aload_1
    //   400: aload_0
    //   401: invokeinterface size : ()I
    //   406: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   409: pop
    //   410: aload_1
    //   411: ldc_w ' secondary dex files'
    //   414: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   417: pop
    //   418: ldc 'MultiDex'
    //   420: aload_1
    //   421: invokevirtual toString : ()Ljava/lang/String;
    //   424: invokestatic i : (Ljava/lang/String;Ljava/lang/String;)I
    //   427: pop
    //   428: aload_0
    //   429: areturn
    //   430: aload_1
    //   431: athrow
    //   432: astore_0
    //   433: aload #7
    //   435: astore_2
    //   436: aload #8
    //   438: astore_1
    //   439: goto -> 456
    //   442: astore_0
    //   443: aconst_null
    //   444: astore_1
    //   445: aload #7
    //   447: astore_2
    //   448: goto -> 456
    //   451: astore_0
    //   452: aconst_null
    //   453: astore_2
    //   454: aload_2
    //   455: astore_1
    //   456: aload_1
    //   457: ifnull -> 503
    //   460: aload_1
    //   461: invokevirtual release : ()V
    //   464: goto -> 503
    //   467: new java/lang/StringBuilder
    //   470: dup
    //   471: invokespecial <init> : ()V
    //   474: astore_1
    //   475: aload_1
    //   476: ldc_w 'Failed to release lock on '
    //   479: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   482: pop
    //   483: aload_1
    //   484: aload #12
    //   486: invokevirtual getPath : ()Ljava/lang/String;
    //   489: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   492: pop
    //   493: ldc 'MultiDex'
    //   495: aload_1
    //   496: invokevirtual toString : ()Ljava/lang/String;
    //   499: invokestatic e : (Ljava/lang/String;Ljava/lang/String;)I
    //   502: pop
    //   503: aload_2
    //   504: ifnull -> 511
    //   507: aload_2
    //   508: invokestatic closeQuietly : (Ljava/io/Closeable;)V
    //   511: aload #11
    //   513: invokestatic closeQuietly : (Ljava/io/Closeable;)V
    //   516: goto -> 521
    //   519: aload_0
    //   520: athrow
    //   521: goto -> 519
    //   524: astore_1
    //   525: goto -> 467
    //   528: goto -> 276
    // Exception table:
    //   from	to	target	type
    //   111	118	451	finally
    //   118	165	442	finally
    //   165	205	432	finally
    //   210	220	432	finally
    //   225	234	240	java/io/IOException
    //   225	234	432	finally
    //   242	271	432	finally
    //   276	303	432	finally
    //   316	321	327	java/io/IOException
    //   460	464	524	java/io/IOException }
  
  private static List<ExtractedDex> loadExistingExtractions(Context paramContext, File paramFile1, File paramFile2, String paramString) throws IOException {
    Log.i("MultiDex", "loading existing secondary dex files");
    StringBuilder stringBuilder2 = new StringBuilder();
    stringBuilder2.append(paramFile1.getName());
    stringBuilder2.append(".classes");
    String str2 = stringBuilder2.toString();
    SharedPreferences sharedPreferences = getMultiDexPreferences(paramContext);
    StringBuilder stringBuilder1 = new StringBuilder();
    stringBuilder1.append(paramString);
    stringBuilder1.append("dex.number");
    int i = sharedPreferences.getInt(stringBuilder1.toString(), 1);
    ArrayList arrayList = new ArrayList(i - 1);
    byte b = 2;
    String str1 = str2;
    while (b <= i) {
      StringBuilder stringBuilder4 = new StringBuilder();
      stringBuilder4.append(str1);
      stringBuilder4.append(b);
      stringBuilder4.append(".zip");
      ExtractedDex extractedDex = new ExtractedDex(paramFile2, stringBuilder4.toString());
      if (extractedDex.isFile()) {
        extractedDex.crc = getZipCrc(extractedDex);
        StringBuilder stringBuilder6 = new StringBuilder();
        stringBuilder6.append(paramString);
        stringBuilder6.append("dex.crc.");
        stringBuilder6.append(b);
        long l1 = sharedPreferences.getLong(stringBuilder6.toString(), -1L);
        stringBuilder6 = new StringBuilder();
        stringBuilder6.append(paramString);
        stringBuilder6.append("dex.time.");
        stringBuilder6.append(b);
        long l2 = sharedPreferences.getLong(stringBuilder6.toString(), -1L);
        long l3 = extractedDex.lastModified();
        if (l2 == l3 && l1 == extractedDex.crc) {
          arrayList.add(extractedDex);
          b++;
          continue;
        } 
        StringBuilder stringBuilder5 = new StringBuilder();
        stringBuilder5.append("Invalid extracted dex: ");
        stringBuilder5.append(extractedDex);
        stringBuilder5.append(" (key \"");
        stringBuilder5.append(paramString);
        stringBuilder5.append("\"), expected modification time: ");
        stringBuilder5.append(l2);
        stringBuilder5.append(", modification time: ");
        stringBuilder5.append(l3);
        stringBuilder5.append(", expected crc: ");
        stringBuilder5.append(l1);
        stringBuilder5.append(", file crc: ");
        stringBuilder5.append(extractedDex.crc);
        throw new IOException(stringBuilder5.toString());
      } 
      StringBuilder stringBuilder3 = new StringBuilder();
      stringBuilder3.append("Missing extracted secondary dex file '");
      stringBuilder3.append(extractedDex.getPath());
      stringBuilder3.append("'");
      throw new IOException(stringBuilder3.toString());
    } 
    return arrayList;
  }
  
  private static List<ExtractedDex> performExtractions(File paramFile1, File paramFile2) throws IOException {
    stringBuilder = new StringBuilder();
    stringBuilder.append(paramFile1.getName());
    stringBuilder.append(".classes");
    String str = stringBuilder.toString();
    prepareDexDir(paramFile2, str);
    arrayList = new ArrayList();
    zipFile = new ZipFile(paramFile1);
    try {
      StringBuilder stringBuilder1 = new StringBuilder();
      stringBuilder1.append("classes");
      stringBuilder1.append(2);
      stringBuilder1.append(".dex");
      zipEntry = zipFile.getEntry(stringBuilder1.toString());
      byte b = 2;
      label46: while (true) {
        if (zipEntry != null) {
          stringBuilder = new StringBuilder();
          stringBuilder.append(str);
          stringBuilder.append(b);
          stringBuilder.append(".zip");
          ExtractedDex extractedDex = new ExtractedDex(paramFile2, stringBuilder.toString());
          arrayList.add(extractedDex);
          stringBuilder = new StringBuilder();
          stringBuilder.append("Extraction is needed for file ");
          stringBuilder.append(extractedDex);
          Log.i("MultiDex", stringBuilder.toString());
          byte b1 = 0;
          boolean bool = false;
          while (true) {
            if (b1 < 3 && !bool) {
              String str1;
              extract(zipFile, zipEntry, extractedDex, str);
              try {
                extractedDex.crc = getZipCrc(extractedDex);
                bool = true;
              } catch (IOException stringBuilder) {
                StringBuilder stringBuilder3 = new StringBuilder();
                stringBuilder3.append("Failed to read crc from ");
                stringBuilder3.append(extractedDex.getAbsolutePath());
                Log.w("MultiDex", stringBuilder3.toString(), stringBuilder);
                bool = false;
              } 
              StringBuilder stringBuilder2 = new StringBuilder();
              stringBuilder2.append("Extraction ");
              if (bool) {
                str1 = "succeeded";
              } else {
                str1 = "failed";
              } 
              stringBuilder2.append(str1);
              stringBuilder2.append(" - length ");
              stringBuilder2.append(extractedDex.getAbsolutePath());
              stringBuilder2.append(": ");
              stringBuilder2.append(extractedDex.length());
              stringBuilder2.append(" - crc: ");
              stringBuilder2.append(extractedDex.crc);
              Log.i("MultiDex", stringBuilder2.toString());
              if (!bool) {
                extractedDex.delete();
                if (extractedDex.exists()) {
                  StringBuilder stringBuilder3 = new StringBuilder();
                  stringBuilder3.append("Failed to delete corrupted secondary dex '");
                  stringBuilder3.append(extractedDex.getPath());
                  stringBuilder3.append("'");
                  Log.w("MultiDex", stringBuilder3.toString());
                } 
              } 
            } else {
              if (bool) {
                b++;
                StringBuilder stringBuilder3 = new StringBuilder();
                stringBuilder3.append("classes");
                stringBuilder3.append(b);
                stringBuilder3.append(".dex");
                ZipEntry zipEntry1 = zipFile.getEntry(stringBuilder3.toString());
                continue label46;
              } 
              StringBuilder stringBuilder2 = new StringBuilder();
              stringBuilder2.append("Could not create zip file ");
              stringBuilder2.append(extractedDex.getAbsolutePath());
              stringBuilder2.append(" for secondary dex (");
              stringBuilder2.append(b);
              stringBuilder2.append(")");
              throw new IOException(stringBuilder2.toString());
            } 
            b1++;
          } 
          break;
        } 
        try {
          return arrayList;
        } catch (IOException zipEntry) {
          return arrayList;
        } 
      } 
    } finally {
      try {
        zipFile.close();
      } catch (IOException paramFile2) {
        Log.w("MultiDex", "Failed to close resource", paramFile2);
      } 
    } 
  }
  
  private static void prepareDexDir(File paramFile, String paramString) {
    StringBuilder stringBuilder = paramFile.listFiles(new Object(paramString));
    if (stringBuilder == null) {
      stringBuilder = new StringBuilder();
      stringBuilder.append("Failed to list secondary dex dir content (");
      stringBuilder.append(paramFile.getPath());
      stringBuilder.append(").");
      Log.w("MultiDex", stringBuilder.toString());
      return;
    } 
    int i = stringBuilder.length;
    for (byte b = 0; b < i; b++) {
      StringBuilder stringBuilder1 = stringBuilder[b];
      StringBuilder stringBuilder2 = new StringBuilder();
      stringBuilder2.append("Trying to delete old file ");
      stringBuilder2.append(stringBuilder1.getPath());
      stringBuilder2.append(" of size ");
      stringBuilder2.append(stringBuilder1.length());
      Log.i("MultiDex", stringBuilder2.toString());
      if (!stringBuilder1.delete()) {
        stringBuilder2 = new StringBuilder();
        stringBuilder2.append("Failed to delete old file ");
        stringBuilder2.append(stringBuilder1.getPath());
        Log.w("MultiDex", stringBuilder2.toString());
      } else {
        stringBuilder2 = new StringBuilder();
        stringBuilder2.append("Deleted old file ");
        stringBuilder2.append(stringBuilder1.getPath());
        Log.i("MultiDex", stringBuilder2.toString());
      } 
    } 
  }
  
  private static void putStoredApkInfo(Context paramContext, String paramString, long paramLong1, long paramLong2, List<ExtractedDex> paramList) {
    SharedPreferences.Editor editor = getMultiDexPreferences(paramContext).edit();
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(paramString);
    stringBuilder.append("timestamp");
    editor.putLong(stringBuilder.toString(), paramLong1);
    stringBuilder = new StringBuilder();
    stringBuilder.append(paramString);
    stringBuilder.append("crc");
    editor.putLong(stringBuilder.toString(), paramLong2);
    stringBuilder = new StringBuilder();
    stringBuilder.append(paramString);
    stringBuilder.append("dex.number");
    editor.putInt(stringBuilder.toString(), paramList.size() + 1);
    Iterator iterator = paramList.iterator();
    byte b;
    for (b = 2; iterator.hasNext(); b++) {
      ExtractedDex extractedDex = (ExtractedDex)iterator.next();
      StringBuilder stringBuilder1 = new StringBuilder();
      stringBuilder1.append(paramString);
      stringBuilder1.append("dex.crc.");
      stringBuilder1.append(b);
      editor.putLong(stringBuilder1.toString(), extractedDex.crc);
      stringBuilder1 = new StringBuilder();
      stringBuilder1.append(paramString);
      stringBuilder1.append("dex.time.");
      stringBuilder1.append(b);
      editor.putLong(stringBuilder1.toString(), extractedDex.lastModified());
    } 
    editor.commit();
  }
}

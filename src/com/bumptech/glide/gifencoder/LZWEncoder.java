package com.bumptech.glide.gifencoder;

import java.io.IOException;
import java.io.OutputStream;

class LZWEncoder {
  static final int BITS = 12;
  
  private static final int EOF = -1;
  
  static final int HSIZE = 5003;
  
  int ClearCode;
  
  int EOFCode;
  
  int a_count;
  
  byte[] accum = new byte[256];
  
  boolean clear_flg = false;
  
  int[] codetab = new int[5003];
  
  private int curPixel;
  
  int cur_accum = 0;
  
  int cur_bits = 0;
  
  int free_ent = 0;
  
  int g_init_bits;
  
  int hsize = 5003;
  
  int[] htab = new int[5003];
  
  private int imgH;
  
  private int imgW;
  
  private int initCodeSize;
  
  int[] masks = { 
      0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 
      1023, 2047, 4095, 8191, 16383, 32767, 65535 };
  
  int maxbits = 12;
  
  int maxcode;
  
  int maxmaxcode = 4096;
  
  int n_bits;
  
  private byte[] pixAry;
  
  private int remaining;
  
  LZWEncoder(int paramInt1, int paramInt2, byte[] paramArrayOfByte, int paramInt3) {
    this.imgW = paramInt1;
    this.imgH = paramInt2;
    this.pixAry = paramArrayOfByte;
    this.initCodeSize = Math.max(2, paramInt3);
  }
  
  private int nextPixel() {
    int i = this.remaining;
    if (i == 0)
      return -1; 
    this.remaining = i - 1;
    byte[] arrayOfByte = this.pixAry;
    i = this.curPixel;
    this.curPixel = i + 1;
    return arrayOfByte[i] & 0xFF;
  }
  
  final int MAXCODE(int paramInt) { return (1 << paramInt) - 1; }
  
  void char_out(byte paramByte, OutputStream paramOutputStream) throws IOException {
    byte[] arrayOfByte = this.accum;
    int i = this.a_count;
    this.a_count = i + 1;
    arrayOfByte[i] = paramByte;
    if (this.a_count >= 254)
      flush_char(paramOutputStream); 
  }
  
  void cl_block(OutputStream paramOutputStream) throws IOException {
    cl_hash(this.hsize);
    int i = this.ClearCode;
    this.free_ent = i + 2;
    this.clear_flg = true;
    output(i, paramOutputStream);
  }
  
  void cl_hash(int paramInt) {
    for (byte b = 0; b < paramInt; b++)
      this.htab[b] = -1; 
  }
  
  void compress(int paramInt, OutputStream paramOutputStream) throws IOException {
    this.g_init_bits = paramInt;
    byte b = 0;
    this.clear_flg = false;
    this.n_bits = this.g_init_bits;
    this.maxcode = MAXCODE(this.n_bits);
    this.ClearCode = 1 << paramInt - 1;
    paramInt = this.ClearCode;
    this.EOFCode = paramInt + 1;
    this.free_ent = paramInt + 2;
    this.a_count = 0;
    int i = nextPixel();
    for (paramInt = this.hsize; paramInt < 65536; paramInt *= 2)
      b++; 
    int j = this.hsize;
    cl_hash(j);
    output(this.ClearCode, paramOutputStream);
    paramInt = i;
    label39: while (true) {
      int k = nextPixel();
      if (k != -1) {
        int n = (k << this.maxbits) + paramInt;
        i = k << 8 - b ^ paramInt;
        int[] arrayOfInt = this.htab;
        if (arrayOfInt[i] == n) {
          paramInt = this.codetab[i];
          continue;
        } 
        int m = i;
        if (arrayOfInt[i] >= 0) {
          m = j - i;
          int i1 = i;
          if (i == 0) {
            m = 1;
            i1 = i;
          } 
          do {
            i1 -= m;
            i = i1;
            if (i1 < 0)
              i = i1 + j; 
            arrayOfInt = this.htab;
            if (arrayOfInt[i] == n) {
              paramInt = this.codetab[i];
              continue label39;
            } 
            i1 = i;
          } while (arrayOfInt[i] >= 0);
          m = i;
        } 
        output(paramInt, paramOutputStream);
        paramInt = this.free_ent;
        if (paramInt < this.maxmaxcode) {
          arrayOfInt = this.codetab;
          this.free_ent = paramInt + 1;
          arrayOfInt[m] = paramInt;
          this.htab[m] = n;
        } else {
          cl_block(paramOutputStream);
        } 
        paramInt = k;
        continue;
      } 
      break;
    } 
    output(paramInt, paramOutputStream);
    output(this.EOFCode, paramOutputStream);
  }
  
  void encode(OutputStream paramOutputStream) throws IOException {
    paramOutputStream.write(this.initCodeSize);
    this.remaining = this.imgW * this.imgH;
    this.curPixel = 0;
    compress(this.initCodeSize + 1, paramOutputStream);
    paramOutputStream.write(0);
  }
  
  void flush_char(OutputStream paramOutputStream) throws IOException {
    int i = this.a_count;
    if (i > 0) {
      paramOutputStream.write(i);
      paramOutputStream.write(this.accum, 0, this.a_count);
      this.a_count = 0;
    } 
  }
  
  void output(int paramInt, OutputStream paramOutputStream) throws IOException {
    int i = this.cur_accum;
    int[] arrayOfInt = this.masks;
    int j = this.cur_bits;
    this.cur_accum = i & arrayOfInt[j];
    if (j > 0) {
      this.cur_accum |= paramInt << j;
    } else {
      this.cur_accum = paramInt;
    } 
    this.cur_bits += this.n_bits;
    while (this.cur_bits >= 8) {
      char_out((byte)(this.cur_accum & 0xFF), paramOutputStream);
      this.cur_accum >>= 8;
      this.cur_bits -= 8;
    } 
    if (this.free_ent > this.maxcode || this.clear_flg)
      if (this.clear_flg) {
        i = this.g_init_bits;
        this.n_bits = i;
        this.maxcode = MAXCODE(i);
        this.clear_flg = false;
      } else {
        i = ++this.n_bits;
        if (i == this.maxbits) {
          this.maxcode = this.maxmaxcode;
        } else {
          this.maxcode = MAXCODE(i);
        } 
      }  
    if (paramInt == this.EOFCode) {
      while (this.cur_bits > 0) {
        char_out((byte)(this.cur_accum & 0xFF), paramOutputStream);
        this.cur_accum >>= 8;
        this.cur_bits -= 8;
      } 
      flush_char(paramOutputStream);
    } 
  }
}

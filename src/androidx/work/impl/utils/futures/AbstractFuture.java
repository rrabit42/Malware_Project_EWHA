package androidx.work.impl.utils.futures;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RestrictTo;
import com.google.common.util.concurrent.ListenableFuture;
import java.util.Locale;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.concurrent.locks.LockSupport;
import java.util.logging.Level;
import java.util.logging.Logger;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public abstract class AbstractFuture<V> extends Object implements ListenableFuture<V> {
  static final AtomicHelper ATOMIC_HELPER;
  
  static final boolean GENERATE_CANCELLATION_CAUSES;
  
  private static final Object NULL;
  
  private static final long SPIN_THRESHOLD_NANOS = 1000L;
  
  private static final Logger log;
  
  static  {
    SynchronizedHelper synchronizedHelper;
    GENERATE_CANCELLATION_CAUSES = Boolean.parseBoolean(System.getProperty("guava.concurrent.generate_cancellation_cause", "false"));
    log = Logger.getLogger(AbstractFuture.class.getName());
    try {
      synchronizedHelper = new SafeAtomicHelper(AtomicReferenceFieldUpdater.newUpdater(Waiter.class, Thread.class, "thread"), AtomicReferenceFieldUpdater.newUpdater(Waiter.class, Waiter.class, "next"), AtomicReferenceFieldUpdater.newUpdater(AbstractFuture.class, Waiter.class, "waiters"), AtomicReferenceFieldUpdater.newUpdater(AbstractFuture.class, Listener.class, "listeners"), AtomicReferenceFieldUpdater.newUpdater(AbstractFuture.class, Object.class, "value"));
      throwable = null;
    } catch (Throwable throwable) {
      synchronizedHelper = new SynchronizedHelper();
    } 
    ATOMIC_HELPER = synchronizedHelper;
    if (throwable != null)
      log.log(Level.SEVERE, "SafeAtomicHelper is broken!", throwable); 
    NULL = new Object();
  }
  
  private void addDoneString(StringBuilder paramStringBuilder) {
    try {
      Object object = getUninterruptibly(this);
      paramStringBuilder.append("SUCCESS, result=[");
      paramStringBuilder.append(userObjectToString(object));
      paramStringBuilder.append("]");
      return;
    } catch (ExecutionException executionException) {
      paramStringBuilder.append("FAILURE, cause=[");
      paramStringBuilder.append(executionException.getCause());
      paramStringBuilder.append("]");
      return;
    } catch (CancellationException cancellationException) {
      paramStringBuilder.append("CANCELLED");
      return;
    } catch (RuntimeException runtimeException) {
      paramStringBuilder.append("UNKNOWN, cause=[");
      paramStringBuilder.append(runtimeException.getClass());
      paramStringBuilder.append(" thrown from get()]");
      return;
    } 
  }
  
  private static CancellationException cancellationExceptionWithCause(@Nullable String paramString, @Nullable Throwable paramThrowable) {
    CancellationException cancellationException = new CancellationException(paramString);
    cancellationException.initCause(paramThrowable);
    return cancellationException;
  }
  
  @NonNull
  static <T> T checkNotNull(@Nullable T paramT) {
    if (paramT != null)
      return paramT; 
    throw new NullPointerException();
  }
  
  private Listener clearListeners(Listener paramListener) {
    Listener listener2;
    do {
      listener2 = this.listeners;
    } while (!ATOMIC_HELPER.casListeners(this, listener2, Listener.TOMBSTONE));
    Listener listener1 = paramListener;
    for (paramListener = listener2; paramListener != null; paramListener = listener2) {
      listener2 = paramListener.next;
      paramListener.next = listener1;
      listener1 = paramListener;
    } 
    return listener1;
  }
  
  static void complete(AbstractFuture<?> paramAbstractFuture) {
    AbstractFuture<?> abstractFuture2 = null;
    AbstractFuture<?> abstractFuture1 = paramAbstractFuture;
    paramAbstractFuture = abstractFuture2;
    label17: while (true) {
      abstractFuture1.releaseWaiters();
      abstractFuture1.afterDone();
      Listener listener = abstractFuture1.clearListeners(paramAbstractFuture);
      while (listener != null) {
        AbstractFuture abstractFuture;
        Listener listener1 = listener.next;
        SetFuture setFuture = listener.task;
        if (setFuture instanceof SetFuture) {
          setFuture = (SetFuture)setFuture;
          abstractFuture = setFuture.owner;
          if (abstractFuture.value == setFuture) {
            Object object = getFutureValue(setFuture.future);
            if (ATOMIC_HELPER.casValue(abstractFuture, setFuture, object))
              continue label17; 
          } 
        } else {
          executeListener(setFuture, abstractFuture.executor);
        } 
        Listener listener2 = listener1;
      } 
      break;
    } 
  }
  
  private static void executeListener(Runnable paramRunnable, Executor paramExecutor) {
    try {
      paramExecutor.execute(paramRunnable);
      return;
    } catch (RuntimeException runtimeException) {
      Logger logger = log;
      Level level = Level.SEVERE;
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append("RuntimeException while executing runnable ");
      stringBuilder.append(paramRunnable);
      stringBuilder.append(" with executor ");
      stringBuilder.append(paramExecutor);
      logger.log(level, stringBuilder.toString(), runtimeException);
      return;
    } 
  }
  
  private V getDoneValue(Object paramObject) throws ExecutionException {
    if (!(paramObject instanceof Cancellation)) {
      if (!(paramObject instanceof Failure)) {
        Object object = paramObject;
        if (paramObject == NULL)
          object = null; 
        return (V)object;
      } 
      throw new ExecutionException(((Failure)paramObject).exception);
    } 
    throw cancellationExceptionWithCause("Task was cancelled.", ((Cancellation)paramObject).cause);
  }
  
  static Object getFutureValue(ListenableFuture<?> paramListenableFuture) {
    if (paramListenableFuture instanceof AbstractFuture) {
      Object object1 = ((AbstractFuture)paramListenableFuture).value;
      object = object1;
      if (object1 instanceof Cancellation) {
        Cancellation cancellation = (Cancellation)object1;
        object = object1;
        if (cancellation.wasInterrupted) {
          if (cancellation.cause != null)
            return new Cancellation(false, cancellation.cause); 
          object = Cancellation.CAUSELESS_CANCELLED;
        } 
      } 
      return object;
    } 
    boolean bool = object.isCancelled();
    if ((GENERATE_CANCELLATION_CAUSES ^ true) & bool)
      return Cancellation.CAUSELESS_CANCELLED; 
    try {
      Object object2 = getUninterruptibly(object);
      Object object1 = object2;
      if (object2 == null)
        object1 = NULL; 
      return object1;
    } catch (ExecutionException object) {
      return new Failure(object.getCause());
    } catch (CancellationException cancellationException) {
      if (!bool) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("get() threw CancellationException, despite reporting isCancelled() == false: ");
        stringBuilder.append(object);
        return new Failure(new IllegalArgumentException(stringBuilder.toString(), cancellationException));
      } 
      return new Cancellation(false, cancellationException);
    } catch (Throwable object) {
      return new Failure(object);
    } 
  }
  
  private static <V> V getUninterruptibly(Future<V> paramFuture) throws ExecutionException {
    bool = false;
    while (true) {
      try {
        object = paramFuture.get();
        return (V)object;
      } catch (InterruptedException interruptedException) {
      
      } finally {
        if (bool)
          Thread.currentThread().interrupt(); 
      } 
    } 
  }
  
  private void releaseWaiters() {
    Waiter waiter;
    do {
      waiter = this.waiters;
    } while (!ATOMIC_HELPER.casWaiters(this, waiter, Waiter.TOMBSTONE));
    while (waiter != null) {
      waiter.unpark();
      waiter = waiter.next;
    } 
  }
  
  private void removeWaiter(Waiter paramWaiter) {
    paramWaiter.thread = null;
    label24: while (true) {
      paramWaiter = this.waiters;
      if (paramWaiter == Waiter.TOMBSTONE)
        return; 
      for (Object object = null; paramWaiter != null; object = object1) {
        Object object1;
        Waiter waiter = paramWaiter.next;
        if (paramWaiter.thread != null) {
          object1 = paramWaiter;
        } else if (object != null) {
          object.next = waiter;
          object1 = object;
          if (object.thread == null)
            continue label24; 
        } else {
          object1 = object;
          if (!ATOMIC_HELPER.casWaiters(this, paramWaiter, waiter))
            continue label24; 
        } 
        paramWaiter = waiter;
      } 
      break;
    } 
  }
  
  private String userObjectToString(Object paramObject) { return (paramObject == this) ? "this future" : String.valueOf(paramObject); }
  
  public final void addListener(Runnable paramRunnable, Executor paramExecutor) {
    checkNotNull(paramRunnable);
    checkNotNull(paramExecutor);
    Listener listener = this.listeners;
    if (listener != Listener.TOMBSTONE) {
      Listener listener1;
      Listener listener2 = new Listener(paramRunnable, paramExecutor);
      do {
        listener2.next = listener;
        if (ATOMIC_HELPER.casListeners(this, listener, listener2))
          return; 
        listener1 = this.listeners;
        listener = listener1;
      } while (listener1 != Listener.TOMBSTONE);
    } 
    executeListener(paramRunnable, paramExecutor);
  }
  
  protected void afterDone() {}
  
  public final boolean cancel(boolean paramBoolean) {
    boolean bool2;
    boolean bool1;
    Object object = this.value;
    byte b = 1;
    if (object == null) {
      bool1 = true;
    } else {
      bool1 = false;
    } 
    if (bool1 | object instanceof SetFuture) {
      Cancellation cancellation;
      if (GENERATE_CANCELLATION_CAUSES) {
        cancellation = new Cancellation(paramBoolean, new CancellationException("Future.cancel() was called."));
      } else if (paramBoolean) {
        cancellation = Cancellation.CAUSELESS_INTERRUPTED;
      } else {
        cancellation = Cancellation.CAUSELESS_CANCELLED;
      } 
      bool2 = false;
      AbstractFuture abstractFuture = this;
      while (true) {
        while (ATOMIC_HELPER.casValue(abstractFuture, object, cancellation)) {
          if (paramBoolean)
            abstractFuture.interruptTask(); 
          complete(abstractFuture);
          bool2 = b;
          if (object instanceof SetFuture) {
            object = ((SetFuture)object).future;
            if (object instanceof AbstractFuture) {
              abstractFuture = (AbstractFuture)object;
              object = abstractFuture.value;
              if (object == null) {
                bool1 = true;
              } else {
                bool1 = false;
              } 
              bool2 = b;
              if (bool1 | object instanceof SetFuture) {
                bool2 = true;
                continue;
              } 
            } else {
              object.cancel(paramBoolean);
              return true;
            } 
          } 
          return bool2;
        } 
        Object object1 = abstractFuture.value;
        object = object1;
        if (!(object1 instanceof SetFuture))
          return bool2; 
      } 
    } else {
      bool2 = false;
    } 
    return bool2;
  }
  
  public final V get() throws InterruptedException, ExecutionException {
    if (!Thread.interrupted()) {
      byte b2;
      byte b1;
      Object object = this.value;
      if (object != null) {
        b1 = 1;
      } else {
        b1 = 0;
      } 
      if (!(object instanceof SetFuture)) {
        b2 = 1;
      } else {
        b2 = 0;
      } 
      if (b1 & b2)
        return (V)getDoneValue(object); 
      object = this.waiters;
      if (object != Waiter.TOMBSTONE) {
        Waiter waiter1;
        Waiter waiter2 = new Waiter();
        do {
          waiter2.setNext(object);
          if (ATOMIC_HELPER.casWaiters(this, object, waiter2)) {
            while (true) {
              LockSupport.park(this);
              if (!Thread.interrupted()) {
                object = this.value;
                if (object != null) {
                  b1 = 1;
                } else {
                  b1 = 0;
                } 
                if (!(object instanceof SetFuture)) {
                  b2 = 1;
                } else {
                  b2 = 0;
                } 
                if ((b1 & b2) != 0)
                  return (V)getDoneValue(object); 
                continue;
              } 
              break;
            } 
            removeWaiter(waiter2);
            throw new InterruptedException();
          } 
          waiter1 = this.waiters;
          object = waiter1;
        } while (waiter1 != Waiter.TOMBSTONE);
      } 
      return (V)getDoneValue(this.value);
    } 
    InterruptedException interruptedException = new InterruptedException();
    throw interruptedException;
  }
  
  public final V get(long paramLong, TimeUnit paramTimeUnit) throws InterruptedException, TimeoutException, ExecutionException {
    long l = paramTimeUnit.toNanos(paramLong);
    if (!Thread.interrupted()) {
      long l2;
      byte b2;
      byte b1;
      Object object = this.value;
      if (object != null) {
        b1 = 1;
      } else {
        b1 = 0;
      } 
      if (!(object instanceof SetFuture)) {
        b2 = 1;
      } else {
        b2 = 0;
      } 
      if (b1 & b2)
        return (V)getDoneValue(object); 
      if (l > 0L) {
        l2 = System.nanoTime() + l;
      } else {
        l2 = 0L;
      } 
      long l1 = l;
      if (l >= 1000L) {
        object = this.waiters;
        if (object != Waiter.TOMBSTONE) {
          Waiter waiter = new Waiter();
          label90: while (true) {
            waiter.setNext(object);
            if (ATOMIC_HELPER.casWaiters(this, object, waiter)) {
              while (true) {
                LockSupport.parkNanos(this, l);
                if (!Thread.interrupted()) {
                  object = this.value;
                  if (object != null) {
                    b1 = 1;
                  } else {
                    b1 = 0;
                  } 
                  if (!(object instanceof SetFuture)) {
                    b2 = 1;
                  } else {
                    b2 = 0;
                  } 
                  if ((b1 & b2) != 0)
                    return (V)getDoneValue(object); 
                  l1 = l2 - System.nanoTime();
                  l = l1;
                  if (l1 < 1000L) {
                    removeWaiter(waiter);
                    break;
                  } 
                  continue;
                } 
                removeWaiter(waiter);
                throw new InterruptedException();
              } 
              break;
            } 
            Waiter waiter1 = this.waiters;
            object = waiter1;
            if (waiter1 == Waiter.TOMBSTONE)
              break label90; 
          } 
        } else {
          return (V)getDoneValue(this.value);
        } 
      } 
      while (l1 > 0L) {
        object = this.value;
        if (object != null) {
          b1 = 1;
        } else {
          b1 = 0;
        } 
        if (!(object instanceof SetFuture)) {
          b2 = 1;
        } else {
          b2 = 0;
        } 
        if ((b1 & b2) != 0)
          return (V)getDoneValue(object); 
        if (!Thread.interrupted()) {
          l1 = l2 - System.nanoTime();
          continue;
        } 
        throw new InterruptedException();
      } 
      String str2 = toString();
      String str3 = paramTimeUnit.toString().toLowerCase(Locale.ROOT);
      object = new StringBuilder();
      object.append("Waited ");
      object.append(paramLong);
      object.append(" ");
      object.append(paramTimeUnit.toString().toLowerCase(Locale.ROOT));
      String str1 = object.toString();
      object = str1;
      if (l1 + 1000L < 0L) {
        object = new StringBuilder();
        object.append(str1);
        object.append(" (plus ");
        object = object.toString();
        l1 = -l1;
        paramLong = paramTimeUnit.convert(l1, TimeUnit.NANOSECONDS);
        l1 -= paramTimeUnit.toNanos(paramLong);
        if (paramLong == 0L || l1 > 1000L) {
          b1 = 1;
        } else {
          b1 = 0;
        } 
        Object object1 = object;
        if (paramLong > 0L) {
          object1 = new StringBuilder();
          object1.append(object);
          object1.append(paramLong);
          object1.append(" ");
          object1.append(str3);
          object = object1.toString();
          object1 = object;
          if (b1 != 0) {
            object1 = new StringBuilder();
            object1.append(object);
            object1.append(",");
            object1 = object1.toString();
          } 
          object = new StringBuilder();
          object.append(object1);
          object.append(" ");
          object1 = object.toString();
        } 
        object = object1;
        if (b1 != 0) {
          object = new StringBuilder();
          object.append(object1);
          object.append(l1);
          object.append(" nanoseconds ");
          object = object.toString();
        } 
        object1 = new StringBuilder();
        object1.append(object);
        object1.append("delay)");
        object = object1.toString();
      } 
      if (isDone()) {
        StringBuilder stringBuilder1 = new StringBuilder();
        stringBuilder1.append(object);
        stringBuilder1.append(" but future completed as timeout expired");
        throw new TimeoutException(stringBuilder1.toString());
      } 
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append(object);
      stringBuilder.append(" for ");
      stringBuilder.append(str2);
      throw new TimeoutException(stringBuilder.toString());
    } 
    InterruptedException interruptedException = new InterruptedException();
    throw interruptedException;
  }
  
  protected void interruptTask() {}
  
  public final boolean isCancelled() { return this.value instanceof Cancellation; }
  
  public final boolean isDone() {
    byte b1;
    Object object = this.value;
    byte b2 = 1;
    if (object != null) {
      b1 = 1;
    } else {
      b1 = 0;
    } 
    if (object instanceof SetFuture)
      b2 = 0; 
    return b1 & b2;
  }
  
  final void maybePropagateCancellationTo(@Nullable Future<?> paramFuture) {
    boolean bool;
    if (paramFuture != null) {
      bool = true;
    } else {
      bool = false;
    } 
    if (bool & isCancelled())
      paramFuture.cancel(wasInterrupted()); 
  }
  
  @Nullable
  protected String pendingToString() {
    Object object = this.value;
    if (object instanceof SetFuture) {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append("setFuture=[");
      stringBuilder.append(userObjectToString(((SetFuture)object).future));
      stringBuilder.append("]");
      return stringBuilder.toString();
    } 
    if (this instanceof ScheduledFuture) {
      object = new StringBuilder();
      object.append("remaining delay=[");
      object.append(((ScheduledFuture)this).getDelay(TimeUnit.MILLISECONDS));
      object.append(" ms]");
      return object.toString();
    } 
    return null;
  }
  
  protected boolean set(@Nullable V paramV) {
    V v = paramV;
    if (paramV == null)
      v = (V)NULL; 
    if (ATOMIC_HELPER.casValue(this, null, v)) {
      complete(this);
      return true;
    } 
    return false;
  }
  
  protected boolean setException(Throwable paramThrowable) {
    Failure failure = new Failure((Throwable)checkNotNull(paramThrowable));
    if (ATOMIC_HELPER.casValue(this, null, failure)) {
      complete(this);
      return true;
    } 
    return false;
  }
  
  protected boolean setFuture(ListenableFuture<? extends V> paramListenableFuture) {
    checkNotNull(paramListenableFuture);
    Object object3 = this.value;
    Object object2 = object3;
    if (object3 == null) {
      if (paramListenableFuture.isDone()) {
        object1 = getFutureValue(paramListenableFuture);
        if (ATOMIC_HELPER.casValue(this, null, object1)) {
          complete(this);
          return true;
        } 
        return false;
      } 
      object2 = new SetFuture(this, object1);
      if (ATOMIC_HELPER.casValue(this, null, object2))
        try {
          object1.addListener(object2, DirectExecutor.INSTANCE);
          return true;
        } catch (Throwable object1) {
          try {
            object1 = new Failure(object1);
          } catch (Throwable object1) {
            object1 = Failure.FALLBACK_INSTANCE;
          } 
          ATOMIC_HELPER.casValue(this, object2, object1);
          return true;
        }  
      object2 = this.value;
    } 
    if (object2 instanceof Cancellation)
      object1.cancel(((Cancellation)object2).wasInterrupted); 
    return false;
  }
  
  public String toString() {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(super.toString());
    stringBuilder.append("[status=");
    if (isCancelled()) {
      stringBuilder.append("CANCELLED");
    } else if (isDone()) {
      addDoneString(stringBuilder);
    } else {
      String str;
      try {
        str = pendingToString();
      } catch (RuntimeException runtimeException) {
        StringBuilder stringBuilder1 = new StringBuilder();
        stringBuilder1.append("Exception thrown from implementation: ");
        stringBuilder1.append(runtimeException.getClass());
        str = stringBuilder1.toString();
      } 
      if (str != null && !str.isEmpty()) {
        stringBuilder.append("PENDING, info=[");
        stringBuilder.append(str);
        stringBuilder.append("]");
      } else if (isDone()) {
        addDoneString(stringBuilder);
      } else {
        stringBuilder.append("PENDING");
      } 
    } 
    stringBuilder.append("]");
    return stringBuilder.toString();
  }
  
  protected final boolean wasInterrupted() {
    Object object = this.value;
    return (object instanceof Cancellation && ((Cancellation)object).wasInterrupted);
  }
}

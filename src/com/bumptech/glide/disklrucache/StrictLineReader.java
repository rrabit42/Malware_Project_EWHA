package com.bumptech.glide.disklrucache;

import java.io.Closeable;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;

class StrictLineReader implements Closeable {
  private static final byte CR = 13;
  
  private static final byte LF = 10;
  
  private byte[] buf;
  
  private final Charset charset;
  
  private int end;
  
  private final InputStream in;
  
  private int pos;
  
  public StrictLineReader(InputStream paramInputStream, int paramInt, Charset paramCharset) {
    if (paramInputStream != null && paramCharset != null) {
      if (paramInt >= 0) {
        if (paramCharset.equals(Util.US_ASCII)) {
          this.in = paramInputStream;
          this.charset = paramCharset;
          this.buf = new byte[paramInt];
          return;
        } 
        throw new IllegalArgumentException("Unsupported encoding");
      } 
      throw new IllegalArgumentException("capacity <= 0");
    } 
    throw new NullPointerException();
  }
  
  public StrictLineReader(InputStream paramInputStream, Charset paramCharset) { this(paramInputStream, 8192, paramCharset); }
  
  private void fillBuf() throws IOException {
    InputStream inputStream = this.in;
    byte[] arrayOfByte = this.buf;
    int i = inputStream.read(arrayOfByte, 0, arrayOfByte.length);
    if (i != -1) {
      this.pos = 0;
      this.end = i;
      return;
    } 
    throw new EOFException();
  }
  
  public void close() throws IOException {
    synchronized (this.in) {
      if (this.buf != null) {
        this.buf = null;
        this.in.close();
      } 
      return;
    } 
  }
  
  public boolean hasUnterminatedLine() { return (this.end == -1); }
  
  public String readLine() throws IOException {
    int i;
    synchronized (this.in) {
      if (this.buf != null) {
        if (this.pos >= this.end)
          fillBuf(); 
        for (i = this.pos;; i++) {
          if (i != this.end) {
            if (this.buf[i] == 10) {
              if (i != this.pos) {
                byte[] arrayOfByte = this.buf;
                int k = i - 1;
                if (arrayOfByte[k] == 13) {
                  String str1 = new String(this.buf, this.pos, k - this.pos, this.charset.name());
                  this.pos = i + 1;
                  return str1;
                } 
              } 
              int j = i;
              String str = new String(this.buf, this.pos, j - this.pos, this.charset.name());
              this.pos = i + 1;
              return str;
            } 
          } else {
            null = new Object(this, this.end - this.pos + 80);
            while (true) {
              null.write(this.buf, this.pos, this.end - this.pos);
              this.end = -1;
              fillBuf();
              for (i = this.pos;; i++) {
                if (i != this.end) {
                  if (this.buf[i] == 10) {
                    if (i != this.pos)
                      null.write(this.buf, this.pos, i - this.pos); 
                    this.pos = i + 1;
                    return null.toString();
                  } 
                } else {
                  break;
                } 
              } 
            } 
          } 
        } 
      } else {
        throw new IOException("LineReader is closed");
      } 
    } 
    i++;
    continue;
  }
}

package android.support.multidex;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.os.Build;
import android.util.Log;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public final class MultiDex {
  private static final String CODE_CACHE_NAME = "code_cache";
  
  private static final String CODE_CACHE_SECONDARY_FOLDER_NAME = "secondary-dexes";
  
  private static final boolean IS_VM_MULTIDEX_CAPABLE;
  
  private static final int MAX_SUPPORTED_SDK_VERSION = 20;
  
  private static final int MIN_SDK_VERSION = 4;
  
  private static final String NO_KEY_PREFIX = "";
  
  private static final String OLD_SECONDARY_FOLDER_NAME = "secondary-dexes";
  
  static final String TAG = "MultiDex";
  
  private static final int VM_WITH_MULTIDEX_VERSION_MAJOR = 2;
  
  private static final int VM_WITH_MULTIDEX_VERSION_MINOR = 1;
  
  private static final Set<File> installedApk = new HashSet();
  
  static  {
    IS_VM_MULTIDEX_CAPABLE = isVMMultidexCapable(System.getProperty("java.vm.version"));
  }
  
  private static void clearOldDexDir(Context paramContext) throws Exception {
    File file = new File(paramContext.getFilesDir(), "secondary-dexes");
    if (file.isDirectory()) {
      StringBuilder stringBuilder2 = new StringBuilder();
      stringBuilder2.append("Clearing old secondary dex dir (");
      stringBuilder2.append(file.getPath());
      stringBuilder2.append(").");
      Log.i("MultiDex", stringBuilder2.toString());
      StringBuilder stringBuilder1 = file.listFiles();
      if (stringBuilder1 == null) {
        stringBuilder1 = new StringBuilder();
        stringBuilder1.append("Failed to list secondary dex dir content (");
        stringBuilder1.append(file.getPath());
        stringBuilder1.append(").");
        Log.w("MultiDex", stringBuilder1.toString());
        return;
      } 
      int i = stringBuilder1.length;
      for (byte b = 0; b < i; b++) {
        StringBuilder stringBuilder3 = stringBuilder1[b];
        StringBuilder stringBuilder4 = new StringBuilder();
        stringBuilder4.append("Trying to delete old file ");
        stringBuilder4.append(stringBuilder3.getPath());
        stringBuilder4.append(" of size ");
        stringBuilder4.append(stringBuilder3.length());
        Log.i("MultiDex", stringBuilder4.toString());
        if (!stringBuilder3.delete()) {
          stringBuilder4 = new StringBuilder();
          stringBuilder4.append("Failed to delete old file ");
          stringBuilder4.append(stringBuilder3.getPath());
          Log.w("MultiDex", stringBuilder4.toString());
        } else {
          stringBuilder4 = new StringBuilder();
          stringBuilder4.append("Deleted old file ");
          stringBuilder4.append(stringBuilder3.getPath());
          Log.i("MultiDex", stringBuilder4.toString());
        } 
      } 
      if (!file.delete()) {
        stringBuilder1 = new StringBuilder();
        stringBuilder1.append("Failed to delete secondary dex dir ");
        stringBuilder1.append(file.getPath());
        Log.w("MultiDex", stringBuilder1.toString());
        return;
      } 
      stringBuilder1 = new StringBuilder();
      stringBuilder1.append("Deleted old secondary dex dir ");
      stringBuilder1.append(file.getPath());
      Log.i("MultiDex", stringBuilder1.toString());
    } 
  }
  
  private static void doInstallation(Context paramContext, File paramFile1, File paramFile2, String paramString1, String paramString2) throws IOException, IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException {
    synchronized (installedApk) {
      if (installedApk.contains(paramFile1))
        return; 
      installedApk.add(paramFile1);
      if (Build.VERSION.SDK_INT > 20) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("MultiDex is not guaranteed to work in SDK version ");
        stringBuilder.append(Build.VERSION.SDK_INT);
        stringBuilder.append(": SDK version higher than ");
        stringBuilder.append(20);
        stringBuilder.append(" should be backed by ");
        stringBuilder.append("runtime with built-in multidex capabilty but it's not the ");
        stringBuilder.append("case here: java.vm.version=\"");
        stringBuilder.append(System.getProperty("java.vm.version"));
        stringBuilder.append("\"");
        Log.w("MultiDex", stringBuilder.toString());
      } 
      try {
        ClassLoader classLoader = paramContext.getClassLoader();
        if (classLoader == null) {
          Log.e("MultiDex", "Context class loader is null. Must be running in test mode. Skip patching.");
          return;
        } 
        try {
          clearOldDexDir(paramContext);
        } catch (Throwable throwable) {
          Log.w("MultiDex", "Something went wrong when trying to clear old MultiDex extraction, continuing without cleaning.", throwable);
        } 
        paramFile2 = getDexDir(paramContext, paramFile2, paramString1);
        installSecondaryDexes(classLoader, paramFile2, MultiDexExtractor.load(paramContext, paramFile1, paramFile2, paramString2, false));
        return;
      } catch (RuntimeException paramContext) {
        Log.w("MultiDex", "Failure while trying to obtain Context class loader. Must be running in test mode. Skip patching.", paramContext);
        return;
      } 
    } 
  }
  
  private static void expandFieldArray(Object paramObject, String paramString, Object[] paramArrayOfObject) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
    Field field = findField(paramObject, paramString);
    Object[] arrayOfObject1 = (Object[])field.get(paramObject);
    Object[] arrayOfObject2 = (Object[])Array.newInstance(arrayOfObject1.getClass().getComponentType(), arrayOfObject1.length + paramArrayOfObject.length);
    System.arraycopy(arrayOfObject1, 0, arrayOfObject2, 0, arrayOfObject1.length);
    System.arraycopy(paramArrayOfObject, 0, arrayOfObject2, arrayOfObject1.length, paramArrayOfObject.length);
    field.set(paramObject, arrayOfObject2);
  }
  
  private static Field findField(Object paramObject, String paramString) throws NoSuchFieldException {
    Class clazz = paramObject.getClass();
    while (true) {
      if (clazz != null)
        try {
          Field field = clazz.getDeclaredField(paramString);
          if (!field.isAccessible())
            field.setAccessible(true); 
          return field;
        } catch (NoSuchFieldException noSuchFieldException) {
          clazz = clazz.getSuperclass();
          continue;
        }  
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append("Field ");
      stringBuilder.append(paramString);
      stringBuilder.append(" not found in ");
      stringBuilder.append(paramObject.getClass());
      paramObject = new NoSuchFieldException(stringBuilder.toString());
      throw paramObject;
    } 
  }
  
  private static Method findMethod(Object paramObject, String paramString, Class<?>... paramVarArgs) throws NoSuchMethodException {
    Class clazz = paramObject.getClass();
    while (true) {
      if (clazz != null)
        try {
          Method method = clazz.getDeclaredMethod(paramString, paramVarArgs);
          if (!method.isAccessible())
            method.setAccessible(true); 
          return method;
        } catch (NoSuchMethodException noSuchMethodException) {
          clazz = clazz.getSuperclass();
          continue;
        }  
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append("Method ");
      stringBuilder.append(paramString);
      stringBuilder.append(" with parameters ");
      stringBuilder.append(Arrays.asList(paramVarArgs));
      stringBuilder.append(" not found in ");
      stringBuilder.append(paramObject.getClass());
      paramObject = new NoSuchMethodException(stringBuilder.toString());
      throw paramObject;
    } 
  }
  
  private static ApplicationInfo getApplicationInfo(Context paramContext) {
    try {
      return paramContext.getApplicationInfo();
    } catch (RuntimeException paramContext) {
      Log.w("MultiDex", "Failure while trying to obtain ApplicationInfo from Context. Must be running in test mode. Skip patching.", paramContext);
      return null;
    } 
  }
  
  private static File getDexDir(Context paramContext, File paramFile, String paramString) throws IOException {
    paramFile = new File(paramFile, "code_cache");
    try {
      mkdirChecked(paramFile);
      file = paramFile;
    } catch (IOException paramFile) {
      file = new File(file.getFilesDir(), "code_cache");
      mkdirChecked(file);
    } 
    File file = new File(file, paramString);
    mkdirChecked(file);
    return file;
  }
  
  public static void install(Context paramContext) throws Exception {
    Log.i("MultiDex", "Installing application");
    if (IS_VM_MULTIDEX_CAPABLE) {
      Log.i("MultiDex", "VM has multidex support, MultiDex support library is disabled.");
      return;
    } 
    if (Build.VERSION.SDK_INT >= 4)
      try {
        ApplicationInfo applicationInfo = getApplicationInfo(paramContext);
        if (applicationInfo == null) {
          Log.i("MultiDex", "No ApplicationInfo available, i.e. running on a test Context: MultiDex support library is disabled.");
          return;
        } 
        doInstallation(paramContext, new File(applicationInfo.sourceDir), new File(applicationInfo.dataDir), "secondary-dexes", "");
        Log.i("MultiDex", "install done");
        return;
      } catch (Exception paramContext) {
        Log.e("MultiDex", "MultiDex installation failure", paramContext);
        StringBuilder stringBuilder1 = new StringBuilder();
        stringBuilder1.append("MultiDex installation failed (");
        stringBuilder1.append(paramContext.getMessage());
        stringBuilder1.append(").");
        throw new RuntimeException(stringBuilder1.toString());
      }  
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("MultiDex installation failed. SDK ");
    stringBuilder.append(Build.VERSION.SDK_INT);
    stringBuilder.append(" is unsupported. Min SDK version is ");
    stringBuilder.append(4);
    stringBuilder.append(".");
    throw new RuntimeException(stringBuilder.toString());
  }
  
  public static void installInstrumentation(Context paramContext1, Context paramContext2) {
    Log.i("MultiDex", "Installing instrumentation");
    if (IS_VM_MULTIDEX_CAPABLE) {
      Log.i("MultiDex", "VM has multidex support, MultiDex support library is disabled.");
      return;
    } 
    if (Build.VERSION.SDK_INT >= 4)
      try {
        ApplicationInfo applicationInfo2 = getApplicationInfo(paramContext1);
        if (applicationInfo2 == null) {
          Log.i("MultiDex", "No ApplicationInfo available for instrumentation, i.e. running on a test Context: MultiDex support library is disabled.");
          return;
        } 
        ApplicationInfo applicationInfo1 = getApplicationInfo(paramContext2);
        if (applicationInfo1 == null) {
          Log.i("MultiDex", "No ApplicationInfo available, i.e. running on a test Context: MultiDex support library is disabled.");
          return;
        } 
        StringBuilder stringBuilder1 = new StringBuilder();
        stringBuilder1.append(paramContext1.getPackageName());
        stringBuilder1.append(".");
        String str = stringBuilder1.toString();
        File file2 = new File(applicationInfo1.dataDir);
        File file1 = new File(applicationInfo2.sourceDir);
        StringBuilder stringBuilder2 = new StringBuilder();
        stringBuilder2.append(str);
        stringBuilder2.append("secondary-dexes");
        doInstallation(paramContext2, file1, file2, stringBuilder2.toString(), str);
        doInstallation(paramContext2, new File(applicationInfo1.sourceDir), file2, "secondary-dexes", "");
        Log.i("MultiDex", "Installation done");
        return;
      } catch (Exception paramContext1) {
        Log.e("MultiDex", "MultiDex installation failure", paramContext1);
        StringBuilder stringBuilder1 = new StringBuilder();
        stringBuilder1.append("MultiDex installation failed (");
        stringBuilder1.append(paramContext1.getMessage());
        stringBuilder1.append(").");
        throw new RuntimeException(stringBuilder1.toString());
      }  
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("MultiDex installation failed. SDK ");
    stringBuilder.append(Build.VERSION.SDK_INT);
    stringBuilder.append(" is unsupported. Min SDK version is ");
    stringBuilder.append(4);
    stringBuilder.append(".");
    throw new RuntimeException(stringBuilder.toString());
  }
  
  private static void installSecondaryDexes(ClassLoader paramClassLoader, File paramFile, List<? extends File> paramList) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException {
    if (!paramList.isEmpty()) {
      if (Build.VERSION.SDK_INT >= 19) {
        V19.access$000(paramClassLoader, paramList, paramFile);
        return;
      } 
      if (Build.VERSION.SDK_INT >= 14) {
        V14.access$100(paramClassLoader, paramList, paramFile);
        return;
      } 
      V4.access$200(paramClassLoader, paramList);
    } 
  }
  
  static boolean isVMMultidexCapable(String paramString) { // Byte code:
    //   0: iconst_0
    //   1: istore #4
    //   3: iload #4
    //   5: istore_3
    //   6: aload_0
    //   7: ifnull -> 76
    //   10: ldc_w '(\d+)\.(\d+)(\.\d+)?'
    //   13: invokestatic compile : (Ljava/lang/String;)Ljava/util/regex/Pattern;
    //   16: aload_0
    //   17: invokevirtual matcher : (Ljava/lang/CharSequence;)Ljava/util/regex/Matcher;
    //   20: astore #5
    //   22: iload #4
    //   24: istore_3
    //   25: aload #5
    //   27: invokevirtual matches : ()Z
    //   30: ifeq -> 76
    //   33: aload #5
    //   35: iconst_1
    //   36: invokevirtual group : (I)Ljava/lang/String;
    //   39: invokestatic parseInt : (Ljava/lang/String;)I
    //   42: istore_1
    //   43: aload #5
    //   45: iconst_2
    //   46: invokevirtual group : (I)Ljava/lang/String;
    //   49: invokestatic parseInt : (Ljava/lang/String;)I
    //   52: istore_2
    //   53: iload_1
    //   54: iconst_2
    //   55: if_icmpgt -> 74
    //   58: iload #4
    //   60: istore_3
    //   61: iload_1
    //   62: iconst_2
    //   63: if_icmpne -> 76
    //   66: iload #4
    //   68: istore_3
    //   69: iload_2
    //   70: iconst_1
    //   71: if_icmplt -> 76
    //   74: iconst_1
    //   75: istore_3
    //   76: new java/lang/StringBuilder
    //   79: dup
    //   80: invokespecial <init> : ()V
    //   83: astore #5
    //   85: aload #5
    //   87: ldc_w 'VM with version '
    //   90: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   93: pop
    //   94: aload #5
    //   96: aload_0
    //   97: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   100: pop
    //   101: iload_3
    //   102: ifeq -> 112
    //   105: ldc_w ' has multidex support'
    //   108: astore_0
    //   109: goto -> 116
    //   112: ldc_w ' does not have multidex support'
    //   115: astore_0
    //   116: aload #5
    //   118: aload_0
    //   119: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   122: pop
    //   123: ldc 'MultiDex'
    //   125: aload #5
    //   127: invokevirtual toString : ()Ljava/lang/String;
    //   130: invokestatic i : (Ljava/lang/String;Ljava/lang/String;)I
    //   133: pop
    //   134: iload_3
    //   135: ireturn
    //   136: astore #5
    //   138: iload #4
    //   140: istore_3
    //   141: goto -> 76
    // Exception table:
    //   from	to	target	type
    //   33	53	136	java/lang/NumberFormatException }
  
  private static void mkdirChecked(File paramFile) throws IOException {
    paramFile.mkdir();
    if (!paramFile.isDirectory()) {
      StringBuilder stringBuilder = paramFile.getParentFile();
      if (stringBuilder == null) {
        stringBuilder = new StringBuilder();
        stringBuilder.append("Failed to create dir ");
        stringBuilder.append(paramFile.getPath());
        stringBuilder.append(". Parent file is null.");
        Log.e("MultiDex", stringBuilder.toString());
      } else {
        StringBuilder stringBuilder1 = new StringBuilder();
        stringBuilder1.append("Failed to create dir ");
        stringBuilder1.append(paramFile.getPath());
        stringBuilder1.append(". parent file is a dir ");
        stringBuilder1.append(stringBuilder.isDirectory());
        stringBuilder1.append(", a file ");
        stringBuilder1.append(stringBuilder.isFile());
        stringBuilder1.append(", exists ");
        stringBuilder1.append(stringBuilder.exists());
        stringBuilder1.append(", readable ");
        stringBuilder1.append(stringBuilder.canRead());
        stringBuilder1.append(", writable ");
        stringBuilder1.append(stringBuilder.canWrite());
        Log.e("MultiDex", stringBuilder1.toString());
      } 
      stringBuilder = new StringBuilder();
      stringBuilder.append("Failed to create directory ");
      stringBuilder.append(paramFile.getPath());
      throw new IOException(stringBuilder.toString());
    } 
  }
}

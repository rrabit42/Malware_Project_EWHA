package com.bumptech.glide.load.engine;

import android.os.Looper;
import android.util.Log;
import com.bumptech.glide.Priority;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.engine.cache.DiskCache;
import com.bumptech.glide.load.engine.cache.MemoryCache;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.DataLoadProvider;
import com.bumptech.glide.request.ResourceCallback;
import com.bumptech.glide.util.LogTime;
import com.bumptech.glide.util.Util;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;

public class Engine implements EngineJobListener, MemoryCache.ResourceRemovedListener, EngineResource.ResourceListener {
  private static final String TAG = "Engine";
  
  private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
  
  private final MemoryCache cache;
  
  private final LazyDiskCacheProvider diskCacheProvider;
  
  private final EngineJobFactory engineJobFactory;
  
  private final Map<Key, EngineJob> jobs;
  
  private final EngineKeyFactory keyFactory;
  
  private final ResourceRecycler resourceRecycler;
  
  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
  
  public Engine(MemoryCache paramMemoryCache, DiskCache.Factory paramFactory, ExecutorService paramExecutorService1, ExecutorService paramExecutorService2) { this(paramMemoryCache, paramFactory, paramExecutorService1, paramExecutorService2, null, null, null, null, null); }
  
  Engine(MemoryCache paramMemoryCache, DiskCache.Factory paramFactory, ExecutorService paramExecutorService1, ExecutorService paramExecutorService2, Map<Key, EngineJob> paramMap1, EngineKeyFactory paramEngineKeyFactory, Map<Key, WeakReference<EngineResource<?>>> paramMap2, EngineJobFactory paramEngineJobFactory, ResourceRecycler paramResourceRecycler) {
    this.cache = paramMemoryCache;
    this.diskCacheProvider = new LazyDiskCacheProvider(paramFactory);
    Map<Key, WeakReference<EngineResource<?>>> map2 = paramMap2;
    if (paramMap2 == null)
      map2 = new HashMap<Key, WeakReference<EngineResource<?>>>(); 
    this.activeResources = map2;
    EngineKeyFactory engineKeyFactory = paramEngineKeyFactory;
    if (paramEngineKeyFactory == null)
      engineKeyFactory = new EngineKeyFactory(); 
    this.keyFactory = engineKeyFactory;
    Map<Key, EngineJob> map1 = paramMap1;
    if (paramMap1 == null)
      map1 = new HashMap<Key, EngineJob>(); 
    this.jobs = map1;
    EngineJobFactory engineJobFactory1 = paramEngineJobFactory;
    if (paramEngineJobFactory == null)
      engineJobFactory1 = new EngineJobFactory(paramExecutorService1, paramExecutorService2, this); 
    this.engineJobFactory = engineJobFactory1;
    ResourceRecycler resourceRecycler1 = paramResourceRecycler;
    if (paramResourceRecycler == null)
      resourceRecycler1 = new ResourceRecycler(); 
    this.resourceRecycler = resourceRecycler1;
    paramMemoryCache.setResourceRemovedListener(this);
  }
  
  private EngineResource<?> getEngineResourceFromCache(Key paramKey) {
    Resource resource = this.cache.remove(paramKey);
    return (resource == null) ? null : ((resource instanceof EngineResource) ? (EngineResource)resource : new EngineResource(resource, true));
  }
  
  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
    if (this.resourceReferenceQueue == null) {
      this.resourceReferenceQueue = new ReferenceQueue();
      Looper.myQueue().addIdleHandler(new RefQueueIdleHandler(this.activeResources, this.resourceReferenceQueue));
    } 
    return this.resourceReferenceQueue;
  }
  
  private EngineResource<?> loadFromActiveResources(Key paramKey, boolean paramBoolean) {
    EngineResource engineResource = null;
    if (!paramBoolean)
      return null; 
    WeakReference weakReference = (WeakReference)this.activeResources.get(paramKey);
    if (weakReference != null) {
      engineResource = (EngineResource)weakReference.get();
      if (engineResource != null) {
        engineResource.acquire();
        return engineResource;
      } 
      this.activeResources.remove(paramKey);
    } 
    return engineResource;
  }
  
  private EngineResource<?> loadFromCache(Key paramKey, boolean paramBoolean) {
    if (!paramBoolean)
      return null; 
    EngineResource engineResource = getEngineResourceFromCache(paramKey);
    if (engineResource != null) {
      engineResource.acquire();
      this.activeResources.put(paramKey, new ResourceWeakReference(paramKey, engineResource, getReferenceQueue()));
    } 
    return engineResource;
  }
  
  private static void logWithTimeAndKey(String paramString, long paramLong, Key paramKey) {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(paramString);
    stringBuilder.append(" in ");
    stringBuilder.append(LogTime.getElapsedMillis(paramLong));
    stringBuilder.append("ms, key: ");
    stringBuilder.append(paramKey);
    Log.v("Engine", stringBuilder.toString());
  }
  
  public void clearDiskCache() { this.diskCacheProvider.getDiskCache().clear(); }
  
  public <T, Z, R> LoadStatus load(Key paramKey, int paramInt1, int paramInt2, DataFetcher<T> paramDataFetcher, DataLoadProvider<T, Z> paramDataLoadProvider, Transformation<Z> paramTransformation, ResourceTranscoder<Z, R> paramResourceTranscoder, Priority paramPriority, boolean paramBoolean, DiskCacheStrategy paramDiskCacheStrategy, ResourceCallback paramResourceCallback) {
    Util.assertMainThread();
    long l = LogTime.getLogTime();
    String str = paramDataFetcher.getId();
    EngineKey engineKey = this.keyFactory.buildKey(str, paramKey, paramInt1, paramInt2, paramDataLoadProvider.getCacheDecoder(), paramDataLoadProvider.getSourceDecoder(), paramTransformation, paramDataLoadProvider.getEncoder(), paramResourceTranscoder, paramDataLoadProvider.getSourceEncoder());
    EngineResource engineResource = loadFromCache(engineKey, paramBoolean);
    if (engineResource != null) {
      paramResourceCallback.onResourceReady(engineResource);
      if (Log.isLoggable("Engine", 2))
        logWithTimeAndKey("Loaded resource from cache", l, engineKey); 
      return null;
    } 
    engineResource = loadFromActiveResources(engineKey, paramBoolean);
    if (engineResource != null) {
      paramResourceCallback.onResourceReady(engineResource);
      if (Log.isLoggable("Engine", 2))
        logWithTimeAndKey("Loaded resource from active resources", l, engineKey); 
      return null;
    } 
    EngineJob engineJob = (EngineJob)this.jobs.get(engineKey);
    if (engineJob != null) {
      engineJob.addCallback(paramResourceCallback);
      if (Log.isLoggable("Engine", 2))
        logWithTimeAndKey("Added to existing load", l, engineKey); 
      return new LoadStatus(paramResourceCallback, engineJob);
    } 
    engineJob = this.engineJobFactory.build(engineKey, paramBoolean);
    EngineRunnable engineRunnable = new EngineRunnable(engineJob, new DecodeJob(engineKey, paramInt1, paramInt2, paramDataFetcher, paramDataLoadProvider, paramTransformation, paramResourceTranscoder, this.diskCacheProvider, paramDiskCacheStrategy, paramPriority), paramPriority);
    this.jobs.put(engineKey, engineJob);
    engineJob.addCallback(paramResourceCallback);
    engineJob.start(engineRunnable);
    if (Log.isLoggable("Engine", 2))
      logWithTimeAndKey("Started new load", l, engineKey); 
    return new LoadStatus(paramResourceCallback, engineJob);
  }
  
  public void onEngineJobCancelled(EngineJob paramEngineJob, Key paramKey) {
    Util.assertMainThread();
    if (paramEngineJob.equals((EngineJob)this.jobs.get(paramKey)))
      this.jobs.remove(paramKey); 
  }
  
  public void onEngineJobComplete(Key paramKey, EngineResource<?> paramEngineResource) {
    Util.assertMainThread();
    if (paramEngineResource != null) {
      paramEngineResource.setResourceListener(paramKey, this);
      if (paramEngineResource.isCacheable())
        this.activeResources.put(paramKey, new ResourceWeakReference(paramKey, paramEngineResource, getReferenceQueue())); 
    } 
    this.jobs.remove(paramKey);
  }
  
  public void onResourceReleased(Key paramKey, EngineResource paramEngineResource) {
    Util.assertMainThread();
    this.activeResources.remove(paramKey);
    if (paramEngineResource.isCacheable()) {
      this.cache.put(paramKey, paramEngineResource);
      return;
    } 
    this.resourceRecycler.recycle(paramEngineResource);
  }
  
  public void onResourceRemoved(Resource<?> paramResource) {
    Util.assertMainThread();
    this.resourceRecycler.recycle(paramResource);
  }
  
  public void release(Resource paramResource) {
    Util.assertMainThread();
    if (paramResource instanceof EngineResource) {
      ((EngineResource)paramResource).release();
      return;
    } 
    throw new IllegalArgumentException("Cannot release anything but an EngineResource");
  }
}

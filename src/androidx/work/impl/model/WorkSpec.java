package androidx.work.impl.model;

import android.arch.core.util.Function;
import android.arch.persistence.room.ColumnInfo;
import android.arch.persistence.room.Embedded;
import android.arch.persistence.room.Entity;
import android.arch.persistence.room.Index;
import android.arch.persistence.room.PrimaryKey;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.annotation.RestrictTo;
import androidx.work.BackoffPolicy;
import androidx.work.Constraints;
import androidx.work.Data;
import androidx.work.Logger;
import androidx.work.WorkInfo;
import java.util.List;

@Entity(indices = {@Index({"schedule_requested_at"})})
@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class WorkSpec {
  public static final long SCHEDULE_NOT_REQUESTED_YET = -1L;
  
  private static final String TAG = Logger.tagWithPrefix("WorkSpec");
  
  public static final Function<List<WorkInfoPojo>, List<WorkInfo>> WORK_INFO_MAPPER = new Object();
  
  @ColumnInfo(name = "backoff_delay_duration")
  public long backoffDelayDuration = 30000L;
  
  @ColumnInfo(name = "backoff_policy")
  @NonNull
  public BackoffPolicy backoffPolicy = BackoffPolicy.EXPONENTIAL;
  
  @Embedded
  @NonNull
  public Constraints constraints = Constraints.NONE;
  
  @ColumnInfo(name = "flex_duration")
  public long flexDuration;
  
  @ColumnInfo(name = "id")
  @PrimaryKey
  @NonNull
  public String id;
  
  @ColumnInfo(name = "initial_delay")
  public long initialDelay;
  
  @ColumnInfo(name = "input")
  @NonNull
  public Data input = Data.EMPTY;
  
  @ColumnInfo(name = "input_merger_class_name")
  public String inputMergerClassName;
  
  @ColumnInfo(name = "interval_duration")
  public long intervalDuration;
  
  @ColumnInfo(name = "minimum_retention_duration")
  public long minimumRetentionDuration;
  
  @ColumnInfo(name = "output")
  @NonNull
  public Data output = Data.EMPTY;
  
  @ColumnInfo(name = "period_start_time")
  public long periodStartTime;
  
  @ColumnInfo(name = "run_attempt_count")
  public int runAttemptCount;
  
  @ColumnInfo(name = "schedule_requested_at")
  public long scheduleRequestedAt = -1L;
  
  @ColumnInfo(name = "state")
  @NonNull
  public WorkInfo.State state = WorkInfo.State.ENQUEUED;
  
  @ColumnInfo(name = "worker_class_name")
  @NonNull
  public String workerClassName;
  
  public WorkSpec(@NonNull WorkSpec paramWorkSpec) {
    this.id = paramWorkSpec.id;
    this.workerClassName = paramWorkSpec.workerClassName;
    this.state = paramWorkSpec.state;
    this.inputMergerClassName = paramWorkSpec.inputMergerClassName;
    this.input = new Data(paramWorkSpec.input);
    this.output = new Data(paramWorkSpec.output);
    this.initialDelay = paramWorkSpec.initialDelay;
    this.intervalDuration = paramWorkSpec.intervalDuration;
    this.flexDuration = paramWorkSpec.flexDuration;
    this.constraints = new Constraints(paramWorkSpec.constraints);
    this.runAttemptCount = paramWorkSpec.runAttemptCount;
    this.backoffPolicy = paramWorkSpec.backoffPolicy;
    this.backoffDelayDuration = paramWorkSpec.backoffDelayDuration;
    this.periodStartTime = paramWorkSpec.periodStartTime;
    this.minimumRetentionDuration = paramWorkSpec.minimumRetentionDuration;
    this.scheduleRequestedAt = paramWorkSpec.scheduleRequestedAt;
  }
  
  public WorkSpec(@NonNull String paramString1, @NonNull String paramString2) {
    this.id = paramString1;
    this.workerClassName = paramString2;
  }
  
  public long calculateNextRunTime() {
    boolean bool = isBackedOff();
    byte b2 = 0;
    byte b1 = 0;
    if (bool) {
      long l;
      if (this.backoffPolicy == BackoffPolicy.LINEAR)
        b1 = 1; 
      if (b1) {
        l = this.backoffDelayDuration * this.runAttemptCount;
      } else {
        l = (long)Math.scalb((float)this.backoffDelayDuration, this.runAttemptCount - 1);
      } 
      return this.periodStartTime + Math.min(18000000L, l);
    } 
    if (isPeriodic()) {
      if (Build.VERSION.SDK_INT <= 22) {
        b1 = b2;
        if (this.flexDuration != this.intervalDuration)
          b1 = 1; 
        if (b1 != 0) {
          long l1;
          if (this.periodStartTime == 0L) {
            l1 = -1L * this.flexDuration;
          } else {
            l1 = 0L;
          } 
          long l3 = this.periodStartTime;
          long l2 = l3;
          if (l3 == 0L)
            l2 = System.currentTimeMillis(); 
          return l2 + this.intervalDuration + l1;
        } 
        return this.periodStartTime + this.intervalDuration;
      } 
      return this.periodStartTime + this.intervalDuration - this.flexDuration;
    } 
    return this.periodStartTime + this.initialDelay;
  }
  
  public boolean equals(Object paramObject) {
    if (this == paramObject)
      return true; 
    if (paramObject != null) {
      if (getClass() != paramObject.getClass())
        return false; 
      paramObject = (WorkSpec)paramObject;
      if (this.initialDelay != paramObject.initialDelay)
        return false; 
      if (this.intervalDuration != paramObject.intervalDuration)
        return false; 
      if (this.flexDuration != paramObject.flexDuration)
        return false; 
      if (this.runAttemptCount != paramObject.runAttemptCount)
        return false; 
      if (this.backoffDelayDuration != paramObject.backoffDelayDuration)
        return false; 
      if (this.periodStartTime != paramObject.periodStartTime)
        return false; 
      if (this.minimumRetentionDuration != paramObject.minimumRetentionDuration)
        return false; 
      if (this.scheduleRequestedAt != paramObject.scheduleRequestedAt)
        return false; 
      if (!this.id.equals(paramObject.id))
        return false; 
      if (this.state != paramObject.state)
        return false; 
      if (!this.workerClassName.equals(paramObject.workerClassName))
        return false; 
      String str = this.inputMergerClassName;
      if (str != null) {
        if (!str.equals(paramObject.inputMergerClassName))
          return false; 
      } else if (paramObject.inputMergerClassName != null) {
        return false;
      } 
      return !this.input.equals(paramObject.input) ? false : (!this.output.equals(paramObject.output) ? false : (!this.constraints.equals(paramObject.constraints) ? false : ((this.backoffPolicy == paramObject.backoffPolicy))));
    } 
    return false;
  }
  
  public boolean hasConstraints() { return Constraints.NONE.equals(this.constraints) ^ true; }
  
  public int hashCode() {
    int i;
    int j = this.id.hashCode();
    int k = this.state.hashCode();
    int m = this.workerClassName.hashCode();
    String str = this.inputMergerClassName;
    if (str != null) {
      i = str.hashCode();
    } else {
      i = 0;
    } 
    int n = this.input.hashCode();
    int i1 = this.output.hashCode();
    long l = this.initialDelay;
    int i2 = (int)(l ^ l >>> 32);
    l = this.intervalDuration;
    int i3 = (int)(l ^ l >>> 32);
    l = this.flexDuration;
    int i4 = (int)(l ^ l >>> 32);
    int i5 = this.constraints.hashCode();
    int i6 = this.runAttemptCount;
    int i7 = this.backoffPolicy.hashCode();
    l = this.backoffDelayDuration;
    int i8 = (int)(l ^ l >>> 32);
    l = this.periodStartTime;
    int i9 = (int)(l ^ l >>> 32);
    l = this.minimumRetentionDuration;
    int i10 = (int)(l ^ l >>> 32);
    l = this.scheduleRequestedAt;
    return ((((((((((((((j * 31 + k) * 31 + m) * 31 + i) * 31 + n) * 31 + i1) * 31 + i2) * 31 + i3) * 31 + i4) * 31 + i5) * 31 + i6) * 31 + i7) * 31 + i8) * 31 + i9) * 31 + i10) * 31 + (int)(l ^ l >>> 32);
  }
  
  public boolean isBackedOff() { return (this.state == WorkInfo.State.ENQUEUED && this.runAttemptCount > 0); }
  
  public boolean isPeriodic() { return (this.intervalDuration != 0L); }
  
  public void setBackoffDelayDuration(long paramLong) {
    long l = paramLong;
    if (paramLong > 18000000L) {
      Logger.get().warning(TAG, "Backoff delay duration exceeds maximum value", new Throwable[0]);
      l = 18000000L;
    } 
    paramLong = l;
    if (l < 10000L) {
      Logger.get().warning(TAG, "Backoff delay duration less than minimum value", new Throwable[0]);
      paramLong = 10000L;
    } 
    this.backoffDelayDuration = paramLong;
  }
  
  public void setPeriodic(long paramLong) {
    long l = paramLong;
    if (paramLong < 900000L) {
      Logger.get().warning(TAG, String.format("Interval duration lesser than minimum allowed value; Changed to %s", new Object[] { Long.valueOf(900000L) }), new Throwable[0]);
      l = 900000L;
    } 
    setPeriodic(l, l);
  }
  
  public void setPeriodic(long paramLong1, long paramLong2) {
    long l = paramLong1;
    if (paramLong1 < 900000L) {
      Logger.get().warning(TAG, String.format("Interval duration lesser than minimum allowed value; Changed to %s", new Object[] { Long.valueOf(900000L) }), new Throwable[0]);
      l = 900000L;
    } 
    paramLong1 = paramLong2;
    if (paramLong2 < 300000L) {
      Logger.get().warning(TAG, String.format("Flex duration lesser than minimum allowed value; Changed to %s", new Object[] { Long.valueOf(300000L) }), new Throwable[0]);
      paramLong1 = 300000L;
    } 
    paramLong2 = paramLong1;
    if (paramLong1 > l) {
      Logger.get().warning(TAG, String.format("Flex duration greater than interval duration; Changed to %s", new Object[] { Long.valueOf(l) }), new Throwable[0]);
      paramLong2 = l;
    } 
    this.intervalDuration = l;
    this.flexDuration = paramLong2;
  }
  
  public String toString() {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("{WorkSpec: ");
    stringBuilder.append(this.id);
    stringBuilder.append("}");
    return stringBuilder.toString();
  }
}

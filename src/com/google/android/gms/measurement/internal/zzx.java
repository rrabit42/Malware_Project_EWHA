package com.google.android.gms.measurement.internal;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.support.annotation.WorkerThread;
import android.text.TextUtils;
import java.io.File;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public final class zzx {
  static void zza(zzas paramzzas, SQLiteDatabase paramSQLiteDatabase) {
    if (paramzzas != null) {
      File file = new File(paramSQLiteDatabase.getPath());
      if (!file.setReadable(false, false))
        paramzzas.zzjj().zzby("Failed to turn off database read permission"); 
      if (!file.setWritable(false, false))
        paramzzas.zzjj().zzby("Failed to turn off database write permission"); 
      if (!file.setReadable(true, true))
        paramzzas.zzjj().zzby("Failed to turn on database read permission for owner"); 
      if (!file.setWritable(true, true))
        paramzzas.zzjj().zzby("Failed to turn on database write permission for owner"); 
      return;
    } 
    throw new IllegalArgumentException("Monitor must not be null");
  }
  
  @WorkerThread
  static void zza(zzas paramzzas, SQLiteDatabase paramSQLiteDatabase, String paramString1, String paramString2, String paramString3, String[] paramArrayOfString) throws SQLiteException {
    if (paramzzas != null) {
      if (!zza(paramzzas, paramSQLiteDatabase, paramString1))
        paramSQLiteDatabase.execSQL(paramString2); 
      if (paramzzas != null)
        try {
          StringBuilder stringBuilder;
          Set set = zzb(paramSQLiteDatabase, paramString1);
          String[] arrayOfString = paramString3.split(",");
          int i = arrayOfString.length;
          byte b2 = 0;
          byte b1 = 0;
          while (b1 < i) {
            paramString3 = arrayOfString[b1];
            if (set.remove(paramString3)) {
              b1++;
              continue;
            } 
            stringBuilder = new StringBuilder(String.valueOf(paramString1).length() + 35 + String.valueOf(paramString3).length());
            stringBuilder.append("Table ");
            stringBuilder.append(paramString1);
            stringBuilder.append(" is missing required column: ");
            stringBuilder.append(paramString3);
            throw new SQLiteException(stringBuilder.toString());
          } 
          if (paramArrayOfString != null) {
            for (b1 = b2;; b1 += 2) {
              if (b1 < paramArrayOfString.length) {
                if (!set.remove(paramArrayOfString[b1]))
                  stringBuilder.execSQL(paramArrayOfString[b1 + 1]); 
                continue;
              } 
              if (!set.isEmpty()) {
                paramzzas.zzjj().zze("Table has extra columns. table, columns", paramString1, TextUtils.join(", ", set));
                return;
              } 
              break;
            } 
            return;
          } 
          if (!set.isEmpty()) {
            paramzzas.zzjj().zze("Table has extra columns. table, columns", paramString1, TextUtils.join(", ", set));
            return;
          } 
          break;
        } catch (SQLiteException paramSQLiteDatabase) {
          paramzzas.zzjg().zzg("Failed to verify columns on table that was just created", paramString1);
          throw paramSQLiteDatabase;
        }  
      throw new IllegalArgumentException("Monitor must not be null");
    } 
    IllegalArgumentException illegalArgumentException = new IllegalArgumentException("Monitor must not be null");
    throw illegalArgumentException;
  }
  
  @WorkerThread
  private static boolean zza(zzas paramzzas, SQLiteDatabase paramSQLiteDatabase, String paramString) {
    if (paramzzas != null) {
      Cursor cursor2 = null;
      Cursor cursor1 = null;
      try {
        Cursor cursor = paramSQLiteDatabase.query("SQLITE_MASTER", new String[] { "name" }, "name=?", new String[] { paramString }, null, null, null);
        cursor1 = cursor;
        cursor2 = cursor;
        boolean bool = cursor.moveToFirst();
        if (cursor != null)
          cursor.close(); 
        return bool;
      } catch (SQLiteException paramSQLiteDatabase) {
        cursor1 = cursor2;
        paramzzas.zzjj().zze("Error querying for table", paramString, paramSQLiteDatabase);
        if (cursor2 != null)
          cursor2.close(); 
        return false;
      } finally {}
      if (cursor1 != null)
        cursor1.close(); 
      throw paramzzas;
    } 
    throw new IllegalArgumentException("Monitor must not be null");
  }
  
  @WorkerThread
  private static Set<String> zzb(SQLiteDatabase paramSQLiteDatabase, String paramString) {
    hashSet = new HashSet();
    StringBuilder stringBuilder = new StringBuilder(String.valueOf(paramString).length() + 22);
    stringBuilder.append("SELECT * FROM ");
    stringBuilder.append(paramString);
    stringBuilder.append(" LIMIT 0");
    cursor = paramSQLiteDatabase.rawQuery(stringBuilder.toString(), null);
    try {
      Collections.addAll(hashSet, cursor.getColumnNames());
      return hashSet;
    } finally {
      cursor.close();
    } 
  }
}

package androidx.work.impl.background.greedy;

import android.content.Context;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.annotation.RestrictTo;
import android.support.annotation.VisibleForTesting;
import android.text.TextUtils;
import androidx.work.Logger;
import androidx.work.WorkInfo;
import androidx.work.impl.ExecutionListener;
import androidx.work.impl.Scheduler;
import androidx.work.impl.WorkManagerImpl;
import androidx.work.impl.constraints.WorkConstraintsCallback;
import androidx.work.impl.constraints.WorkConstraintsTracker;
import androidx.work.impl.model.WorkSpec;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class GreedyScheduler implements Scheduler, WorkConstraintsCallback, ExecutionListener {
  private static final String TAG = Logger.tagWithPrefix("GreedyScheduler");
  
  private List<WorkSpec> mConstrainedWorkSpecs = new ArrayList();
  
  private final Object mLock;
  
  private boolean mRegisteredExecutionListener;
  
  private WorkConstraintsTracker mWorkConstraintsTracker;
  
  private WorkManagerImpl mWorkManagerImpl;
  
  public GreedyScheduler(Context paramContext, WorkManagerImpl paramWorkManagerImpl) {
    this.mWorkManagerImpl = paramWorkManagerImpl;
    this.mWorkConstraintsTracker = new WorkConstraintsTracker(paramContext, this);
    this.mLock = new Object();
  }
  
  @VisibleForTesting
  public GreedyScheduler(WorkManagerImpl paramWorkManagerImpl, WorkConstraintsTracker paramWorkConstraintsTracker) {
    this.mWorkManagerImpl = paramWorkManagerImpl;
    this.mWorkConstraintsTracker = paramWorkConstraintsTracker;
    this.mLock = new Object();
  }
  
  private void registerExecutionListenerIfNeeded() {
    if (!this.mRegisteredExecutionListener) {
      this.mWorkManagerImpl.getProcessor().addExecutionListener(this);
      this.mRegisteredExecutionListener = true;
    } 
  }
  
  private void removeConstraintTrackingFor(@NonNull String paramString) {
    synchronized (this.mLock) {
      int i = this.mConstrainedWorkSpecs.size();
      byte b = 0;
      while (true) {
        if (b < i)
          if (((WorkSpec)this.mConstrainedWorkSpecs.get(b)).id.equals(paramString)) {
            Logger.get().debug(TAG, String.format("Stopping tracking for %s", new Object[] { paramString }), new Throwable[0]);
            this.mConstrainedWorkSpecs.remove(b);
            this.mWorkConstraintsTracker.replace(this.mConstrainedWorkSpecs);
          } else {
            b++;
            continue;
          }  
        return;
      } 
    } 
  }
  
  public void cancel(@NonNull String paramString) {
    registerExecutionListenerIfNeeded();
    Logger.get().debug(TAG, String.format("Cancelling work ID %s", new Object[] { paramString }), new Throwable[0]);
    this.mWorkManagerImpl.stopWork(paramString);
  }
  
  public void onAllConstraintsMet(@NonNull List<String> paramList) {
    Iterator iterator = paramList.iterator();
    while (iterator.hasNext()) {
      String str;
      Logger.get().debug(TAG, (str = (String)iterator.next()).format("Constraints met: Scheduling work ID %s", new Object[] { str }), new Throwable[0]);
      this.mWorkManagerImpl.startWork(str);
    } 
  }
  
  public void onAllConstraintsNotMet(@NonNull List<String> paramList) {
    Iterator iterator = paramList.iterator();
    while (iterator.hasNext()) {
      String str;
      Logger.get().debug(TAG, (str = (String)iterator.next()).format("Constraints not met: Cancelling work ID %s", new Object[] { str }), new Throwable[0]);
      this.mWorkManagerImpl.stopWork(str);
    } 
  }
  
  public void onExecuted(@NonNull String paramString, boolean paramBoolean) { removeConstraintTrackingFor(paramString); }
  
  public void schedule(WorkSpec... paramVarArgs) {
    registerExecutionListenerIfNeeded();
    null = new ArrayList();
    ArrayList arrayList = new ArrayList();
    int i = paramVarArgs.length;
    for (byte b = 0; b < i; b++) {
      WorkSpec workSpec = paramVarArgs[b];
      if (workSpec.state == WorkInfo.State.ENQUEUED && !workSpec.isPeriodic() && workSpec.initialDelay == 0L && !workSpec.isBackedOff())
        if (workSpec.hasConstraints()) {
          if (Build.VERSION.SDK_INT < 24 || !workSpec.constraints.hasContentUriTriggers()) {
            null.add(workSpec);
            arrayList.add(workSpec.id);
          } 
        } else {
          Logger.get().debug(TAG, String.format("Starting work for %s", new Object[] { workSpec.id }), new Throwable[0]);
          this.mWorkManagerImpl.startWork(workSpec.id);
        }  
    } 
    synchronized (this.mLock) {
      if (!null.isEmpty()) {
        Logger.get().debug(TAG, String.format("Starting tracking for [%s]", new Object[] { TextUtils.join(",", arrayList) }), new Throwable[0]);
        this.mConstrainedWorkSpecs.addAll(null);
        this.mWorkConstraintsTracker.replace(this.mConstrainedWorkSpecs);
      } 
      return;
    } 
  }
}

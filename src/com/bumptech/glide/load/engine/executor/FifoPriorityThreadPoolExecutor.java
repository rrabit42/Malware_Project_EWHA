package com.bumptech.glide.load.engine.executor;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.RunnableFuture;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class FifoPriorityThreadPoolExecutor extends ThreadPoolExecutor {
  private static final String TAG = "PriorityExecutor";
  
  private final AtomicInteger ordering = new AtomicInteger();
  
  private final UncaughtThrowableStrategy uncaughtThrowableStrategy;
  
  public FifoPriorityThreadPoolExecutor(int paramInt) { this(paramInt, UncaughtThrowableStrategy.LOG); }
  
  public FifoPriorityThreadPoolExecutor(int paramInt1, int paramInt2, long paramLong, TimeUnit paramTimeUnit, ThreadFactory paramThreadFactory, UncaughtThrowableStrategy paramUncaughtThrowableStrategy) {
    super(paramInt1, paramInt2, paramLong, paramTimeUnit, new PriorityBlockingQueue(), paramThreadFactory);
    this.uncaughtThrowableStrategy = paramUncaughtThrowableStrategy;
  }
  
  public FifoPriorityThreadPoolExecutor(int paramInt, UncaughtThrowableStrategy paramUncaughtThrowableStrategy) { this(paramInt, paramInt, 0L, TimeUnit.MILLISECONDS, new DefaultThreadFactory(), paramUncaughtThrowableStrategy); }
  
  protected void afterExecute(Runnable paramRunnable, Throwable paramThrowable) {
    super.afterExecute(paramRunnable, paramThrowable);
    if (paramThrowable == null && paramRunnable instanceof Future) {
      future = (Future)paramRunnable;
      if (future.isDone() && !future.isCancelled())
        try {
          future.get();
          return;
        } catch (InterruptedException future) {
          this.uncaughtThrowableStrategy.handle(future);
        } catch (ExecutionException future) {
          this.uncaughtThrowableStrategy.handle(future);
          return;
        }  
    } 
  }
  
  protected <T> RunnableFuture<T> newTaskFor(Runnable paramRunnable, T paramT) { return new LoadTask(paramRunnable, paramT, this.ordering.getAndIncrement()); }
}

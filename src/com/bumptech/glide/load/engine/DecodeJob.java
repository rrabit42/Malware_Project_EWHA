package com.bumptech.glide.load.engine;

import android.util.Log;
import com.bumptech.glide.Priority;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.DataLoadProvider;
import com.bumptech.glide.util.LogTime;
import java.io.File;
import java.io.IOException;

class DecodeJob<A, T, Z> extends Object {
  private static final FileOpener DEFAULT_FILE_OPENER = new FileOpener();
  
  private static final String TAG = "DecodeJob";
  
  private final DiskCacheProvider diskCacheProvider;
  
  private final DiskCacheStrategy diskCacheStrategy;
  
  private final DataFetcher<A> fetcher;
  
  private final FileOpener fileOpener;
  
  private final int height;
  
  private final DataLoadProvider<A, T> loadProvider;
  
  private final Priority priority;
  
  private final EngineKey resultKey;
  
  private final ResourceTranscoder<T, Z> transcoder;
  
  private final Transformation<T> transformation;
  
  private final int width;
  
  public DecodeJob(EngineKey paramEngineKey, int paramInt1, int paramInt2, DataFetcher<A> paramDataFetcher, DataLoadProvider<A, T> paramDataLoadProvider, Transformation<T> paramTransformation, ResourceTranscoder<T, Z> paramResourceTranscoder, DiskCacheProvider paramDiskCacheProvider, DiskCacheStrategy paramDiskCacheStrategy, Priority paramPriority) { this(paramEngineKey, paramInt1, paramInt2, paramDataFetcher, paramDataLoadProvider, paramTransformation, paramResourceTranscoder, paramDiskCacheProvider, paramDiskCacheStrategy, paramPriority, DEFAULT_FILE_OPENER); }
  
  DecodeJob(EngineKey paramEngineKey, int paramInt1, int paramInt2, DataFetcher<A> paramDataFetcher, DataLoadProvider<A, T> paramDataLoadProvider, Transformation<T> paramTransformation, ResourceTranscoder<T, Z> paramResourceTranscoder, DiskCacheProvider paramDiskCacheProvider, DiskCacheStrategy paramDiskCacheStrategy, Priority paramPriority, FileOpener paramFileOpener) {
    this.resultKey = paramEngineKey;
    this.width = paramInt1;
    this.height = paramInt2;
    this.fetcher = paramDataFetcher;
    this.loadProvider = paramDataLoadProvider;
    this.transformation = paramTransformation;
    this.transcoder = paramResourceTranscoder;
    this.diskCacheProvider = paramDiskCacheProvider;
    this.diskCacheStrategy = paramDiskCacheStrategy;
    this.priority = paramPriority;
    this.fileOpener = paramFileOpener;
  }
  
  private Resource<T> cacheAndDecodeSourceData(A paramA) throws IOException { // Byte code:
    //   0: invokestatic getLogTime : ()J
    //   3: lstore_2
    //   4: new com/bumptech/glide/load/engine/DecodeJob$SourceWriter
    //   7: dup
    //   8: aload_0
    //   9: aload_0
    //   10: getfield loadProvider : Lcom/bumptech/glide/provider/DataLoadProvider;
    //   13: invokeinterface getSourceEncoder : ()Lcom/bumptech/glide/load/Encoder;
    //   18: aload_1
    //   19: invokespecial <init> : (Lcom/bumptech/glide/load/engine/DecodeJob;Lcom/bumptech/glide/load/Encoder;Ljava/lang/Object;)V
    //   22: astore_1
    //   23: aload_0
    //   24: getfield diskCacheProvider : Lcom/bumptech/glide/load/engine/DecodeJob$DiskCacheProvider;
    //   27: invokeinterface getDiskCache : ()Lcom/bumptech/glide/load/engine/cache/DiskCache;
    //   32: aload_0
    //   33: getfield resultKey : Lcom/bumptech/glide/load/engine/EngineKey;
    //   36: invokevirtual getOriginalKey : ()Lcom/bumptech/glide/load/Key;
    //   39: aload_1
    //   40: invokeinterface put : (Lcom/bumptech/glide/load/Key;Lcom/bumptech/glide/load/engine/cache/DiskCache$Writer;)V
    //   45: ldc 'DecodeJob'
    //   47: iconst_2
    //   48: invokestatic isLoggable : (Ljava/lang/String;I)Z
    //   51: ifeq -> 61
    //   54: aload_0
    //   55: ldc 'Wrote source to cache'
    //   57: lload_2
    //   58: invokespecial logWithTimeAndKey : (Ljava/lang/String;J)V
    //   61: invokestatic getLogTime : ()J
    //   64: lstore_2
    //   65: aload_0
    //   66: aload_0
    //   67: getfield resultKey : Lcom/bumptech/glide/load/engine/EngineKey;
    //   70: invokevirtual getOriginalKey : ()Lcom/bumptech/glide/load/Key;
    //   73: invokespecial loadFromCache : (Lcom/bumptech/glide/load/Key;)Lcom/bumptech/glide/load/engine/Resource;
    //   76: astore_1
    //   77: ldc 'DecodeJob'
    //   79: iconst_2
    //   80: invokestatic isLoggable : (Ljava/lang/String;I)Z
    //   83: ifeq -> 97
    //   86: aload_1
    //   87: ifnull -> 97
    //   90: aload_0
    //   91: ldc 'Decoded source from cache'
    //   93: lload_2
    //   94: invokespecial logWithTimeAndKey : (Ljava/lang/String;J)V
    //   97: aload_1
    //   98: areturn }
  
  private Resource<T> decodeFromSourceData(A paramA) throws IOException {
    if (this.diskCacheStrategy.cacheSource())
      return cacheAndDecodeSourceData(paramA); 
    long l = LogTime.getLogTime();
    paramA = (A)this.loadProvider.getSourceDecoder().decode(paramA, this.width, this.height);
    if (Log.isLoggable("DecodeJob", 2))
      logWithTimeAndKey("Decoded from source", l); 
    return paramA;
  }
  
  private Resource<T> decodeSource() throws Exception {
    try {
      long l = LogTime.getLogTime();
      null = this.fetcher.loadData(this.priority);
      if (Log.isLoggable("DecodeJob", 2))
        logWithTimeAndKey("Fetched data", l); 
      boolean bool = this.isCancelled;
      if (bool)
        return null; 
      return decodeFromSourceData(null);
    } finally {
      this.fetcher.cleanup();
    } 
  }
  
  private Resource<T> loadFromCache(Key paramKey) throws IOException {
    null = this.diskCacheProvider.getDiskCache().get(paramKey);
    if (null == null)
      return null; 
    try {
      return this.loadProvider.getCacheDecoder().decode(null, this.width, this.height);
    } finally {
      this.diskCacheProvider.getDiskCache().delete(paramKey);
    } 
  }
  
  private void logWithTimeAndKey(String paramString, long paramLong) {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(paramString);
    stringBuilder.append(" in ");
    stringBuilder.append(LogTime.getElapsedMillis(paramLong));
    stringBuilder.append(", key: ");
    stringBuilder.append(this.resultKey);
    Log.v("DecodeJob", stringBuilder.toString());
  }
  
  private Resource<Z> transcode(Resource<T> paramResource) { return (paramResource == null) ? null : this.transcoder.transcode(paramResource); }
  
  private Resource<T> transform(Resource<T> paramResource) {
    if (paramResource == null)
      return null; 
    Resource resource = this.transformation.transform(paramResource, this.width, this.height);
    if (!paramResource.equals(resource))
      paramResource.recycle(); 
    return resource;
  }
  
  private Resource<Z> transformEncodeAndTranscode(Resource<T> paramResource) {
    long l = LogTime.getLogTime();
    paramResource = transform(paramResource);
    if (Log.isLoggable("DecodeJob", 2))
      logWithTimeAndKey("Transformed resource from source", l); 
    writeTransformedToCache(paramResource);
    l = LogTime.getLogTime();
    paramResource = transcode(paramResource);
    if (Log.isLoggable("DecodeJob", 2))
      logWithTimeAndKey("Transcoded transformed from source", l); 
    return paramResource;
  }
  
  private void writeTransformedToCache(Resource<T> paramResource) {
    if (paramResource != null) {
      if (!this.diskCacheStrategy.cacheResult())
        return; 
      long l = LogTime.getLogTime();
      SourceWriter sourceWriter = new SourceWriter(this, this.loadProvider.getEncoder(), paramResource);
      this.diskCacheProvider.getDiskCache().put(this.resultKey, sourceWriter);
      if (Log.isLoggable("DecodeJob", 2))
        logWithTimeAndKey("Wrote transformed from source to cache", l); 
    } 
  }
  
  public void cancel() {
    this.isCancelled = true;
    this.fetcher.cancel();
  }
  
  public Resource<Z> decodeFromSource() throws Exception { return transformEncodeAndTranscode(decodeSource()); }
  
  public Resource<Z> decodeResultFromCache() throws Exception {
    if (!this.diskCacheStrategy.cacheResult())
      return null; 
    long l = LogTime.getLogTime();
    Resource resource = loadFromCache(this.resultKey);
    if (Log.isLoggable("DecodeJob", 2))
      logWithTimeAndKey("Decoded transformed from cache", l); 
    l = LogTime.getLogTime();
    resource = transcode(resource);
    if (Log.isLoggable("DecodeJob", 2))
      logWithTimeAndKey("Transcoded transformed from cache", l); 
    return resource;
  }
  
  public Resource<Z> decodeSourceFromCache() throws Exception {
    if (!this.diskCacheStrategy.cacheSource())
      return null; 
    long l = LogTime.getLogTime();
    Resource resource = loadFromCache(this.resultKey.getOriginalKey());
    if (Log.isLoggable("DecodeJob", 2))
      logWithTimeAndKey("Decoded source from cache", l); 
    return transformEncodeAndTranscode(resource);
  }
}

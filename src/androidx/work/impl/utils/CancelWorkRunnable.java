package androidx.work.impl.utils;

import android.support.annotation.NonNull;
import android.support.annotation.RestrictTo;
import androidx.work.Operation;
import androidx.work.WorkInfo;
import androidx.work.impl.OperationImpl;
import androidx.work.impl.Scheduler;
import androidx.work.impl.Schedulers;
import androidx.work.impl.WorkDatabase;
import androidx.work.impl.WorkManagerImpl;
import androidx.work.impl.model.DependencyDao;
import androidx.work.impl.model.WorkSpecDao;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.UUID;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public abstract class CancelWorkRunnable implements Runnable {
  private final OperationImpl mOperation = new OperationImpl();
  
  public static CancelWorkRunnable forAll(@NonNull WorkManagerImpl paramWorkManagerImpl) { return new Object(paramWorkManagerImpl); }
  
  public static CancelWorkRunnable forId(@NonNull UUID paramUUID, @NonNull WorkManagerImpl paramWorkManagerImpl) { return new Object(paramWorkManagerImpl, paramUUID); }
  
  public static CancelWorkRunnable forName(@NonNull String paramString, @NonNull WorkManagerImpl paramWorkManagerImpl, boolean paramBoolean) { return new Object(paramWorkManagerImpl, paramString, paramBoolean); }
  
  public static CancelWorkRunnable forTag(@NonNull String paramString, @NonNull WorkManagerImpl paramWorkManagerImpl) { return new Object(paramWorkManagerImpl, paramString); }
  
  private void iterativelyCancelWorkAndDependents(WorkDatabase paramWorkDatabase, String paramString) {
    WorkSpecDao workSpecDao = paramWorkDatabase.workSpecDao();
    DependencyDao dependencyDao = paramWorkDatabase.dependencyDao();
    LinkedList linkedList = new LinkedList();
    linkedList.add(paramString);
    while (!linkedList.isEmpty()) {
      paramString = (String)linkedList.remove();
      WorkInfo.State state = workSpecDao.getState(paramString);
      if (state != WorkInfo.State.SUCCEEDED && state != WorkInfo.State.FAILED)
        workSpecDao.setState(WorkInfo.State.CANCELLED, new String[] { paramString }); 
      linkedList.addAll(dependencyDao.getDependentWorkIds(paramString));
    } 
  }
  
  void cancel(WorkManagerImpl paramWorkManagerImpl, String paramString) {
    iterativelyCancelWorkAndDependents(paramWorkManagerImpl.getWorkDatabase(), paramString);
    paramWorkManagerImpl.getProcessor().stopAndCancelWork(paramString);
    Iterator iterator = paramWorkManagerImpl.getSchedulers().iterator();
    while (iterator.hasNext())
      ((Scheduler)iterator.next()).cancel(paramString); 
  }
  
  public Operation getOperation() { return this.mOperation; }
  
  void reschedulePendingWorkers(WorkManagerImpl paramWorkManagerImpl) { Schedulers.schedule(paramWorkManagerImpl.getConfiguration(), paramWorkManagerImpl.getWorkDatabase(), paramWorkManagerImpl.getSchedulers()); }
  
  public void run() {
    try {
      runInternal();
      this.mOperation.setState(Operation.SUCCESS);
      return;
    } catch (Throwable throwable) {
      this.mOperation.setState(new Operation.State.FAILURE(throwable));
      return;
    } 
  }
  
  abstract void runInternal();
}

package com.google.android.gms.common.api.internal;

import android.os.Looper;
import android.support.annotation.NonNull;
import android.util.Log;
import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.common.api.PendingResult;
import com.google.android.gms.common.api.Releasable;
import com.google.android.gms.common.api.Result;
import com.google.android.gms.common.api.ResultCallback;
import com.google.android.gms.common.api.ResultCallbacks;
import com.google.android.gms.common.api.ResultTransform;
import com.google.android.gms.common.api.Status;
import com.google.android.gms.common.api.TransformedResult;
import com.google.android.gms.common.internal.Preconditions;
import java.lang.ref.WeakReference;
import javax.annotation.concurrent.GuardedBy;

public final class zacm<R extends Result> extends TransformedResult<R> implements ResultCallback<R> {
  private final Object zadn = new Object();
  
  private final WeakReference<GoogleApiClient> zadp;
  
  private ResultTransform<? super R, ? extends Result> zakn = null;
  
  private zacm<? extends Result> zako = null;
  
  private PendingResult<R> zakq = null;
  
  private Status zakr = null;
  
  private final zaco zaks;
  
  private boolean zakt = false;
  
  public zacm(WeakReference<GoogleApiClient> paramWeakReference) {
    Preconditions.checkNotNull(paramWeakReference, "GoogleApiClient reference must not be null");
    this.zadp = paramWeakReference;
    Looper looper = (GoogleApiClient)this.zadp.get();
    if (looper != null) {
      Looper looper1 = looper.getLooper();
    } else {
      looper = Looper.getMainLooper();
    } 
    this.zaks = new zaco(this, looper);
  }
  
  private static void zab(Result paramResult) {
    if (paramResult instanceof Releasable)
      try {
        ((Releasable)paramResult).release();
        return;
      } catch (RuntimeException runtimeException) {
        String str;
        StringBuilder stringBuilder = new StringBuilder((str = String.valueOf(paramResult)).valueOf(str).length() + 18);
        stringBuilder.append("Unable to release ");
        stringBuilder.append(str);
        Log.w("TransformedResultImpl", stringBuilder.toString(), runtimeException);
      }  
  }
  
  @GuardedBy("mSyncToken")
  private final void zabu() {
    if (this.zakn == null && this.zakp == null)
      return; 
    GoogleApiClient googleApiClient = (GoogleApiClient)this.zadp.get();
    if (!this.zakt && this.zakn != null && googleApiClient != null) {
      googleApiClient.zaa(this);
      this.zakt = true;
    } 
    Status status = this.zakr;
    if (status != null) {
      zae(status);
      return;
    } 
    PendingResult pendingResult = this.zakq;
    if (pendingResult != null)
      pendingResult.setResultCallback(this); 
  }
  
  @GuardedBy("mSyncToken")
  private final boolean zabw() {
    GoogleApiClient googleApiClient = (GoogleApiClient)this.zadp.get();
    return (this.zakp != null && googleApiClient != null);
  }
  
  private final void zad(Status paramStatus) {
    synchronized (this.zadn) {
      this.zakr = paramStatus;
      zae(this.zakr);
      return;
    } 
  }
  
  private final void zae(Status paramStatus) {
    synchronized (this.zadn) {
      if (this.zakn != null) {
        paramStatus = this.zakn.onFailure(paramStatus);
        Preconditions.checkNotNull(paramStatus, "onFailure must not return null");
        this.zako.zad(paramStatus);
      } else if (zabw()) {
        this.zakp.onFailure(paramStatus);
      } 
      return;
    } 
  }
  
  public final void andFinally(@NonNull ResultCallbacks<? super R> paramResultCallbacks) {
    synchronized (this.zadn) {
      boolean bool;
      ResultCallbacks resultCallbacks = this.zakp;
      boolean bool1 = true;
      if (resultCallbacks == null) {
        bool = true;
      } else {
        bool = false;
      } 
      Preconditions.checkState(bool, "Cannot call andFinally() twice.");
      if (this.zakn == null) {
        bool = bool1;
      } else {
        bool = false;
      } 
      Preconditions.checkState(bool, "Cannot call then() and andFinally() on the same TransformedResult.");
      this.zakp = paramResultCallbacks;
      zabu();
      return;
    } 
  }
  
  public final void onResult(R paramR) {
    synchronized (this.zadn) {
      if (paramR.getStatus().isSuccess()) {
        if (this.zakn != null) {
          zacc.zabb().submit(new zacn(this, paramR));
        } else if (zabw()) {
          this.zakp.onSuccess(paramR);
        } 
      } else {
        zad(paramR.getStatus());
        zab(paramR);
      } 
      return;
    } 
  }
  
  @NonNull
  public final <S extends Result> TransformedResult<S> then(@NonNull ResultTransform<? super R, ? extends S> paramResultTransform) {
    synchronized (this.zadn) {
      boolean bool1;
      ResultTransform resultTransform = this.zakn;
      boolean bool2 = true;
      if (resultTransform == null) {
        bool1 = true;
      } else {
        bool1 = false;
      } 
      Preconditions.checkState(bool1, "Cannot call then() twice.");
      if (this.zakp == null) {
        bool1 = bool2;
        Preconditions.checkState(bool1, "Cannot call then() and andFinally() on the same TransformedResult.");
        this.zakn = paramResultTransform;
        zacm zacm2 = new zacm(this.zadp);
        this.zako = zacm2;
        zabu();
        return zacm2;
      } 
    } 
    boolean bool = false;
    Preconditions.checkState(bool, "Cannot call then() and andFinally() on the same TransformedResult.");
    this.zakn = paramResultTransform;
    zacm zacm1 = new zacm(this.zadp);
    this.zako = zacm1;
    zabu();
    /* monitor exit ClassFileLocalVariableReferenceExpression{type=ObjectType{java/lang/Object}, name=SYNTHETIC_LOCAL_VARIABLE_4} */
    return zacm1;
  }
  
  public final void zaa(PendingResult<?> paramPendingResult) {
    synchronized (this.zadn) {
      this.zakq = paramPendingResult;
      zabu();
      return;
    } 
  }
  
  final void zabv() { this.zakp = null; }
}

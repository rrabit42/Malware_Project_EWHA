package android.support.v7.widget;

import android.content.Context;
import android.graphics.PointF;
import android.graphics.Rect;
import android.os.Parcelable;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RestrictTo;
import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;
import android.view.accessibility.AccessibilityEvent;
import java.util.Arrays;
import java.util.BitSet;

public class StaggeredGridLayoutManager extends RecyclerView.LayoutManager implements RecyclerView.SmoothScroller.ScrollVectorProvider {
  static final boolean DEBUG = false;
  
  @Deprecated
  public static final int GAP_HANDLING_LAZY = 1;
  
  public static final int GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS = 2;
  
  public static final int GAP_HANDLING_NONE = 0;
  
  public static final int HORIZONTAL = 0;
  
  static final int INVALID_OFFSET = -2147483648;
  
  private static final float MAX_SCROLL_FACTOR = 0.33333334F;
  
  private static final String TAG = "StaggeredGridLManager";
  
  public static final int VERTICAL = 1;
  
  private final AnchorInfo mAnchorInfo = new AnchorInfo(this);
  
  private final Runnable mCheckForGapsRunnable = new Object(this);
  
  private int mFullSizeSpec;
  
  private int mGapStrategy = 2;
  
  private boolean mLaidOutInvalidFullSpan = false;
  
  private boolean mLastLayoutFromEnd;
  
  private boolean mLastLayoutRTL;
  
  @NonNull
  private final LayoutState mLayoutState;
  
  LazySpanLookup mLazySpanLookup = new LazySpanLookup();
  
  private int mOrientation;
  
  private SavedState mPendingSavedState;
  
  int mPendingScrollPosition = -1;
  
  int mPendingScrollPositionOffset = Integer.MIN_VALUE;
  
  private int[] mPrefetchDistances;
  
  @NonNull
  OrientationHelper mPrimaryOrientation;
  
  private BitSet mRemainingSpans;
  
  boolean mReverseLayout = false;
  
  @NonNull
  OrientationHelper mSecondaryOrientation;
  
  boolean mShouldReverseLayout = false;
  
  private int mSizePerSpan;
  
  private boolean mSmoothScrollbarEnabled = true;
  
  private int mSpanCount = -1;
  
  Span[] mSpans;
  
  private final Rect mTmpRect = new Rect();
  
  public StaggeredGridLayoutManager(int paramInt1, int paramInt2) {
    this.mOrientation = paramInt2;
    setSpanCount(paramInt1);
    this.mLayoutState = new LayoutState();
    createOrientationHelpers();
  }
  
  public StaggeredGridLayoutManager(Context paramContext, AttributeSet paramAttributeSet, int paramInt1, int paramInt2) {
    RecyclerView.LayoutManager.Properties properties = getProperties(paramContext, paramAttributeSet, paramInt1, paramInt2);
    setOrientation(properties.orientation);
    setSpanCount(properties.spanCount);
    setReverseLayout(properties.reverseLayout);
    this.mLayoutState = new LayoutState();
    createOrientationHelpers();
  }
  
  private void appendViewToAllSpans(View paramView) {
    for (int i = this.mSpanCount - 1; i >= 0; i--)
      this.mSpans[i].appendToSpan(paramView); 
  }
  
  private void applyPendingSavedState(AnchorInfo paramAnchorInfo) {
    if (this.mPendingSavedState.mSpanOffsetsSize > 0)
      if (this.mPendingSavedState.mSpanOffsetsSize == this.mSpanCount) {
        for (byte b = 0; b < this.mSpanCount; b++) {
          this.mSpans[b].clear();
          int j = this.mPendingSavedState.mSpanOffsets[b];
          int i = j;
          if (j != Integer.MIN_VALUE) {
            if (this.mPendingSavedState.mAnchorLayoutFromEnd) {
              i = this.mPrimaryOrientation.getEndAfterPadding();
            } else {
              i = this.mPrimaryOrientation.getStartAfterPadding();
            } 
            i = j + i;
          } 
          this.mSpans[b].setLine(i);
        } 
      } else {
        this.mPendingSavedState.invalidateSpanInfo();
        SavedState savedState = this.mPendingSavedState;
        savedState.mAnchorPosition = savedState.mVisibleAnchorPosition;
      }  
    this.mLastLayoutRTL = this.mPendingSavedState.mLastLayoutRTL;
    setReverseLayout(this.mPendingSavedState.mReverseLayout);
    resolveShouldLayoutReverse();
    if (this.mPendingSavedState.mAnchorPosition != -1) {
      this.mPendingScrollPosition = this.mPendingSavedState.mAnchorPosition;
      paramAnchorInfo.mLayoutFromEnd = this.mPendingSavedState.mAnchorLayoutFromEnd;
    } else {
      paramAnchorInfo.mLayoutFromEnd = this.mShouldReverseLayout;
    } 
    if (this.mPendingSavedState.mSpanLookupSize > 1) {
      this.mLazySpanLookup.mData = this.mPendingSavedState.mSpanLookup;
      this.mLazySpanLookup.mFullSpanItems = this.mPendingSavedState.mFullSpanItems;
    } 
  }
  
  private void attachViewToSpans(View paramView, LayoutParams paramLayoutParams, LayoutState paramLayoutState) {
    if (paramLayoutState.mLayoutDirection == 1) {
      if (paramLayoutParams.mFullSpan) {
        appendViewToAllSpans(paramView);
        return;
      } 
      paramLayoutParams.mSpan.appendToSpan(paramView);
      return;
    } 
    if (paramLayoutParams.mFullSpan) {
      prependViewToAllSpans(paramView);
      return;
    } 
    paramLayoutParams.mSpan.prependToSpan(paramView);
  }
  
  private int calculateScrollDirectionForPosition(int paramInt) {
    boolean bool;
    int j = getChildCount();
    int i = -1;
    if (j == 0) {
      paramInt = i;
      if (this.mShouldReverseLayout)
        paramInt = 1; 
      return paramInt;
    } 
    if (paramInt < getFirstChildPosition()) {
      bool = true;
    } else {
      bool = false;
    } 
    return (bool != this.mShouldReverseLayout) ? -1 : 1;
  }
  
  private boolean checkSpanForGap(Span paramSpan) {
    if (this.mShouldReverseLayout) {
      if (paramSpan.getEndLine() < this.mPrimaryOrientation.getEndAfterPadding())
        return (paramSpan.getLayoutParams((View)paramSpan.mViews.get(paramSpan.mViews.size() - 1))).mFullSpan ^ true; 
    } else if (paramSpan.getStartLine() > this.mPrimaryOrientation.getStartAfterPadding()) {
      return (paramSpan.getLayoutParams((View)paramSpan.mViews.get(0))).mFullSpan ^ true;
    } 
    return false;
  }
  
  private int computeScrollExtent(RecyclerView.State paramState) { return (getChildCount() == 0) ? 0 : ScrollbarHelper.computeScrollExtent(paramState, this.mPrimaryOrientation, findFirstVisibleItemClosestToStart(this.mSmoothScrollbarEnabled ^ true), findFirstVisibleItemClosestToEnd(this.mSmoothScrollbarEnabled ^ true), this, this.mSmoothScrollbarEnabled); }
  
  private int computeScrollOffset(RecyclerView.State paramState) { return (getChildCount() == 0) ? 0 : ScrollbarHelper.computeScrollOffset(paramState, this.mPrimaryOrientation, findFirstVisibleItemClosestToStart(this.mSmoothScrollbarEnabled ^ true), findFirstVisibleItemClosestToEnd(this.mSmoothScrollbarEnabled ^ true), this, this.mSmoothScrollbarEnabled, this.mShouldReverseLayout); }
  
  private int computeScrollRange(RecyclerView.State paramState) { return (getChildCount() == 0) ? 0 : ScrollbarHelper.computeScrollRange(paramState, this.mPrimaryOrientation, findFirstVisibleItemClosestToStart(this.mSmoothScrollbarEnabled ^ true), findFirstVisibleItemClosestToEnd(this.mSmoothScrollbarEnabled ^ true), this, this.mSmoothScrollbarEnabled); }
  
  private int convertFocusDirectionToLayoutDirection(int paramInt) { return (paramInt != 1) ? ((paramInt != 2) ? ((paramInt != 17) ? ((paramInt != 33) ? ((paramInt != 66) ? ((paramInt != 130) ? Integer.MIN_VALUE : ((this.mOrientation == 1) ? 1 : Integer.MIN_VALUE)) : ((this.mOrientation == 0) ? 1 : Integer.MIN_VALUE)) : ((this.mOrientation == 1) ? -1 : Integer.MIN_VALUE)) : ((this.mOrientation == 0) ? -1 : Integer.MIN_VALUE)) : ((this.mOrientation == 1) ? 1 : (isLayoutRTL() ? -1 : 1))) : ((this.mOrientation == 1) ? -1 : (isLayoutRTL() ? 1 : -1)); }
  
  private LazySpanLookup.FullSpanItem createFullSpanItemFromEnd(int paramInt) {
    LazySpanLookup.FullSpanItem fullSpanItem = new LazySpanLookup.FullSpanItem();
    fullSpanItem.mGapPerSpan = new int[this.mSpanCount];
    for (byte b = 0; b < this.mSpanCount; b++)
      fullSpanItem.mGapPerSpan[b] = paramInt - this.mSpans[b].getEndLine(paramInt); 
    return fullSpanItem;
  }
  
  private LazySpanLookup.FullSpanItem createFullSpanItemFromStart(int paramInt) {
    LazySpanLookup.FullSpanItem fullSpanItem = new LazySpanLookup.FullSpanItem();
    fullSpanItem.mGapPerSpan = new int[this.mSpanCount];
    for (byte b = 0; b < this.mSpanCount; b++)
      fullSpanItem.mGapPerSpan[b] = this.mSpans[b].getStartLine(paramInt) - paramInt; 
    return fullSpanItem;
  }
  
  private void createOrientationHelpers() { this.mSecondaryOrientation = (this.mPrimaryOrientation = OrientationHelper.createOrientationHelper(this, this.mOrientation)).createOrientationHelper(this, 1 - this.mOrientation); }
  
  private int fill(RecyclerView.Recycler paramRecycler, LayoutState paramLayoutState, RecyclerView.State paramState) {
    int i;
    this.mRemainingSpans.set(0, this.mSpanCount, true);
    if (this.mLayoutState.mInfinite) {
      if (paramLayoutState.mLayoutDirection == 1) {
        i = Integer.MAX_VALUE;
      } else {
        i = Integer.MIN_VALUE;
      } 
    } else if (paramLayoutState.mLayoutDirection == 1) {
      i = paramLayoutState.mEndLine + paramLayoutState.mAvailable;
    } else {
      i = paramLayoutState.mStartLine - paramLayoutState.mAvailable;
    } 
    updateAllRemainingSpans(paramLayoutState.mLayoutDirection, i);
    if (this.mShouldReverseLayout) {
      k = this.mPrimaryOrientation.getEndAfterPadding();
    } else {
      k = this.mPrimaryOrientation.getStartAfterPadding();
    } 
    int j;
    for (j = 0; paramLayoutState.hasMore(paramState) && (this.mLayoutState.mInfinite || !this.mRemainingSpans.isEmpty()); j = 1) {
      Span span;
      int i1;
      int n;
      int m;
      View view = paramLayoutState.next(paramRecycler);
      LayoutParams layoutParams = (LayoutParams)view.getLayoutParams();
      int i2 = layoutParams.getViewLayoutPosition();
      j = this.mLazySpanLookup.getSpan(i2);
      if (j == -1) {
        i1 = 1;
      } else {
        i1 = 0;
      } 
      if (i1) {
        if (layoutParams.mFullSpan) {
          span = this.mSpans[0];
        } else {
          span = getNextSpan(paramLayoutState);
        } 
        this.mLazySpanLookup.setSpan(i2, span);
      } else {
        span = this.mSpans[j];
      } 
      layoutParams.mSpan = span;
      if (paramLayoutState.mLayoutDirection == 1) {
        addView(view);
      } else {
        addView(view, 0);
      } 
      measureChildWithDecorationsAndMargin(view, layoutParams, false);
      if (paramLayoutState.mLayoutDirection == 1) {
        if (layoutParams.mFullSpan) {
          j = getMaxEnd(k);
        } else {
          j = span.getEndLine(k);
        } 
        m = this.mPrimaryOrientation.getDecoratedMeasurement(view);
        if (i1 && layoutParams.mFullSpan) {
          LazySpanLookup.FullSpanItem fullSpanItem = createFullSpanItemFromEnd(j);
          fullSpanItem.mGapDir = -1;
          fullSpanItem.mPosition = i2;
          this.mLazySpanLookup.addFullSpanItem(fullSpanItem);
        } 
        n = m + j;
        m = j;
      } else {
        if (layoutParams.mFullSpan) {
          j = getMinStart(k);
        } else {
          j = span.getStartLine(k);
        } 
        m = j - this.mPrimaryOrientation.getDecoratedMeasurement(view);
        if (i1 && layoutParams.mFullSpan) {
          LazySpanLookup.FullSpanItem fullSpanItem = createFullSpanItemFromStart(j);
          fullSpanItem.mGapDir = 1;
          fullSpanItem.mPosition = i2;
          this.mLazySpanLookup.addFullSpanItem(fullSpanItem);
        } 
        n = j;
      } 
      if (layoutParams.mFullSpan && paramLayoutState.mItemDirection == -1)
        if (i1) {
          this.mLaidOutInvalidFullSpan = true;
        } else {
          boolean bool;
          if (paramLayoutState.mLayoutDirection == 1) {
            bool = areAllEndsEqual();
          } else {
            bool = areAllStartsEqual();
          } 
          if (bool ^ true) {
            LazySpanLookup.FullSpanItem fullSpanItem = this.mLazySpanLookup.getFullSpanItem(i2);
            if (fullSpanItem != null)
              fullSpanItem.mHasUnwantedGapAfter = true; 
            this.mLaidOutInvalidFullSpan = true;
          } 
        }  
      attachViewToSpans(view, layoutParams, paramLayoutState);
      if (isLayoutRTL() && this.mOrientation == 1) {
        if (layoutParams.mFullSpan) {
          j = this.mSecondaryOrientation.getEndAfterPadding();
        } else {
          j = this.mSecondaryOrientation.getEndAfterPadding() - (this.mSpanCount - 1 - span.mIndex) * this.mSizePerSpan;
        } 
        i2 = this.mSecondaryOrientation.getDecoratedMeasurement(view);
        i1 = j;
        j -= i2;
        i2 = i1;
      } else {
        if (layoutParams.mFullSpan) {
          j = this.mSecondaryOrientation.getStartAfterPadding();
        } else {
          j = span.mIndex * this.mSizePerSpan + this.mSecondaryOrientation.getStartAfterPadding();
        } 
        i2 = this.mSecondaryOrientation.getDecoratedMeasurement(view);
        i1 = j;
        i2 += j;
        j = i1;
      } 
      if (this.mOrientation == 1) {
        layoutDecoratedWithMargins(view, j, m, i2, n);
      } else {
        layoutDecoratedWithMargins(view, m, j, n, i2);
      } 
      if (layoutParams.mFullSpan) {
        updateAllRemainingSpans(this.mLayoutState.mLayoutDirection, i);
      } else {
        updateRemainingSpans(span, this.mLayoutState.mLayoutDirection, i);
      } 
      recycle(paramRecycler, this.mLayoutState);
      if (this.mLayoutState.mStopInFocusable && view.hasFocusable())
        if (layoutParams.mFullSpan) {
          this.mRemainingSpans.clear();
        } else {
          this.mRemainingSpans.set(span.mIndex, false);
        }  
    } 
    int k = 0;
    if (j == 0)
      recycle(paramRecycler, this.mLayoutState); 
    if (this.mLayoutState.mLayoutDirection == -1) {
      i = getMinStart(this.mPrimaryOrientation.getStartAfterPadding());
      i = this.mPrimaryOrientation.getStartAfterPadding() - i;
    } else {
      i = getMaxEnd(this.mPrimaryOrientation.getEndAfterPadding()) - this.mPrimaryOrientation.getEndAfterPadding();
    } 
    j = k;
    if (i > 0)
      j = Math.min(paramLayoutState.mAvailable, i); 
    return j;
  }
  
  private int findFirstReferenceChildPosition(int paramInt) {
    int i = getChildCount();
    for (byte b = 0; b < i; b++) {
      int j = getPosition(getChildAt(b));
      if (j >= 0 && j < paramInt)
        return j; 
    } 
    return 0;
  }
  
  private int findLastReferenceChildPosition(int paramInt) {
    for (int i = getChildCount() - 1; i >= 0; i--) {
      int j = getPosition(getChildAt(i));
      if (j >= 0 && j < paramInt)
        return j; 
    } 
    return 0;
  }
  
  private void fixEndGap(RecyclerView.Recycler paramRecycler, RecyclerView.State paramState, boolean paramBoolean) {
    int i = getMaxEnd(-2147483648);
    if (i == Integer.MIN_VALUE)
      return; 
    i = this.mPrimaryOrientation.getEndAfterPadding() - i;
    if (i > 0) {
      i -= -scrollBy(-i, paramRecycler, paramState);
      if (paramBoolean && i > 0)
        this.mPrimaryOrientation.offsetChildren(i); 
    } 
  }
  
  private void fixStartGap(RecyclerView.Recycler paramRecycler, RecyclerView.State paramState, boolean paramBoolean) {
    int i = getMinStart(2147483647);
    if (i == Integer.MAX_VALUE)
      return; 
    i -= this.mPrimaryOrientation.getStartAfterPadding();
    if (i > 0) {
      i -= scrollBy(i, paramRecycler, paramState);
      if (paramBoolean && i > 0)
        this.mPrimaryOrientation.offsetChildren(-i); 
    } 
  }
  
  private int getMaxEnd(int paramInt) {
    int i = this.mSpans[0].getEndLine(paramInt);
    byte b = 1;
    while (b < this.mSpanCount) {
      int k = this.mSpans[b].getEndLine(paramInt);
      int j = i;
      if (k > i)
        j = k; 
      b++;
      i = j;
    } 
    return i;
  }
  
  private int getMaxStart(int paramInt) {
    int i = this.mSpans[0].getStartLine(paramInt);
    byte b = 1;
    while (b < this.mSpanCount) {
      int k = this.mSpans[b].getStartLine(paramInt);
      int j = i;
      if (k > i)
        j = k; 
      b++;
      i = j;
    } 
    return i;
  }
  
  private int getMinEnd(int paramInt) {
    int i = this.mSpans[0].getEndLine(paramInt);
    byte b = 1;
    while (b < this.mSpanCount) {
      int k = this.mSpans[b].getEndLine(paramInt);
      int j = i;
      if (k < i)
        j = k; 
      b++;
      i = j;
    } 
    return i;
  }
  
  private int getMinStart(int paramInt) {
    int i = this.mSpans[0].getStartLine(paramInt);
    byte b = 1;
    while (b < this.mSpanCount) {
      int k = this.mSpans[b].getStartLine(paramInt);
      int j = i;
      if (k < i)
        j = k; 
      b++;
      i = j;
    } 
    return i;
  }
  
  private Span getNextSpan(LayoutState paramLayoutState) {
    byte b2;
    byte b1;
    boolean bool = preferLastSpan(paramLayoutState.mLayoutDirection);
    int i = -1;
    if (bool) {
      b1 = this.mSpanCount - 1;
      b2 = -1;
    } else {
      b1 = 0;
      i = this.mSpanCount;
      b2 = 1;
    } 
    int j = paramLayoutState.mLayoutDirection;
    Span span2 = null;
    paramLayoutState = null;
    if (j == 1) {
      Span span;
      j = Integer.MAX_VALUE;
      int m = this.mPrimaryOrientation.getStartAfterPadding();
      while (b1 != i) {
        span2 = this.mSpans[b1];
        int i1 = span2.getEndLine(m);
        int n = j;
        if (i1 < j) {
          span = span2;
          n = i1;
        } 
        b1 += b2;
        j = n;
      } 
      return span;
    } 
    j = Integer.MIN_VALUE;
    int k = this.mPrimaryOrientation.getEndAfterPadding();
    Span span1 = span2;
    while (b1 != i) {
      span2 = this.mSpans[b1];
      int n = span2.getStartLine(k);
      int m = j;
      if (n > j) {
        span1 = span2;
        m = n;
      } 
      b1 += b2;
      j = m;
    } 
    return span1;
  }
  
  private void handleUpdate(int paramInt1, int paramInt2, int paramInt3) {
    if (this.mShouldReverseLayout) {
      int k = getLastChildPosition();
    } else {
      int k = getFirstChildPosition();
    } 
    if (paramInt3 == 8) {
      if (paramInt1 < paramInt2) {
        i = paramInt2 + 1;
      } else {
        int k = paramInt1 + 1;
        i = paramInt2;
        this.mLazySpanLookup.invalidateAfter(i);
      } 
    } else {
      i = paramInt1 + paramInt2;
    } 
    int j = i;
    int i = paramInt1;
    this.mLazySpanLookup.invalidateAfter(i);
  }
  
  private void measureChildWithDecorationsAndMargin(View paramView, int paramInt1, int paramInt2, boolean paramBoolean) {
    calculateItemDecorationsForChild(paramView, this.mTmpRect);
    LayoutParams layoutParams = (LayoutParams)paramView.getLayoutParams();
    paramInt1 = updateSpecWithExtra(paramInt1, layoutParams.leftMargin + this.mTmpRect.left, layoutParams.rightMargin + this.mTmpRect.right);
    paramInt2 = updateSpecWithExtra(paramInt2, layoutParams.topMargin + this.mTmpRect.top, layoutParams.bottomMargin + this.mTmpRect.bottom);
    if (paramBoolean) {
      paramBoolean = shouldReMeasureChild(paramView, paramInt1, paramInt2, layoutParams);
    } else {
      paramBoolean = shouldMeasureChild(paramView, paramInt1, paramInt2, layoutParams);
    } 
    if (paramBoolean)
      paramView.measure(paramInt1, paramInt2); 
  }
  
  private void measureChildWithDecorationsAndMargin(View paramView, LayoutParams paramLayoutParams, boolean paramBoolean) {
    if (paramLayoutParams.mFullSpan) {
      if (this.mOrientation == 1) {
        measureChildWithDecorationsAndMargin(paramView, this.mFullSizeSpec, getChildMeasureSpec(getHeight(), getHeightMode(), getPaddingTop() + getPaddingBottom(), paramLayoutParams.height, true), paramBoolean);
        return;
      } 
      measureChildWithDecorationsAndMargin(paramView, getChildMeasureSpec(getWidth(), getWidthMode(), getPaddingLeft() + getPaddingRight(), paramLayoutParams.width, true), this.mFullSizeSpec, paramBoolean);
      return;
    } 
    if (this.mOrientation == 1) {
      measureChildWithDecorationsAndMargin(paramView, getChildMeasureSpec(this.mSizePerSpan, getWidthMode(), 0, paramLayoutParams.width, false), getChildMeasureSpec(getHeight(), getHeightMode(), getPaddingTop() + getPaddingBottom(), paramLayoutParams.height, true), paramBoolean);
      return;
    } 
    measureChildWithDecorationsAndMargin(paramView, getChildMeasureSpec(getWidth(), getWidthMode(), getPaddingLeft() + getPaddingRight(), paramLayoutParams.width, true), getChildMeasureSpec(this.mSizePerSpan, getHeightMode(), 0, paramLayoutParams.height, false), paramBoolean);
  }
  
  private void onLayoutChildren(RecyclerView.Recycler paramRecycler, RecyclerView.State paramState, boolean paramBoolean) { // Byte code:
    //   0: aload_0
    //   1: getfield mAnchorInfo : Landroid/support/v7/widget/StaggeredGridLayoutManager$AnchorInfo;
    //   4: astore #7
    //   6: aload_0
    //   7: getfield mPendingSavedState : Landroid/support/v7/widget/StaggeredGridLayoutManager$SavedState;
    //   10: ifnonnull -> 21
    //   13: aload_0
    //   14: getfield mPendingScrollPosition : I
    //   17: iconst_m1
    //   18: if_icmpeq -> 39
    //   21: aload_2
    //   22: invokevirtual getItemCount : ()I
    //   25: ifne -> 39
    //   28: aload_0
    //   29: aload_1
    //   30: invokevirtual removeAndRecycleAllViews : (Landroid/support/v7/widget/RecyclerView$Recycler;)V
    //   33: aload #7
    //   35: invokevirtual reset : ()V
    //   38: return
    //   39: aload #7
    //   41: getfield mValid : Z
    //   44: istore #6
    //   46: iconst_1
    //   47: istore #5
    //   49: iload #6
    //   51: ifeq -> 78
    //   54: aload_0
    //   55: getfield mPendingScrollPosition : I
    //   58: iconst_m1
    //   59: if_icmpne -> 78
    //   62: aload_0
    //   63: getfield mPendingSavedState : Landroid/support/v7/widget/StaggeredGridLayoutManager$SavedState;
    //   66: ifnull -> 72
    //   69: goto -> 78
    //   72: iconst_0
    //   73: istore #4
    //   75: goto -> 81
    //   78: iconst_1
    //   79: istore #4
    //   81: iload #4
    //   83: ifeq -> 133
    //   86: aload #7
    //   88: invokevirtual reset : ()V
    //   91: aload_0
    //   92: getfield mPendingSavedState : Landroid/support/v7/widget/StaggeredGridLayoutManager$SavedState;
    //   95: ifnull -> 107
    //   98: aload_0
    //   99: aload #7
    //   101: invokespecial applyPendingSavedState : (Landroid/support/v7/widget/StaggeredGridLayoutManager$AnchorInfo;)V
    //   104: goto -> 120
    //   107: aload_0
    //   108: invokespecial resolveShouldLayoutReverse : ()V
    //   111: aload #7
    //   113: aload_0
    //   114: getfield mShouldReverseLayout : Z
    //   117: putfield mLayoutFromEnd : Z
    //   120: aload_0
    //   121: aload_2
    //   122: aload #7
    //   124: invokevirtual updateAnchorInfoForLayout : (Landroid/support/v7/widget/RecyclerView$State;Landroid/support/v7/widget/StaggeredGridLayoutManager$AnchorInfo;)V
    //   127: aload #7
    //   129: iconst_1
    //   130: putfield mValid : Z
    //   133: aload_0
    //   134: getfield mPendingSavedState : Landroid/support/v7/widget/StaggeredGridLayoutManager$SavedState;
    //   137: ifnonnull -> 184
    //   140: aload_0
    //   141: getfield mPendingScrollPosition : I
    //   144: iconst_m1
    //   145: if_icmpne -> 184
    //   148: aload #7
    //   150: getfield mLayoutFromEnd : Z
    //   153: aload_0
    //   154: getfield mLastLayoutFromEnd : Z
    //   157: if_icmpne -> 171
    //   160: aload_0
    //   161: invokevirtual isLayoutRTL : ()Z
    //   164: aload_0
    //   165: getfield mLastLayoutRTL : Z
    //   168: if_icmpeq -> 184
    //   171: aload_0
    //   172: getfield mLazySpanLookup : Landroid/support/v7/widget/StaggeredGridLayoutManager$LazySpanLookup;
    //   175: invokevirtual clear : ()V
    //   178: aload #7
    //   180: iconst_1
    //   181: putfield mInvalidateOffsets : Z
    //   184: aload_0
    //   185: invokevirtual getChildCount : ()I
    //   188: ifle -> 394
    //   191: aload_0
    //   192: getfield mPendingSavedState : Landroid/support/v7/widget/StaggeredGridLayoutManager$SavedState;
    //   195: astore #8
    //   197: aload #8
    //   199: ifnull -> 211
    //   202: aload #8
    //   204: getfield mSpanOffsetsSize : I
    //   207: iconst_1
    //   208: if_icmpge -> 394
    //   211: aload #7
    //   213: getfield mInvalidateOffsets : Z
    //   216: ifeq -> 275
    //   219: iconst_0
    //   220: istore #4
    //   222: iload #4
    //   224: aload_0
    //   225: getfield mSpanCount : I
    //   228: if_icmpge -> 394
    //   231: aload_0
    //   232: getfield mSpans : [Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   235: iload #4
    //   237: aaload
    //   238: invokevirtual clear : ()V
    //   241: aload #7
    //   243: getfield mOffset : I
    //   246: ldc -2147483648
    //   248: if_icmpeq -> 266
    //   251: aload_0
    //   252: getfield mSpans : [Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   255: iload #4
    //   257: aaload
    //   258: aload #7
    //   260: getfield mOffset : I
    //   263: invokevirtual setLine : (I)V
    //   266: iload #4
    //   268: iconst_1
    //   269: iadd
    //   270: istore #4
    //   272: goto -> 222
    //   275: iload #4
    //   277: ifne -> 343
    //   280: aload_0
    //   281: getfield mAnchorInfo : Landroid/support/v7/widget/StaggeredGridLayoutManager$AnchorInfo;
    //   284: getfield mSpanReferenceLines : [I
    //   287: ifnonnull -> 293
    //   290: goto -> 343
    //   293: iconst_0
    //   294: istore #4
    //   296: iload #4
    //   298: aload_0
    //   299: getfield mSpanCount : I
    //   302: if_icmpge -> 394
    //   305: aload_0
    //   306: getfield mSpans : [Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   309: iload #4
    //   311: aaload
    //   312: astore #8
    //   314: aload #8
    //   316: invokevirtual clear : ()V
    //   319: aload #8
    //   321: aload_0
    //   322: getfield mAnchorInfo : Landroid/support/v7/widget/StaggeredGridLayoutManager$AnchorInfo;
    //   325: getfield mSpanReferenceLines : [I
    //   328: iload #4
    //   330: iaload
    //   331: invokevirtual setLine : (I)V
    //   334: iload #4
    //   336: iconst_1
    //   337: iadd
    //   338: istore #4
    //   340: goto -> 296
    //   343: iconst_0
    //   344: istore #4
    //   346: iload #4
    //   348: aload_0
    //   349: getfield mSpanCount : I
    //   352: if_icmpge -> 383
    //   355: aload_0
    //   356: getfield mSpans : [Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   359: iload #4
    //   361: aaload
    //   362: aload_0
    //   363: getfield mShouldReverseLayout : Z
    //   366: aload #7
    //   368: getfield mOffset : I
    //   371: invokevirtual cacheReferenceLineAndClear : (ZI)V
    //   374: iload #4
    //   376: iconst_1
    //   377: iadd
    //   378: istore #4
    //   380: goto -> 346
    //   383: aload_0
    //   384: getfield mAnchorInfo : Landroid/support/v7/widget/StaggeredGridLayoutManager$AnchorInfo;
    //   387: aload_0
    //   388: getfield mSpans : [Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   391: invokevirtual saveSpanReferenceLines : ([Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;)V
    //   394: aload_0
    //   395: aload_1
    //   396: invokevirtual detachAndScrapAttachedViews : (Landroid/support/v7/widget/RecyclerView$Recycler;)V
    //   399: aload_0
    //   400: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   403: iconst_0
    //   404: putfield mRecycle : Z
    //   407: aload_0
    //   408: iconst_0
    //   409: putfield mLaidOutInvalidFullSpan : Z
    //   412: aload_0
    //   413: aload_0
    //   414: getfield mSecondaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   417: invokevirtual getTotalSpace : ()I
    //   420: invokevirtual updateMeasureSpecs : (I)V
    //   423: aload_0
    //   424: aload #7
    //   426: getfield mPosition : I
    //   429: aload_2
    //   430: invokespecial updateLayoutState : (ILandroid/support/v7/widget/RecyclerView$State;)V
    //   433: aload #7
    //   435: getfield mLayoutFromEnd : Z
    //   438: ifeq -> 496
    //   441: aload_0
    //   442: iconst_m1
    //   443: invokespecial setLayoutStateDirection : (I)V
    //   446: aload_0
    //   447: aload_1
    //   448: aload_0
    //   449: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   452: aload_2
    //   453: invokespecial fill : (Landroid/support/v7/widget/RecyclerView$Recycler;Landroid/support/v7/widget/LayoutState;Landroid/support/v7/widget/RecyclerView$State;)I
    //   456: pop
    //   457: aload_0
    //   458: iconst_1
    //   459: invokespecial setLayoutStateDirection : (I)V
    //   462: aload_0
    //   463: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   466: aload #7
    //   468: getfield mPosition : I
    //   471: aload_0
    //   472: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   475: getfield mItemDirection : I
    //   478: iadd
    //   479: putfield mCurrentPosition : I
    //   482: aload_0
    //   483: aload_1
    //   484: aload_0
    //   485: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   488: aload_2
    //   489: invokespecial fill : (Landroid/support/v7/widget/RecyclerView$Recycler;Landroid/support/v7/widget/LayoutState;Landroid/support/v7/widget/RecyclerView$State;)I
    //   492: pop
    //   493: goto -> 548
    //   496: aload_0
    //   497: iconst_1
    //   498: invokespecial setLayoutStateDirection : (I)V
    //   501: aload_0
    //   502: aload_1
    //   503: aload_0
    //   504: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   507: aload_2
    //   508: invokespecial fill : (Landroid/support/v7/widget/RecyclerView$Recycler;Landroid/support/v7/widget/LayoutState;Landroid/support/v7/widget/RecyclerView$State;)I
    //   511: pop
    //   512: aload_0
    //   513: iconst_m1
    //   514: invokespecial setLayoutStateDirection : (I)V
    //   517: aload_0
    //   518: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   521: aload #7
    //   523: getfield mPosition : I
    //   526: aload_0
    //   527: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   530: getfield mItemDirection : I
    //   533: iadd
    //   534: putfield mCurrentPosition : I
    //   537: aload_0
    //   538: aload_1
    //   539: aload_0
    //   540: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   543: aload_2
    //   544: invokespecial fill : (Landroid/support/v7/widget/RecyclerView$Recycler;Landroid/support/v7/widget/LayoutState;Landroid/support/v7/widget/RecyclerView$State;)I
    //   547: pop
    //   548: aload_0
    //   549: invokespecial repositionToWrapContentIfNecessary : ()V
    //   552: aload_0
    //   553: invokevirtual getChildCount : ()I
    //   556: ifle -> 597
    //   559: aload_0
    //   560: getfield mShouldReverseLayout : Z
    //   563: ifeq -> 583
    //   566: aload_0
    //   567: aload_1
    //   568: aload_2
    //   569: iconst_1
    //   570: invokespecial fixEndGap : (Landroid/support/v7/widget/RecyclerView$Recycler;Landroid/support/v7/widget/RecyclerView$State;Z)V
    //   573: aload_0
    //   574: aload_1
    //   575: aload_2
    //   576: iconst_0
    //   577: invokespecial fixStartGap : (Landroid/support/v7/widget/RecyclerView$Recycler;Landroid/support/v7/widget/RecyclerView$State;Z)V
    //   580: goto -> 597
    //   583: aload_0
    //   584: aload_1
    //   585: aload_2
    //   586: iconst_1
    //   587: invokespecial fixStartGap : (Landroid/support/v7/widget/RecyclerView$Recycler;Landroid/support/v7/widget/RecyclerView$State;Z)V
    //   590: aload_0
    //   591: aload_1
    //   592: aload_2
    //   593: iconst_0
    //   594: invokespecial fixEndGap : (Landroid/support/v7/widget/RecyclerView$Recycler;Landroid/support/v7/widget/RecyclerView$State;Z)V
    //   597: iload_3
    //   598: ifeq -> 673
    //   601: aload_2
    //   602: invokevirtual isPreLayout : ()Z
    //   605: ifne -> 673
    //   608: aload_0
    //   609: getfield mGapStrategy : I
    //   612: ifeq -> 642
    //   615: aload_0
    //   616: invokevirtual getChildCount : ()I
    //   619: ifle -> 642
    //   622: aload_0
    //   623: getfield mLaidOutInvalidFullSpan : Z
    //   626: ifne -> 636
    //   629: aload_0
    //   630: invokevirtual hasGapsToFix : ()Landroid/view/View;
    //   633: ifnull -> 642
    //   636: iconst_1
    //   637: istore #4
    //   639: goto -> 645
    //   642: iconst_0
    //   643: istore #4
    //   645: iload #4
    //   647: ifeq -> 673
    //   650: aload_0
    //   651: aload_0
    //   652: getfield mCheckForGapsRunnable : Ljava/lang/Runnable;
    //   655: invokevirtual removeCallbacks : (Ljava/lang/Runnable;)Z
    //   658: pop
    //   659: aload_0
    //   660: invokevirtual checkForGaps : ()Z
    //   663: ifeq -> 673
    //   666: iload #5
    //   668: istore #4
    //   670: goto -> 676
    //   673: iconst_0
    //   674: istore #4
    //   676: aload_2
    //   677: invokevirtual isPreLayout : ()Z
    //   680: ifeq -> 690
    //   683: aload_0
    //   684: getfield mAnchorInfo : Landroid/support/v7/widget/StaggeredGridLayoutManager$AnchorInfo;
    //   687: invokevirtual reset : ()V
    //   690: aload_0
    //   691: aload #7
    //   693: getfield mLayoutFromEnd : Z
    //   696: putfield mLastLayoutFromEnd : Z
    //   699: aload_0
    //   700: aload_0
    //   701: invokevirtual isLayoutRTL : ()Z
    //   704: putfield mLastLayoutRTL : Z
    //   707: iload #4
    //   709: ifeq -> 726
    //   712: aload_0
    //   713: getfield mAnchorInfo : Landroid/support/v7/widget/StaggeredGridLayoutManager$AnchorInfo;
    //   716: invokevirtual reset : ()V
    //   719: aload_0
    //   720: aload_1
    //   721: aload_2
    //   722: iconst_0
    //   723: invokespecial onLayoutChildren : (Landroid/support/v7/widget/RecyclerView$Recycler;Landroid/support/v7/widget/RecyclerView$State;Z)V
    //   726: return }
  
  private boolean preferLastSpan(int paramInt) {
    boolean bool;
    if (this.mOrientation == 0) {
      if (paramInt == -1) {
        bool = true;
      } else {
        bool = false;
      } 
      return (bool != this.mShouldReverseLayout);
    } 
    if (paramInt == -1) {
      bool = true;
    } else {
      bool = false;
    } 
    if (bool == this.mShouldReverseLayout) {
      bool = true;
    } else {
      bool = false;
    } 
    return (bool == isLayoutRTL());
  }
  
  private void prependViewToAllSpans(View paramView) {
    for (int i = this.mSpanCount - 1; i >= 0; i--)
      this.mSpans[i].prependToSpan(paramView); 
  }
  
  private void recycle(RecyclerView.Recycler paramRecycler, LayoutState paramLayoutState) {
    if (paramLayoutState.mRecycle) {
      if (paramLayoutState.mInfinite)
        return; 
      if (paramLayoutState.mAvailable == 0) {
        if (paramLayoutState.mLayoutDirection == -1) {
          recycleFromEnd(paramRecycler, paramLayoutState.mEndLine);
          return;
        } 
        recycleFromStart(paramRecycler, paramLayoutState.mStartLine);
        return;
      } 
      if (paramLayoutState.mLayoutDirection == -1) {
        int j = paramLayoutState.mStartLine - getMaxStart(paramLayoutState.mStartLine);
        if (j < 0) {
          j = paramLayoutState.mEndLine;
        } else {
          j = paramLayoutState.mEndLine - Math.min(j, paramLayoutState.mAvailable);
        } 
        recycleFromEnd(paramRecycler, j);
        return;
      } 
      int i = getMinEnd(paramLayoutState.mEndLine) - paramLayoutState.mEndLine;
      if (i < 0) {
        i = paramLayoutState.mStartLine;
      } else {
        int j = paramLayoutState.mStartLine;
        i = Math.min(i, paramLayoutState.mAvailable) + j;
      } 
      recycleFromStart(paramRecycler, i);
    } 
  }
  
  private void recycleFromEnd(RecyclerView.Recycler paramRecycler, int paramInt) {
    int i = getChildCount() - 1;
    while (i >= 0) {
      View view = getChildAt(i);
      if (this.mPrimaryOrientation.getDecoratedStart(view) >= paramInt && this.mPrimaryOrientation.getTransformedStartWithDecoration(view) >= paramInt) {
        LayoutParams layoutParams = (LayoutParams)view.getLayoutParams();
        if (layoutParams.mFullSpan) {
          byte b2;
          boolean bool = false;
          byte b1 = 0;
          while (true) {
            b2 = bool;
            if (b1 < this.mSpanCount) {
              if ((this.mSpans[b1]).mViews.size() == 1)
                return; 
              b1++;
              continue;
            } 
            break;
          } 
          while (b2 < this.mSpanCount) {
            this.mSpans[b2].popEnd();
            b2++;
          } 
        } else {
          if (layoutParams.mSpan.mViews.size() == 1)
            return; 
          layoutParams.mSpan.popEnd();
        } 
        removeAndRecycleView(view, paramRecycler);
        i--;
      } 
    } 
  }
  
  private void recycleFromStart(RecyclerView.Recycler paramRecycler, int paramInt) {
    while (getChildCount() > 0) {
      boolean bool = false;
      View view = getChildAt(0);
      if (this.mPrimaryOrientation.getDecoratedEnd(view) <= paramInt && this.mPrimaryOrientation.getTransformedEndWithDecoration(view) <= paramInt) {
        LayoutParams layoutParams = (LayoutParams)view.getLayoutParams();
        if (layoutParams.mFullSpan) {
          byte b2;
          byte b1 = 0;
          while (true) {
            b2 = bool;
            if (b1 < this.mSpanCount) {
              if ((this.mSpans[b1]).mViews.size() == 1)
                return; 
              b1++;
              continue;
            } 
            break;
          } 
          while (b2 < this.mSpanCount) {
            this.mSpans[b2].popStart();
            b2++;
          } 
        } else {
          if (layoutParams.mSpan.mViews.size() == 1)
            return; 
          layoutParams.mSpan.popStart();
        } 
        removeAndRecycleView(view, paramRecycler);
      } 
    } 
  }
  
  private void repositionToWrapContentIfNecessary() {
    if (this.mSecondaryOrientation.getMode() == 1073741824)
      return; 
    int m = getChildCount();
    int j = 0;
    int i = 0;
    float f = 0.0F;
    while (i < m) {
      View view = getChildAt(i);
      float f1 = this.mSecondaryOrientation.getDecoratedMeasurement(view);
      if (f1 >= f) {
        float f2 = f1;
        if (((LayoutParams)view.getLayoutParams()).isFullSpan())
          f2 = f1 * 1.0F / this.mSpanCount; 
        f = Math.max(f, f2);
      } 
      i++;
    } 
    int n = this.mSizePerSpan;
    int k = Math.round(f * this.mSpanCount);
    i = k;
    if (this.mSecondaryOrientation.getMode() == Integer.MIN_VALUE)
      i = Math.min(k, this.mSecondaryOrientation.getTotalSpace()); 
    updateMeasureSpecs(i);
    i = j;
    if (this.mSizePerSpan == n)
      return; 
    while (i < m) {
      View view = getChildAt(i);
      LayoutParams layoutParams = (LayoutParams)view.getLayoutParams();
      if (!layoutParams.mFullSpan)
        if (isLayoutRTL() && this.mOrientation == 1) {
          view.offsetLeftAndRight(-(this.mSpanCount - 1 - layoutParams.mSpan.mIndex) * this.mSizePerSpan - -(this.mSpanCount - 1 - layoutParams.mSpan.mIndex) * n);
        } else {
          j = layoutParams.mSpan.mIndex * this.mSizePerSpan;
          k = layoutParams.mSpan.mIndex * n;
          if (this.mOrientation == 1) {
            view.offsetLeftAndRight(j - k);
          } else {
            view.offsetTopAndBottom(j - k);
          } 
        }  
      i++;
    } 
  }
  
  private void resolveShouldLayoutReverse() {
    if (this.mOrientation == 1 || !isLayoutRTL()) {
      this.mShouldReverseLayout = this.mReverseLayout;
      return;
    } 
    this.mShouldReverseLayout = this.mReverseLayout ^ true;
  }
  
  private void setLayoutStateDirection(int paramInt) {
    boolean bool;
    LayoutState layoutState = this.mLayoutState;
    layoutState.mLayoutDirection = paramInt;
    boolean bool1 = this.mShouldReverseLayout;
    int i = 1;
    if (paramInt == -1) {
      bool = true;
    } else {
      bool = false;
    } 
    if (bool1 == bool) {
      paramInt = i;
    } else {
      paramInt = -1;
    } 
    layoutState.mItemDirection = paramInt;
  }
  
  private void updateAllRemainingSpans(int paramInt1, int paramInt2) {
    for (byte b = 0; b < this.mSpanCount; b++) {
      if (!(this.mSpans[b]).mViews.isEmpty())
        updateRemainingSpans(this.mSpans[b], paramInt1, paramInt2); 
    } 
  }
  
  private boolean updateAnchorFromChildren(RecyclerView.State paramState, AnchorInfo paramAnchorInfo) {
    int i;
    if (this.mLastLayoutFromEnd) {
      i = findLastReferenceChildPosition(paramState.getItemCount());
    } else {
      i = findFirstReferenceChildPosition(paramState.getItemCount());
    } 
    paramAnchorInfo.mPosition = i;
    paramAnchorInfo.mOffset = Integer.MIN_VALUE;
    return true;
  }
  
  private void updateLayoutState(int paramInt, RecyclerView.State paramState) { // Byte code:
    //   0: aload_0
    //   1: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   4: astore #7
    //   6: iconst_0
    //   7: istore #5
    //   9: aload #7
    //   11: iconst_0
    //   12: putfield mAvailable : I
    //   15: aload #7
    //   17: iload_1
    //   18: putfield mCurrentPosition : I
    //   21: aload_0
    //   22: invokevirtual isSmoothScrolling : ()Z
    //   25: ifeq -> 89
    //   28: aload_2
    //   29: invokevirtual getTargetScrollPosition : ()I
    //   32: istore_3
    //   33: iload_3
    //   34: iconst_m1
    //   35: if_icmpeq -> 89
    //   38: aload_0
    //   39: getfield mShouldReverseLayout : Z
    //   42: istore #6
    //   44: iload_3
    //   45: iload_1
    //   46: if_icmpge -> 55
    //   49: iconst_1
    //   50: istore #4
    //   52: goto -> 58
    //   55: iconst_0
    //   56: istore #4
    //   58: iload #6
    //   60: iload #4
    //   62: if_icmpne -> 76
    //   65: aload_0
    //   66: getfield mPrimaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   69: invokevirtual getTotalSpace : ()I
    //   72: istore_1
    //   73: goto -> 91
    //   76: aload_0
    //   77: getfield mPrimaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   80: invokevirtual getTotalSpace : ()I
    //   83: istore_3
    //   84: iconst_0
    //   85: istore_1
    //   86: goto -> 93
    //   89: iconst_0
    //   90: istore_1
    //   91: iconst_0
    //   92: istore_3
    //   93: aload_0
    //   94: invokevirtual getClipToPadding : ()Z
    //   97: ifeq -> 135
    //   100: aload_0
    //   101: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   104: aload_0
    //   105: getfield mPrimaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   108: invokevirtual getStartAfterPadding : ()I
    //   111: iload_3
    //   112: isub
    //   113: putfield mStartLine : I
    //   116: aload_0
    //   117: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   120: aload_0
    //   121: getfield mPrimaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   124: invokevirtual getEndAfterPadding : ()I
    //   127: iload_1
    //   128: iadd
    //   129: putfield mEndLine : I
    //   132: goto -> 160
    //   135: aload_0
    //   136: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   139: aload_0
    //   140: getfield mPrimaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   143: invokevirtual getEnd : ()I
    //   146: iload_1
    //   147: iadd
    //   148: putfield mEndLine : I
    //   151: aload_0
    //   152: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   155: iload_3
    //   156: ineg
    //   157: putfield mStartLine : I
    //   160: aload_0
    //   161: getfield mLayoutState : Landroid/support/v7/widget/LayoutState;
    //   164: astore_2
    //   165: aload_2
    //   166: iconst_0
    //   167: putfield mStopInFocusable : Z
    //   170: aload_2
    //   171: iconst_1
    //   172: putfield mRecycle : Z
    //   175: iload #5
    //   177: istore #4
    //   179: aload_0
    //   180: getfield mPrimaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   183: invokevirtual getMode : ()I
    //   186: ifne -> 206
    //   189: iload #5
    //   191: istore #4
    //   193: aload_0
    //   194: getfield mPrimaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   197: invokevirtual getEnd : ()I
    //   200: ifne -> 206
    //   203: iconst_1
    //   204: istore #4
    //   206: aload_2
    //   207: iload #4
    //   209: putfield mInfinite : Z
    //   212: return }
  
  private void updateRemainingSpans(Span paramSpan, int paramInt1, int paramInt2) {
    int i = paramSpan.getDeletedSize();
    if (paramInt1 == -1) {
      if (paramSpan.getStartLine() + i <= paramInt2) {
        this.mRemainingSpans.set(paramSpan.mIndex, false);
        return;
      } 
    } else if (paramSpan.getEndLine() - i >= paramInt2) {
      this.mRemainingSpans.set(paramSpan.mIndex, false);
    } 
  }
  
  private int updateSpecWithExtra(int paramInt1, int paramInt2, int paramInt3) {
    if (paramInt2 == 0 && paramInt3 == 0)
      return paramInt1; 
    int i = View.MeasureSpec.getMode(paramInt1);
    return (i == Integer.MIN_VALUE || i == 1073741824) ? View.MeasureSpec.makeMeasureSpec(Math.max(0, View.MeasureSpec.getSize(paramInt1) - paramInt2 - paramInt3), i) : paramInt1;
  }
  
  boolean areAllEndsEqual() {
    int i = this.mSpans[0].getEndLine(-2147483648);
    for (byte b = 1; b < this.mSpanCount; b++) {
      if (this.mSpans[b].getEndLine(-2147483648) != i)
        return false; 
    } 
    return true;
  }
  
  boolean areAllStartsEqual() {
    int i = this.mSpans[0].getStartLine(-2147483648);
    for (byte b = 1; b < this.mSpanCount; b++) {
      if (this.mSpans[b].getStartLine(-2147483648) != i)
        return false; 
    } 
    return true;
  }
  
  public void assertNotInLayoutOrScroll(String paramString) {
    if (this.mPendingSavedState == null)
      super.assertNotInLayoutOrScroll(paramString); 
  }
  
  public boolean canScrollHorizontally() { return (this.mOrientation == 0); }
  
  public boolean canScrollVertically() { return (this.mOrientation == 1); }
  
  boolean checkForGaps() {
    if (getChildCount() != 0 && this.mGapStrategy != 0) {
      byte b;
      int j;
      int i;
      if (!isAttachedToWindow())
        return false; 
      if (this.mShouldReverseLayout) {
        i = getLastChildPosition();
        j = getFirstChildPosition();
      } else {
        i = getFirstChildPosition();
        j = getLastChildPosition();
      } 
      if (i == 0 && hasGapsToFix() != null) {
        this.mLazySpanLookup.clear();
        requestSimpleAnimationsInNextLayout();
        requestLayout();
        return true;
      } 
      if (!this.mLaidOutInvalidFullSpan)
        return false; 
      if (this.mShouldReverseLayout) {
        b = -1;
      } else {
        b = 1;
      } 
      LazySpanLookup lazySpanLookup = this.mLazySpanLookup;
      LazySpanLookup.FullSpanItem fullSpanItem1 = lazySpanLookup.getFirstFullSpanItemInRange(i, ++j, b, true);
      if (fullSpanItem1 == null) {
        this.mLaidOutInvalidFullSpan = false;
        this.mLazySpanLookup.forceInvalidateAfter(j);
        return false;
      } 
      LazySpanLookup.FullSpanItem fullSpanItem2 = this.mLazySpanLookup.getFirstFullSpanItemInRange(i, fullSpanItem1.mPosition, b * -1, true);
      if (fullSpanItem2 == null) {
        this.mLazySpanLookup.forceInvalidateAfter(fullSpanItem1.mPosition);
      } else {
        this.mLazySpanLookup.forceInvalidateAfter(fullSpanItem2.mPosition + 1);
      } 
      requestSimpleAnimationsInNextLayout();
      requestLayout();
      return true;
    } 
    return false;
  }
  
  public boolean checkLayoutParams(RecyclerView.LayoutParams paramLayoutParams) { return paramLayoutParams instanceof LayoutParams; }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY})
  public void collectAdjacentPrefetchPositions(int paramInt1, int paramInt2, RecyclerView.State paramState, RecyclerView.LayoutManager.LayoutPrefetchRegistry paramLayoutPrefetchRegistry) {
    if (this.mOrientation != 0)
      paramInt1 = paramInt2; 
    if (getChildCount() != 0) {
      if (paramInt1 == 0)
        return; 
      prepareLayoutStateForDelta(paramInt1, paramState);
      int[] arrayOfInt = this.mPrefetchDistances;
      if (arrayOfInt == null || arrayOfInt.length < this.mSpanCount)
        this.mPrefetchDistances = new int[this.mSpanCount]; 
      int i = 0;
      paramInt2 = 0;
      for (paramInt1 = 0; paramInt2 < this.mSpanCount; paramInt1 = j) {
        if (this.mLayoutState.mItemDirection == -1) {
          j = this.mLayoutState.mStartLine;
          k = this.mSpans[paramInt2].getStartLine(this.mLayoutState.mStartLine);
        } else {
          j = this.mSpans[paramInt2].getEndLine(this.mLayoutState.mEndLine);
          k = this.mLayoutState.mEndLine;
        } 
        int k = j - k;
        int j = paramInt1;
        if (k >= 0) {
          this.mPrefetchDistances[paramInt1] = k;
          j = paramInt1 + 1;
        } 
        paramInt2++;
      } 
      Arrays.sort(this.mPrefetchDistances, 0, paramInt1);
      for (paramInt2 = i; paramInt2 < paramInt1 && this.mLayoutState.hasMore(paramState); paramInt2++) {
        paramLayoutPrefetchRegistry.addPosition(this.mLayoutState.mCurrentPosition, this.mPrefetchDistances[paramInt2]);
        LayoutState layoutState = this.mLayoutState;
        layoutState.mCurrentPosition += this.mLayoutState.mItemDirection;
      } 
    } 
  }
  
  public int computeHorizontalScrollExtent(RecyclerView.State paramState) { return computeScrollExtent(paramState); }
  
  public int computeHorizontalScrollOffset(RecyclerView.State paramState) { return computeScrollOffset(paramState); }
  
  public int computeHorizontalScrollRange(RecyclerView.State paramState) { return computeScrollRange(paramState); }
  
  public PointF computeScrollVectorForPosition(int paramInt) {
    paramInt = calculateScrollDirectionForPosition(paramInt);
    PointF pointF = new PointF();
    if (paramInt == 0)
      return null; 
    if (this.mOrientation == 0) {
      pointF.x = paramInt;
      pointF.y = 0.0F;
      return pointF;
    } 
    pointF.x = 0.0F;
    pointF.y = paramInt;
    return pointF;
  }
  
  public int computeVerticalScrollExtent(RecyclerView.State paramState) { return computeScrollExtent(paramState); }
  
  public int computeVerticalScrollOffset(RecyclerView.State paramState) { return computeScrollOffset(paramState); }
  
  public int computeVerticalScrollRange(RecyclerView.State paramState) { return computeScrollRange(paramState); }
  
  public int[] findFirstCompletelyVisibleItemPositions(int[] paramArrayOfInt) { // Byte code:
    //   0: aload_1
    //   1: ifnonnull -> 14
    //   4: aload_0
    //   5: getfield mSpanCount : I
    //   8: newarray int
    //   10: astore_1
    //   11: goto -> 23
    //   14: aload_1
    //   15: arraylength
    //   16: aload_0
    //   17: getfield mSpanCount : I
    //   20: if_icmplt -> 54
    //   23: iconst_0
    //   24: istore_2
    //   25: iload_2
    //   26: aload_0
    //   27: getfield mSpanCount : I
    //   30: if_icmpge -> 52
    //   33: aload_1
    //   34: iload_2
    //   35: aload_0
    //   36: getfield mSpans : [Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   39: iload_2
    //   40: aaload
    //   41: invokevirtual findFirstCompletelyVisibleItemPosition : ()I
    //   44: iastore
    //   45: iload_2
    //   46: iconst_1
    //   47: iadd
    //   48: istore_2
    //   49: goto -> 25
    //   52: aload_1
    //   53: areturn
    //   54: new java/lang/StringBuilder
    //   57: dup
    //   58: invokespecial <init> : ()V
    //   61: astore_3
    //   62: aload_3
    //   63: ldc_w 'Provided int[]'s size must be more than or equal to span count. Expected:'
    //   66: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   69: pop
    //   70: aload_3
    //   71: aload_0
    //   72: getfield mSpanCount : I
    //   75: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   78: pop
    //   79: aload_3
    //   80: ldc_w ', array size:'
    //   83: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   86: pop
    //   87: aload_3
    //   88: aload_1
    //   89: arraylength
    //   90: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   93: pop
    //   94: new java/lang/IllegalArgumentException
    //   97: dup
    //   98: aload_3
    //   99: invokevirtual toString : ()Ljava/lang/String;
    //   102: invokespecial <init> : (Ljava/lang/String;)V
    //   105: astore_1
    //   106: goto -> 111
    //   109: aload_1
    //   110: athrow
    //   111: goto -> 109 }
  
  View findFirstVisibleItemClosestToEnd(boolean paramBoolean) {
    int j = this.mPrimaryOrientation.getStartAfterPadding();
    int k = this.mPrimaryOrientation.getEndAfterPadding();
    int i = getChildCount() - 1;
    View view;
    for (view = null; i >= 0; view = view1) {
      View view2 = getChildAt(i);
      int m = this.mPrimaryOrientation.getDecoratedStart(view2);
      int n = this.mPrimaryOrientation.getDecoratedEnd(view2);
      View view1 = view;
      if (n > j)
        if (m >= k) {
          view1 = view;
        } else if (n > k) {
          if (!paramBoolean)
            return view2; 
          view1 = view;
          if (view == null)
            view1 = view2; 
        } else {
          return view2;
        }  
      i--;
    } 
    return view;
  }
  
  View findFirstVisibleItemClosestToStart(boolean paramBoolean) {
    int i = this.mPrimaryOrientation.getStartAfterPadding();
    int j = this.mPrimaryOrientation.getEndAfterPadding();
    int k = getChildCount();
    View view = null;
    byte b = 0;
    while (b < k) {
      View view2 = getChildAt(b);
      int m = this.mPrimaryOrientation.getDecoratedStart(view2);
      View view1 = view;
      if (this.mPrimaryOrientation.getDecoratedEnd(view2) > i)
        if (m >= j) {
          view1 = view;
        } else if (m < i) {
          if (!paramBoolean)
            return view2; 
          view1 = view;
          if (view == null)
            view1 = view2; 
        } else {
          return view2;
        }  
      b++;
      view = view1;
    } 
    return view;
  }
  
  int findFirstVisibleItemPositionInt() {
    View view;
    if (this.mShouldReverseLayout) {
      view = findFirstVisibleItemClosestToEnd(true);
    } else {
      view = findFirstVisibleItemClosestToStart(true);
    } 
    return (view == null) ? -1 : getPosition(view);
  }
  
  public int[] findFirstVisibleItemPositions(int[] paramArrayOfInt) { // Byte code:
    //   0: aload_1
    //   1: ifnonnull -> 14
    //   4: aload_0
    //   5: getfield mSpanCount : I
    //   8: newarray int
    //   10: astore_1
    //   11: goto -> 23
    //   14: aload_1
    //   15: arraylength
    //   16: aload_0
    //   17: getfield mSpanCount : I
    //   20: if_icmplt -> 54
    //   23: iconst_0
    //   24: istore_2
    //   25: iload_2
    //   26: aload_0
    //   27: getfield mSpanCount : I
    //   30: if_icmpge -> 52
    //   33: aload_1
    //   34: iload_2
    //   35: aload_0
    //   36: getfield mSpans : [Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   39: iload_2
    //   40: aaload
    //   41: invokevirtual findFirstVisibleItemPosition : ()I
    //   44: iastore
    //   45: iload_2
    //   46: iconst_1
    //   47: iadd
    //   48: istore_2
    //   49: goto -> 25
    //   52: aload_1
    //   53: areturn
    //   54: new java/lang/StringBuilder
    //   57: dup
    //   58: invokespecial <init> : ()V
    //   61: astore_3
    //   62: aload_3
    //   63: ldc_w 'Provided int[]'s size must be more than or equal to span count. Expected:'
    //   66: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   69: pop
    //   70: aload_3
    //   71: aload_0
    //   72: getfield mSpanCount : I
    //   75: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   78: pop
    //   79: aload_3
    //   80: ldc_w ', array size:'
    //   83: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   86: pop
    //   87: aload_3
    //   88: aload_1
    //   89: arraylength
    //   90: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   93: pop
    //   94: new java/lang/IllegalArgumentException
    //   97: dup
    //   98: aload_3
    //   99: invokevirtual toString : ()Ljava/lang/String;
    //   102: invokespecial <init> : (Ljava/lang/String;)V
    //   105: astore_1
    //   106: goto -> 111
    //   109: aload_1
    //   110: athrow
    //   111: goto -> 109 }
  
  public int[] findLastCompletelyVisibleItemPositions(int[] paramArrayOfInt) { // Byte code:
    //   0: aload_1
    //   1: ifnonnull -> 14
    //   4: aload_0
    //   5: getfield mSpanCount : I
    //   8: newarray int
    //   10: astore_1
    //   11: goto -> 23
    //   14: aload_1
    //   15: arraylength
    //   16: aload_0
    //   17: getfield mSpanCount : I
    //   20: if_icmplt -> 54
    //   23: iconst_0
    //   24: istore_2
    //   25: iload_2
    //   26: aload_0
    //   27: getfield mSpanCount : I
    //   30: if_icmpge -> 52
    //   33: aload_1
    //   34: iload_2
    //   35: aload_0
    //   36: getfield mSpans : [Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   39: iload_2
    //   40: aaload
    //   41: invokevirtual findLastCompletelyVisibleItemPosition : ()I
    //   44: iastore
    //   45: iload_2
    //   46: iconst_1
    //   47: iadd
    //   48: istore_2
    //   49: goto -> 25
    //   52: aload_1
    //   53: areturn
    //   54: new java/lang/StringBuilder
    //   57: dup
    //   58: invokespecial <init> : ()V
    //   61: astore_3
    //   62: aload_3
    //   63: ldc_w 'Provided int[]'s size must be more than or equal to span count. Expected:'
    //   66: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   69: pop
    //   70: aload_3
    //   71: aload_0
    //   72: getfield mSpanCount : I
    //   75: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   78: pop
    //   79: aload_3
    //   80: ldc_w ', array size:'
    //   83: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   86: pop
    //   87: aload_3
    //   88: aload_1
    //   89: arraylength
    //   90: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   93: pop
    //   94: new java/lang/IllegalArgumentException
    //   97: dup
    //   98: aload_3
    //   99: invokevirtual toString : ()Ljava/lang/String;
    //   102: invokespecial <init> : (Ljava/lang/String;)V
    //   105: astore_1
    //   106: goto -> 111
    //   109: aload_1
    //   110: athrow
    //   111: goto -> 109 }
  
  public int[] findLastVisibleItemPositions(int[] paramArrayOfInt) { // Byte code:
    //   0: aload_1
    //   1: ifnonnull -> 14
    //   4: aload_0
    //   5: getfield mSpanCount : I
    //   8: newarray int
    //   10: astore_1
    //   11: goto -> 23
    //   14: aload_1
    //   15: arraylength
    //   16: aload_0
    //   17: getfield mSpanCount : I
    //   20: if_icmplt -> 54
    //   23: iconst_0
    //   24: istore_2
    //   25: iload_2
    //   26: aload_0
    //   27: getfield mSpanCount : I
    //   30: if_icmpge -> 52
    //   33: aload_1
    //   34: iload_2
    //   35: aload_0
    //   36: getfield mSpans : [Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   39: iload_2
    //   40: aaload
    //   41: invokevirtual findLastVisibleItemPosition : ()I
    //   44: iastore
    //   45: iload_2
    //   46: iconst_1
    //   47: iadd
    //   48: istore_2
    //   49: goto -> 25
    //   52: aload_1
    //   53: areturn
    //   54: new java/lang/StringBuilder
    //   57: dup
    //   58: invokespecial <init> : ()V
    //   61: astore_3
    //   62: aload_3
    //   63: ldc_w 'Provided int[]'s size must be more than or equal to span count. Expected:'
    //   66: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   69: pop
    //   70: aload_3
    //   71: aload_0
    //   72: getfield mSpanCount : I
    //   75: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   78: pop
    //   79: aload_3
    //   80: ldc_w ', array size:'
    //   83: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   86: pop
    //   87: aload_3
    //   88: aload_1
    //   89: arraylength
    //   90: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   93: pop
    //   94: new java/lang/IllegalArgumentException
    //   97: dup
    //   98: aload_3
    //   99: invokevirtual toString : ()Ljava/lang/String;
    //   102: invokespecial <init> : (Ljava/lang/String;)V
    //   105: astore_1
    //   106: goto -> 111
    //   109: aload_1
    //   110: athrow
    //   111: goto -> 109 }
  
  public RecyclerView.LayoutParams generateDefaultLayoutParams() { return (this.mOrientation == 0) ? new LayoutParams(-2, -1) : new LayoutParams(-1, -2); }
  
  public RecyclerView.LayoutParams generateLayoutParams(Context paramContext, AttributeSet paramAttributeSet) { return new LayoutParams(paramContext, paramAttributeSet); }
  
  public RecyclerView.LayoutParams generateLayoutParams(ViewGroup.LayoutParams paramLayoutParams) { return (paramLayoutParams instanceof ViewGroup.MarginLayoutParams) ? new LayoutParams((ViewGroup.MarginLayoutParams)paramLayoutParams) : new LayoutParams(paramLayoutParams); }
  
  public int getColumnCountForAccessibility(RecyclerView.Recycler paramRecycler, RecyclerView.State paramState) { return (this.mOrientation == 1) ? this.mSpanCount : super.getColumnCountForAccessibility(paramRecycler, paramState); }
  
  int getFirstChildPosition() { return (getChildCount() == 0) ? 0 : getPosition(getChildAt(0)); }
  
  public int getGapStrategy() { return this.mGapStrategy; }
  
  int getLastChildPosition() {
    int i = getChildCount();
    return (i == 0) ? 0 : getPosition(getChildAt(i - 1));
  }
  
  public int getOrientation() { return this.mOrientation; }
  
  public boolean getReverseLayout() { return this.mReverseLayout; }
  
  public int getRowCountForAccessibility(RecyclerView.Recycler paramRecycler, RecyclerView.State paramState) { return (this.mOrientation == 0) ? this.mSpanCount : super.getRowCountForAccessibility(paramRecycler, paramState); }
  
  public int getSpanCount() { return this.mSpanCount; }
  
  View hasGapsToFix() { // Byte code:
    //   0: aload_0
    //   1: invokevirtual getChildCount : ()I
    //   4: iconst_1
    //   5: isub
    //   6: istore_1
    //   7: new java/util/BitSet
    //   10: dup
    //   11: aload_0
    //   12: getfield mSpanCount : I
    //   15: invokespecial <init> : (I)V
    //   18: astore #7
    //   20: aload #7
    //   22: iconst_0
    //   23: aload_0
    //   24: getfield mSpanCount : I
    //   27: iconst_1
    //   28: invokevirtual set : (IIZ)V
    //   31: aload_0
    //   32: getfield mOrientation : I
    //   35: istore_2
    //   36: iconst_m1
    //   37: istore #5
    //   39: iload_2
    //   40: iconst_1
    //   41: if_icmpne -> 56
    //   44: aload_0
    //   45: invokevirtual isLayoutRTL : ()Z
    //   48: ifeq -> 56
    //   51: iconst_1
    //   52: istore_2
    //   53: goto -> 58
    //   56: iconst_m1
    //   57: istore_2
    //   58: aload_0
    //   59: getfield mShouldReverseLayout : Z
    //   62: ifeq -> 70
    //   65: iconst_m1
    //   66: istore_3
    //   67: goto -> 76
    //   70: iload_1
    //   71: iconst_1
    //   72: iadd
    //   73: istore_3
    //   74: iconst_0
    //   75: istore_1
    //   76: iload_1
    //   77: istore #4
    //   79: iload_1
    //   80: iload_3
    //   81: if_icmpge -> 90
    //   84: iconst_1
    //   85: istore #5
    //   87: iload_1
    //   88: istore #4
    //   90: iload #4
    //   92: iload_3
    //   93: if_icmpeq -> 349
    //   96: aload_0
    //   97: iload #4
    //   99: invokevirtual getChildAt : (I)Landroid/view/View;
    //   102: astore #8
    //   104: aload #8
    //   106: invokevirtual getLayoutParams : ()Landroid/view/ViewGroup$LayoutParams;
    //   109: checkcast android/support/v7/widget/StaggeredGridLayoutManager$LayoutParams
    //   112: astore #9
    //   114: aload #7
    //   116: aload #9
    //   118: getfield mSpan : Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   121: getfield mIndex : I
    //   124: invokevirtual get : (I)Z
    //   127: ifeq -> 158
    //   130: aload_0
    //   131: aload #9
    //   133: getfield mSpan : Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   136: invokespecial checkSpanForGap : (Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;)Z
    //   139: ifeq -> 145
    //   142: aload #8
    //   144: areturn
    //   145: aload #7
    //   147: aload #9
    //   149: getfield mSpan : Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   152: getfield mIndex : I
    //   155: invokevirtual clear : (I)V
    //   158: aload #9
    //   160: getfield mFullSpan : Z
    //   163: ifeq -> 169
    //   166: goto -> 339
    //   169: iload #4
    //   171: iload #5
    //   173: iadd
    //   174: istore_1
    //   175: iload_1
    //   176: iload_3
    //   177: if_icmpeq -> 339
    //   180: aload_0
    //   181: iload_1
    //   182: invokevirtual getChildAt : (I)Landroid/view/View;
    //   185: astore #10
    //   187: aload_0
    //   188: getfield mShouldReverseLayout : Z
    //   191: ifeq -> 233
    //   194: aload_0
    //   195: getfield mPrimaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   198: aload #8
    //   200: invokevirtual getDecoratedEnd : (Landroid/view/View;)I
    //   203: istore_1
    //   204: aload_0
    //   205: getfield mPrimaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   208: aload #10
    //   210: invokevirtual getDecoratedEnd : (Landroid/view/View;)I
    //   213: istore #6
    //   215: iload_1
    //   216: iload #6
    //   218: if_icmpge -> 224
    //   221: aload #8
    //   223: areturn
    //   224: iload_1
    //   225: iload #6
    //   227: if_icmpne -> 274
    //   230: goto -> 269
    //   233: aload_0
    //   234: getfield mPrimaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   237: aload #8
    //   239: invokevirtual getDecoratedStart : (Landroid/view/View;)I
    //   242: istore_1
    //   243: aload_0
    //   244: getfield mPrimaryOrientation : Landroid/support/v7/widget/OrientationHelper;
    //   247: aload #10
    //   249: invokevirtual getDecoratedStart : (Landroid/view/View;)I
    //   252: istore #6
    //   254: iload_1
    //   255: iload #6
    //   257: if_icmple -> 263
    //   260: aload #8
    //   262: areturn
    //   263: iload_1
    //   264: iload #6
    //   266: if_icmpne -> 274
    //   269: iconst_1
    //   270: istore_1
    //   271: goto -> 276
    //   274: iconst_0
    //   275: istore_1
    //   276: iload_1
    //   277: ifeq -> 339
    //   280: aload #10
    //   282: invokevirtual getLayoutParams : ()Landroid/view/ViewGroup$LayoutParams;
    //   285: checkcast android/support/v7/widget/StaggeredGridLayoutManager$LayoutParams
    //   288: astore #10
    //   290: aload #9
    //   292: getfield mSpan : Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   295: getfield mIndex : I
    //   298: aload #10
    //   300: getfield mSpan : Landroid/support/v7/widget/StaggeredGridLayoutManager$Span;
    //   303: getfield mIndex : I
    //   306: isub
    //   307: ifge -> 315
    //   310: iconst_1
    //   311: istore_1
    //   312: goto -> 317
    //   315: iconst_0
    //   316: istore_1
    //   317: iload_2
    //   318: ifge -> 327
    //   321: iconst_1
    //   322: istore #6
    //   324: goto -> 330
    //   327: iconst_0
    //   328: istore #6
    //   330: iload_1
    //   331: iload #6
    //   333: if_icmpeq -> 339
    //   336: aload #8
    //   338: areturn
    //   339: iload #4
    //   341: iload #5
    //   343: iadd
    //   344: istore #4
    //   346: goto -> 90
    //   349: aconst_null
    //   350: areturn }
  
  public void invalidateSpanAssignments() {
    this.mLazySpanLookup.clear();
    requestLayout();
  }
  
  public boolean isAutoMeasureEnabled() { return (this.mGapStrategy != 0); }
  
  boolean isLayoutRTL() { return (getLayoutDirection() == 1); }
  
  public void offsetChildrenHorizontal(int paramInt) {
    super.offsetChildrenHorizontal(paramInt);
    for (byte b = 0; b < this.mSpanCount; b++)
      this.mSpans[b].onOffset(paramInt); 
  }
  
  public void offsetChildrenVertical(int paramInt) {
    super.offsetChildrenVertical(paramInt);
    for (byte b = 0; b < this.mSpanCount; b++)
      this.mSpans[b].onOffset(paramInt); 
  }
  
  public void onDetachedFromWindow(RecyclerView paramRecyclerView, RecyclerView.Recycler paramRecycler) {
    super.onDetachedFromWindow(paramRecyclerView, paramRecycler);
    removeCallbacks(this.mCheckForGapsRunnable);
    for (byte b = 0; b < this.mSpanCount; b++)
      this.mSpans[b].clear(); 
    paramRecyclerView.requestLayout();
  }
  
  @Nullable
  public View onFocusSearchFailed(View paramView, int paramInt, RecyclerView.Recycler paramRecycler, RecyclerView.State paramState) {
    if (getChildCount() == 0)
      return null; 
    paramView = findContainingItemView(paramView);
    if (paramView == null)
      return null; 
    resolveShouldLayoutReverse();
    int k = convertFocusDirectionToLayoutDirection(paramInt);
    if (k == Integer.MIN_VALUE)
      return null; 
    LayoutParams layoutParams = (LayoutParams)paramView.getLayoutParams();
    boolean bool1 = layoutParams.mFullSpan;
    Span span = layoutParams.mSpan;
    if (k == 1) {
      paramInt = getLastChildPosition();
    } else {
      paramInt = getFirstChildPosition();
    } 
    updateLayoutState(paramInt, paramState);
    setLayoutStateDirection(k);
    LayoutState layoutState = this.mLayoutState;
    layoutState.mCurrentPosition = layoutState.mItemDirection + paramInt;
    this.mLayoutState.mAvailable = (int)(this.mPrimaryOrientation.getTotalSpace() * 0.33333334F);
    layoutState = this.mLayoutState;
    layoutState.mStopInFocusable = true;
    int j = 0;
    layoutState.mRecycle = false;
    fill(paramRecycler, layoutState, paramState);
    this.mLastLayoutFromEnd = this.mShouldReverseLayout;
    if (!bool1) {
      View view = span.getFocusableViewAfter(paramInt, k);
      if (view != null && view != paramView)
        return view; 
    } 
    if (preferLastSpan(k)) {
      int m;
      for (m = this.mSpanCount - 1; m >= 0; m--) {
        View view = this.mSpans[m].getFocusableViewAfter(paramInt, k);
        if (view != null && view != paramView)
          return view; 
      } 
    } else {
      byte b;
      for (b = 0; b < this.mSpanCount; b++) {
        View view = this.mSpans[b].getFocusableViewAfter(paramInt, k);
        if (view != null && view != paramView)
          return view; 
      } 
    } 
    boolean bool2 = this.mReverseLayout;
    if (k == -1) {
      paramInt = 1;
    } else {
      paramInt = 0;
    } 
    if ((bool2 ^ true) == paramInt) {
      paramInt = 1;
    } else {
      paramInt = 0;
    } 
    if (!bool1) {
      int m;
      if (paramInt != 0) {
        m = span.findFirstPartiallyVisibleItemPosition();
      } else {
        m = span.findLastPartiallyVisibleItemPosition();
      } 
      View view = findViewByPosition(m);
      if (view != null && view != paramView)
        return view; 
    } 
    int i = j;
    if (preferLastSpan(k)) {
      for (i = this.mSpanCount - 1; i >= 0; i--) {
        if (i != span.mIndex) {
          if (paramInt != 0) {
            j = this.mSpans[i].findFirstPartiallyVisibleItemPosition();
          } else {
            j = this.mSpans[i].findLastPartiallyVisibleItemPosition();
          } 
          View view = findViewByPosition(j);
          if (view != null && view != paramView)
            return view; 
        } 
      } 
    } else {
      while (i < this.mSpanCount) {
        if (paramInt != 0) {
          j = this.mSpans[i].findFirstPartiallyVisibleItemPosition();
        } else {
          j = this.mSpans[i].findLastPartiallyVisibleItemPosition();
        } 
        View view = findViewByPosition(j);
        if (view != null && view != paramView)
          return view; 
        i++;
      } 
    } 
    return null;
  }
  
  public void onInitializeAccessibilityEvent(AccessibilityEvent paramAccessibilityEvent) {
    super.onInitializeAccessibilityEvent(paramAccessibilityEvent);
    if (getChildCount() > 0) {
      View view1 = findFirstVisibleItemClosestToStart(false);
      View view2 = findFirstVisibleItemClosestToEnd(false);
      if (view1 != null) {
        if (view2 == null)
          return; 
        int i = getPosition(view1);
        int j = getPosition(view2);
        if (i < j) {
          paramAccessibilityEvent.setFromIndex(i);
          paramAccessibilityEvent.setToIndex(j);
          return;
        } 
        paramAccessibilityEvent.setFromIndex(j);
        paramAccessibilityEvent.setToIndex(i);
      } 
    } 
  }
  
  public void onInitializeAccessibilityNodeInfoForItem(RecyclerView.Recycler paramRecycler, RecyclerView.State paramState, View paramView, AccessibilityNodeInfoCompat paramAccessibilityNodeInfoCompat) {
    byte b;
    ViewGroup.LayoutParams layoutParams1 = paramView.getLayoutParams();
    if (!(layoutParams1 instanceof LayoutParams)) {
      onInitializeAccessibilityNodeInfoForItem(paramView, paramAccessibilityNodeInfoCompat);
      return;
    } 
    LayoutParams layoutParams = (LayoutParams)layoutParams1;
    if (this.mOrientation == 0) {
      int j = layoutParams.getSpanIndex();
      if (layoutParams.mFullSpan) {
        b = this.mSpanCount;
      } else {
        b = 1;
      } 
      paramAccessibilityNodeInfoCompat.setCollectionItemInfo(AccessibilityNodeInfoCompat.CollectionItemInfoCompat.obtain(j, b, -1, -1, layoutParams.mFullSpan, false));
      return;
    } 
    int i = layoutParams.getSpanIndex();
    if (layoutParams.mFullSpan) {
      b = this.mSpanCount;
    } else {
      b = 1;
    } 
    paramAccessibilityNodeInfoCompat.setCollectionItemInfo(AccessibilityNodeInfoCompat.CollectionItemInfoCompat.obtain(-1, -1, i, b, layoutParams.mFullSpan, false));
  }
  
  public void onItemsAdded(RecyclerView paramRecyclerView, int paramInt1, int paramInt2) { handleUpdate(paramInt1, paramInt2, 1); }
  
  public void onItemsChanged(RecyclerView paramRecyclerView) {
    this.mLazySpanLookup.clear();
    requestLayout();
  }
  
  public void onItemsMoved(RecyclerView paramRecyclerView, int paramInt1, int paramInt2, int paramInt3) { handleUpdate(paramInt1, paramInt2, 8); }
  
  public void onItemsRemoved(RecyclerView paramRecyclerView, int paramInt1, int paramInt2) { handleUpdate(paramInt1, paramInt2, 2); }
  
  public void onItemsUpdated(RecyclerView paramRecyclerView, int paramInt1, int paramInt2, Object paramObject) { handleUpdate(paramInt1, paramInt2, 4); }
  
  public void onLayoutChildren(RecyclerView.Recycler paramRecycler, RecyclerView.State paramState) { onLayoutChildren(paramRecycler, paramState, true); }
  
  public void onLayoutCompleted(RecyclerView.State paramState) {
    super.onLayoutCompleted(paramState);
    this.mPendingScrollPosition = -1;
    this.mPendingScrollPositionOffset = Integer.MIN_VALUE;
    this.mPendingSavedState = null;
    this.mAnchorInfo.reset();
  }
  
  public void onRestoreInstanceState(Parcelable paramParcelable) {
    if (paramParcelable instanceof SavedState) {
      this.mPendingSavedState = (SavedState)paramParcelable;
      requestLayout();
    } 
  }
  
  public Parcelable onSaveInstanceState() {
    SavedState savedState = this.mPendingSavedState;
    if (savedState != null)
      return new SavedState(savedState); 
    savedState = new SavedState();
    savedState.mReverseLayout = this.mReverseLayout;
    savedState.mAnchorLayoutFromEnd = this.mLastLayoutFromEnd;
    savedState.mLastLayoutRTL = this.mLastLayoutRTL;
    LazySpanLookup lazySpanLookup = this.mLazySpanLookup;
    byte b = 0;
    if (lazySpanLookup != null && lazySpanLookup.mData != null) {
      savedState.mSpanLookup = this.mLazySpanLookup.mData;
      savedState.mSpanLookupSize = savedState.mSpanLookup.length;
      savedState.mFullSpanItems = this.mLazySpanLookup.mFullSpanItems;
    } else {
      savedState.mSpanLookupSize = 0;
    } 
    if (getChildCount() > 0) {
      if (this.mLastLayoutFromEnd) {
        i = getLastChildPosition();
      } else {
        i = getFirstChildPosition();
      } 
      savedState.mAnchorPosition = i;
      savedState.mVisibleAnchorPosition = findFirstVisibleItemPositionInt();
      int i = this.mSpanCount;
      savedState.mSpanOffsetsSize = i;
      savedState.mSpanOffsets = new int[i];
      while (b < this.mSpanCount) {
        int j;
        if (this.mLastLayoutFromEnd) {
          j = this.mSpans[b].getEndLine(-2147483648);
          i = j;
          if (j != Integer.MIN_VALUE) {
            i = this.mPrimaryOrientation.getEndAfterPadding();
          } else {
            continue;
          } 
        } else {
          j = this.mSpans[b].getStartLine(-2147483648);
          i = j;
          if (j != Integer.MIN_VALUE) {
            i = this.mPrimaryOrientation.getStartAfterPadding();
          } else {
            continue;
          } 
        } 
        i = j - i;
        continue;
        savedState.mSpanOffsets[b] = i;
        b++;
      } 
    } else {
      savedState.mAnchorPosition = -1;
      savedState.mVisibleAnchorPosition = -1;
      savedState.mSpanOffsetsSize = 0;
    } 
    return savedState;
  }
  
  public void onScrollStateChanged(int paramInt) {
    if (paramInt == 0)
      checkForGaps(); 
  }
  
  void prepareLayoutStateForDelta(int paramInt, RecyclerView.State paramState) {
    byte b;
    int i;
    if (paramInt > 0) {
      i = getLastChildPosition();
      b = 1;
    } else {
      i = getFirstChildPosition();
      b = -1;
    } 
    this.mLayoutState.mRecycle = true;
    updateLayoutState(i, paramState);
    setLayoutStateDirection(b);
    LayoutState layoutState = this.mLayoutState;
    layoutState.mCurrentPosition = i + layoutState.mItemDirection;
    this.mLayoutState.mAvailable = Math.abs(paramInt);
  }
  
  int scrollBy(int paramInt, RecyclerView.Recycler paramRecycler, RecyclerView.State paramState) {
    if (getChildCount() != 0) {
      if (paramInt == 0)
        return 0; 
      prepareLayoutStateForDelta(paramInt, paramState);
      int i = fill(paramRecycler, this.mLayoutState, paramState);
      if (this.mLayoutState.mAvailable >= i)
        if (paramInt < 0) {
          paramInt = -i;
        } else {
          paramInt = i;
        }  
      this.mPrimaryOrientation.offsetChildren(-paramInt);
      this.mLastLayoutFromEnd = this.mShouldReverseLayout;
      LayoutState layoutState = this.mLayoutState;
      layoutState.mAvailable = 0;
      recycle(paramRecycler, layoutState);
      return paramInt;
    } 
    return 0;
  }
  
  public int scrollHorizontallyBy(int paramInt, RecyclerView.Recycler paramRecycler, RecyclerView.State paramState) { return scrollBy(paramInt, paramRecycler, paramState); }
  
  public void scrollToPosition(int paramInt) {
    SavedState savedState = this.mPendingSavedState;
    if (savedState != null && savedState.mAnchorPosition != paramInt)
      this.mPendingSavedState.invalidateAnchorPositionInfo(); 
    this.mPendingScrollPosition = paramInt;
    this.mPendingScrollPositionOffset = Integer.MIN_VALUE;
    requestLayout();
  }
  
  public void scrollToPositionWithOffset(int paramInt1, int paramInt2) {
    SavedState savedState = this.mPendingSavedState;
    if (savedState != null)
      savedState.invalidateAnchorPositionInfo(); 
    this.mPendingScrollPosition = paramInt1;
    this.mPendingScrollPositionOffset = paramInt2;
    requestLayout();
  }
  
  public int scrollVerticallyBy(int paramInt, RecyclerView.Recycler paramRecycler, RecyclerView.State paramState) { return scrollBy(paramInt, paramRecycler, paramState); }
  
  public void setGapStrategy(int paramInt) {
    assertNotInLayoutOrScroll(null);
    if (paramInt == this.mGapStrategy)
      return; 
    if (paramInt == 0 || paramInt == 2) {
      this.mGapStrategy = paramInt;
      requestLayout();
      return;
    } 
    throw new IllegalArgumentException("invalid gap strategy. Must be GAP_HANDLING_NONE or GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS");
  }
  
  public void setMeasuredDimension(Rect paramRect, int paramInt1, int paramInt2) {
    int i = getPaddingLeft() + getPaddingRight();
    int j = getPaddingTop() + getPaddingBottom();
    if (this.mOrientation == 1) {
      paramInt2 = chooseSize(paramInt2, paramRect.height() + j, getMinimumHeight());
      i = chooseSize(paramInt1, this.mSizePerSpan * this.mSpanCount + i, getMinimumWidth());
      paramInt1 = paramInt2;
      paramInt2 = i;
    } else {
      paramInt1 = chooseSize(paramInt1, paramRect.width() + i, getMinimumWidth());
      i = chooseSize(paramInt2, this.mSizePerSpan * this.mSpanCount + j, getMinimumHeight());
      paramInt2 = paramInt1;
      paramInt1 = i;
    } 
    setMeasuredDimension(paramInt2, paramInt1);
  }
  
  public void setOrientation(int paramInt) {
    if (paramInt == 0 || paramInt == 1) {
      assertNotInLayoutOrScroll(null);
      if (paramInt == this.mOrientation)
        return; 
      this.mOrientation = paramInt;
      OrientationHelper orientationHelper = this.mPrimaryOrientation;
      this.mPrimaryOrientation = this.mSecondaryOrientation;
      this.mSecondaryOrientation = orientationHelper;
      requestLayout();
      return;
    } 
    throw new IllegalArgumentException("invalid orientation.");
  }
  
  public void setReverseLayout(boolean paramBoolean) {
    assertNotInLayoutOrScroll(null);
    SavedState savedState = this.mPendingSavedState;
    if (savedState != null && savedState.mReverseLayout != paramBoolean)
      this.mPendingSavedState.mReverseLayout = paramBoolean; 
    this.mReverseLayout = paramBoolean;
    requestLayout();
  }
  
  public void setSpanCount(int paramInt) {
    assertNotInLayoutOrScroll(null);
    if (paramInt != this.mSpanCount) {
      invalidateSpanAssignments();
      this.mSpanCount = paramInt;
      this.mRemainingSpans = new BitSet(this.mSpanCount);
      this.mSpans = new Span[this.mSpanCount];
      for (paramInt = 0; paramInt < this.mSpanCount; paramInt++)
        this.mSpans[paramInt] = new Span(this, paramInt); 
      requestLayout();
    } 
  }
  
  public void smoothScrollToPosition(RecyclerView paramRecyclerView, RecyclerView.State paramState, int paramInt) {
    LinearSmoothScroller linearSmoothScroller = new LinearSmoothScroller(paramRecyclerView.getContext());
    linearSmoothScroller.setTargetPosition(paramInt);
    startSmoothScroll(linearSmoothScroller);
  }
  
  public boolean supportsPredictiveItemAnimations() { return (this.mPendingSavedState == null); }
  
  boolean updateAnchorFromPendingData(RecyclerView.State paramState, AnchorInfo paramAnchorInfo) {
    boolean bool1 = paramState.isPreLayout();
    boolean bool = false;
    if (!bool1) {
      int i = this.mPendingScrollPosition;
      if (i == -1)
        return false; 
      if (i < 0 || i >= paramState.getItemCount()) {
        this.mPendingScrollPosition = -1;
        this.mPendingScrollPositionOffset = Integer.MIN_VALUE;
        return false;
      } 
      SavedState savedState = this.mPendingSavedState;
      if (savedState == null || savedState.mAnchorPosition == -1 || this.mPendingSavedState.mSpanOffsetsSize < 1) {
        View view = findViewByPosition(this.mPendingScrollPosition);
        if (view != null) {
          if (this.mShouldReverseLayout) {
            i = getLastChildPosition();
          } else {
            i = getFirstChildPosition();
          } 
          paramAnchorInfo.mPosition = i;
          if (this.mPendingScrollPositionOffset != Integer.MIN_VALUE) {
            if (paramAnchorInfo.mLayoutFromEnd) {
              paramAnchorInfo.mOffset = this.mPrimaryOrientation.getEndAfterPadding() - this.mPendingScrollPositionOffset - this.mPrimaryOrientation.getDecoratedEnd(view);
              return true;
            } 
            paramAnchorInfo.mOffset = this.mPrimaryOrientation.getStartAfterPadding() + this.mPendingScrollPositionOffset - this.mPrimaryOrientation.getDecoratedStart(view);
            return true;
          } 
          if (this.mPrimaryOrientation.getDecoratedMeasurement(view) > this.mPrimaryOrientation.getTotalSpace()) {
            if (paramAnchorInfo.mLayoutFromEnd) {
              i = this.mPrimaryOrientation.getEndAfterPadding();
            } else {
              i = this.mPrimaryOrientation.getStartAfterPadding();
            } 
            paramAnchorInfo.mOffset = i;
            return true;
          } 
          i = this.mPrimaryOrientation.getDecoratedStart(view) - this.mPrimaryOrientation.getStartAfterPadding();
          if (i < 0) {
            paramAnchorInfo.mOffset = -i;
            return true;
          } 
          i = this.mPrimaryOrientation.getEndAfterPadding() - this.mPrimaryOrientation.getDecoratedEnd(view);
          if (i < 0) {
            paramAnchorInfo.mOffset = i;
            return true;
          } 
          paramAnchorInfo.mOffset = Integer.MIN_VALUE;
          return true;
        } 
        paramAnchorInfo.mPosition = this.mPendingScrollPosition;
        i = this.mPendingScrollPositionOffset;
        if (i == Integer.MIN_VALUE) {
          if (calculateScrollDirectionForPosition(paramAnchorInfo.mPosition) == 1)
            bool = true; 
          paramAnchorInfo.mLayoutFromEnd = bool;
          paramAnchorInfo.assignCoordinateFromPadding();
        } else {
          paramAnchorInfo.assignCoordinateFromPadding(i);
        } 
        paramAnchorInfo.mInvalidateOffsets = true;
        return true;
      } 
      paramAnchorInfo.mOffset = Integer.MIN_VALUE;
      paramAnchorInfo.mPosition = this.mPendingScrollPosition;
      return true;
    } 
    return false;
  }
  
  void updateAnchorInfoForLayout(RecyclerView.State paramState, AnchorInfo paramAnchorInfo) {
    if (updateAnchorFromPendingData(paramState, paramAnchorInfo))
      return; 
    if (updateAnchorFromChildren(paramState, paramAnchorInfo))
      return; 
    paramAnchorInfo.assignCoordinateFromPadding();
    paramAnchorInfo.mPosition = 0;
  }
  
  void updateMeasureSpecs(int paramInt) {
    this.mSizePerSpan = paramInt / this.mSpanCount;
    this.mFullSizeSpec = View.MeasureSpec.makeMeasureSpec(paramInt, this.mSecondaryOrientation.getMode());
  }
}

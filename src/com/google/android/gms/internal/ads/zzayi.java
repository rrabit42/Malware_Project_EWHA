package com.google.android.gms.internal.ads;

import java.security.GeneralSecurityException;
import java.util.Arrays;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public final class zzayi implements zzatz {
  private final SecretKeySpec zzdmu;
  
  private final byte[] zzdmx;
  
  private final byte[] zzdmy;
  
  private final int zzdmz;
  
  public zzayi(byte[] paramArrayOfByte, int paramInt) throws GeneralSecurityException {
    if (paramInt == 12 || paramInt == 16) {
      this.zzdmz = paramInt;
      this.zzdmu = new SecretKeySpec(paramArrayOfByte, "AES");
      Cipher cipher = Cipher.getInstance("AES/ECB/NOPADDING");
      cipher.init(1, this.zzdmu);
      this.zzdmx = zzl(cipher.doFinal(new byte[16]));
      this.zzdmy = zzl(this.zzdmx);
      return;
    } 
    throw new IllegalArgumentException("IV size should be either 12 or 16 bytes");
  }
  
  private final byte[] zza(Cipher paramCipher, int paramInt1, byte[] paramArrayOfByte, int paramInt2, int paramInt3) throws IllegalBlockSizeException, BadPaddingException {
    byte[] arrayOfByte1 = new byte[16];
    arrayOfByte1[15] = (byte)paramInt1;
    if (paramInt3 == 0)
      return paramCipher.doFinal(zzd(arrayOfByte1, this.zzdmx)); 
    arrayOfByte1 = paramCipher.doFinal(arrayOfByte1);
    int i = 0;
    for (paramInt1 = 0; paramInt3 - paramInt1 > 16; paramInt1 += 16) {
      int j;
      for (j = 0; j < 16; j++)
        arrayOfByte1[j] = (byte)(arrayOfByte1[j] ^ paramArrayOfByte[paramInt2 + paramInt1 + j]); 
      arrayOfByte1 = paramCipher.doFinal(arrayOfByte1);
    } 
    byte[] arrayOfByte2 = Arrays.copyOfRange(paramArrayOfByte, paramInt1 + paramInt2, paramInt2 + paramInt3);
    if (arrayOfByte2.length == 16) {
      paramArrayOfByte = zzd(arrayOfByte2, this.zzdmx);
    } else {
      paramArrayOfByte = Arrays.copyOf(this.zzdmy, 16);
      for (paramInt1 = i; paramInt1 < arrayOfByte2.length; paramInt1++)
        paramArrayOfByte[paramInt1] = (byte)(paramArrayOfByte[paramInt1] ^ arrayOfByte2[paramInt1]); 
      paramArrayOfByte[arrayOfByte2.length] = (byte)(paramArrayOfByte[arrayOfByte2.length] ^ 0x80);
    } 
    return paramCipher.doFinal(zzd(arrayOfByte1, paramArrayOfByte));
  }
  
  private static byte[] zzd(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    int i = paramArrayOfByte1.length;
    byte[] arrayOfByte = new byte[i];
    for (byte b = 0; b < i; b++)
      arrayOfByte[b] = (byte)(paramArrayOfByte1[b] ^ paramArrayOfByte2[b]); 
    return arrayOfByte;
  }
  
  private static byte[] zzl(byte[] paramArrayOfByte) {
    byte[] arrayOfByte = new byte[16];
    byte b = 0;
    short s;
    for (s = 0; s < 15; s = b2) {
      byte b3 = paramArrayOfByte[s];
      byte b2 = s + true;
      arrayOfByte[s] = (byte)(b3 << 1 ^ (paramArrayOfByte[b2] & 0xFF) >>> 7);
    } 
    byte b1 = paramArrayOfByte[15];
    if ((paramArrayOfByte[0] & 0x80) == 0) {
      s = b;
    } else {
      s = 135;
    } 
    arrayOfByte[15] = (byte)(b1 << 1 ^ s);
    return arrayOfByte;
  }
  
  public final byte[] zzc(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    int i = paramArrayOfByte1.length;
    int j = this.zzdmz;
    if (i <= Integer.MAX_VALUE - j - 16) {
      byte[] arrayOfByte1 = new byte[paramArrayOfByte1.length + j + 16];
      byte[] arrayOfByte3 = zzazl.zzbh(j);
      j = this.zzdmz;
      i = 0;
      System.arraycopy(arrayOfByte3, 0, arrayOfByte1, 0, j);
      Cipher cipher1 = Cipher.getInstance("AES/ECB/NOPADDING");
      cipher1.init(1, this.zzdmu);
      arrayOfByte3 = zza(cipher1, 0, arrayOfByte3, 0, arrayOfByte3.length);
      if (paramArrayOfByte2 == null)
        paramArrayOfByte2 = new byte[0]; 
      paramArrayOfByte2 = zza(cipher1, 1, paramArrayOfByte2, 0, paramArrayOfByte2.length);
      Cipher cipher2 = Cipher.getInstance("AES/CTR/NOPADDING");
      cipher2.init(1, this.zzdmu, new IvParameterSpec(arrayOfByte3));
      cipher2.doFinal(paramArrayOfByte1, 0, paramArrayOfByte1.length, arrayOfByte1, this.zzdmz);
      byte[] arrayOfByte2 = zza(cipher1, 2, arrayOfByte1, this.zzdmz, paramArrayOfByte1.length);
      j = paramArrayOfByte1.length;
      int k = this.zzdmz;
      while (i < 16) {
        arrayOfByte1[j + k + i] = (byte)(paramArrayOfByte2[i] ^ arrayOfByte3[i] ^ arrayOfByte2[i]);
        i++;
      } 
      return arrayOfByte1;
    } 
    GeneralSecurityException generalSecurityException = new GeneralSecurityException("plaintext too long");
    throw generalSecurityException;
  }
}

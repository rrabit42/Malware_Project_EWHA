package com.bumptech.glide.gifencoder;

class NeuQuant {
  protected static final int alphabiasshift = 10;
  
  protected static final int alpharadbias = 262144;
  
  protected static final int alpharadbshift = 18;
  
  protected static final int beta = 64;
  
  protected static final int betagamma = 65536;
  
  protected static final int betashift = 10;
  
  protected static final int gamma = 1024;
  
  protected static final int gammashift = 10;
  
  protected static final int initalpha = 1024;
  
  protected static final int initrad = 32;
  
  protected static final int initradius = 2048;
  
  protected static final int intbias = 65536;
  
  protected static final int intbiasshift = 16;
  
  protected static final int maxnetpos = 255;
  
  protected static final int minpicturebytes = 1509;
  
  protected static final int ncycles = 100;
  
  protected static final int netbiasshift = 4;
  
  protected static final int netsize = 256;
  
  protected static final int prime1 = 499;
  
  protected static final int prime2 = 491;
  
  protected static final int prime3 = 487;
  
  protected static final int prime4 = 503;
  
  protected static final int radbias = 256;
  
  protected static final int radbiasshift = 8;
  
  protected static final int radiusbias = 64;
  
  protected static final int radiusbiasshift = 6;
  
  protected static final int radiusdec = 30;
  
  protected int alphadec;
  
  protected int[] bias = new int[256];
  
  protected int[] freq = new int[256];
  
  protected int lengthcount;
  
  protected int[] netindex = new int[256];
  
  protected int[][] network;
  
  protected int[] radpower = new int[32];
  
  protected int samplefac;
  
  protected byte[] thepicture;
  
  public NeuQuant(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    this.thepicture = paramArrayOfByte;
    this.lengthcount = paramInt1;
    this.samplefac = paramInt2;
    this.network = new int[256][];
    for (paramInt1 = 0; paramInt1 < 256; paramInt1++) {
      int[][] arrayOfInt1 = this.network;
      arrayOfInt1[paramInt1] = new int[4];
      int[] arrayOfInt = arrayOfInt1[paramInt1];
      paramInt2 = (paramInt1 << 12) / 256;
      arrayOfInt[2] = paramInt2;
      arrayOfInt[1] = paramInt2;
      arrayOfInt[0] = paramInt2;
      this.freq[paramInt1] = 256;
      this.bias[paramInt1] = 0;
    } 
  }
  
  protected void alterneigh(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5) {
    int j = paramInt2 - paramInt1;
    int i = j;
    if (j < -1)
      i = -1; 
    paramInt1 = paramInt2 + paramInt1;
    j = paramInt1;
    if (paramInt1 > 256)
      j = 256; 
    int k = paramInt2 + 1;
    paramInt2--;
    paramInt1 = 1;
    while (true) {
      if (k < j || paramInt2 > i) {
        arrayOfInt = this.radpower;
        int m = paramInt1 + 1;
        int n = arrayOfInt[paramInt1];
        paramInt1 = k;
        if (k < j) {
          arrayOfInt = this.network[k];
          try {
            arrayOfInt[0] = arrayOfInt[0] - (arrayOfInt[0] - paramInt3) * n / 262144;
            arrayOfInt[1] = arrayOfInt[1] - (arrayOfInt[1] - paramInt4) * n / 262144;
            arrayOfInt[2] = arrayOfInt[2] - (arrayOfInt[2] - paramInt5) * n / 262144;
          } catch (Exception arrayOfInt) {}
          paramInt1 = k + 1;
        } 
        if (paramInt2 > i) {
          arrayOfInt = this.network[paramInt2];
          try {
            arrayOfInt[0] = arrayOfInt[0] - (arrayOfInt[0] - paramInt3) * n / 262144;
            arrayOfInt[1] = arrayOfInt[1] - (arrayOfInt[1] - paramInt4) * n / 262144;
            arrayOfInt[2] = arrayOfInt[2] - n * (arrayOfInt[2] - paramInt5) / 262144;
          } catch (Exception arrayOfInt) {}
          paramInt2--;
          k = paramInt1;
          paramInt1 = m;
          continue;
        } 
        k = paramInt1;
        paramInt1 = m;
        continue;
      } 
      return;
    } 
  }
  
  protected void altersingle(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5) {
    int[] arrayOfInt = this.network[paramInt2];
    arrayOfInt[0] = arrayOfInt[0] - (arrayOfInt[0] - paramInt3) * paramInt1 / 1024;
    arrayOfInt[1] = arrayOfInt[1] - (arrayOfInt[1] - paramInt4) * paramInt1 / 1024;
    arrayOfInt[2] = arrayOfInt[2] - paramInt1 * (arrayOfInt[2] - paramInt5) / 1024;
  }
  
  public byte[] colorMap() {
    byte[] arrayOfByte = new byte[768];
    int[] arrayOfInt = new int[256];
    byte b1;
    for (b1 = 0; b1 < 'Ā'; b1++)
      arrayOfInt[this.network[b1][3]] = b1; 
    b1 = 0;
    for (byte b2 = 0; b1 < 'Ā'; b2++) {
      int i = arrayOfInt[b1];
      boolean bool = b2 + true;
      int[][] arrayOfInt1 = this.network;
      arrayOfByte[b2] = (byte)arrayOfInt1[i][0];
      b2 = bool + true;
      arrayOfByte[bool] = (byte)arrayOfInt1[i][1];
      arrayOfByte[b2] = (byte)arrayOfInt1[i][2];
      b1++;
    } 
    return arrayOfByte;
  }
  
  protected int contest(int paramInt1, int paramInt2, int paramInt3) {
    byte b3 = -1;
    byte b1 = 0;
    byte b2 = -1;
    int j = Integer.MAX_VALUE;
    int i;
    for (i = Integer.MAX_VALUE; b1 < 256; i = m) {
      int[] arrayOfInt1 = this.network[b1];
      int m = arrayOfInt1[0] - paramInt1;
      int k = m;
      if (m < 0)
        k = -m; 
      int n = arrayOfInt1[1] - paramInt2;
      m = n;
      if (n < 0)
        m = -n; 
      int i1 = arrayOfInt1[2] - paramInt3;
      n = i1;
      if (i1 < 0)
        n = -i1; 
      m = k + m + n;
      k = j;
      if (m < j) {
        b3 = b1;
        k = m;
      } 
      j = m - (this.bias[b1] >> 12);
      m = i;
      if (j < i) {
        b2 = b1;
        m = j;
      } 
      arrayOfInt1 = this.freq;
      i = arrayOfInt1[b1] >> 10;
      arrayOfInt1[b1] = arrayOfInt1[b1] - i;
      arrayOfInt1 = this.bias;
      arrayOfInt1[b1] = arrayOfInt1[b1] + (i << 10);
      b1++;
      j = k;
    } 
    int[] arrayOfInt = this.freq;
    arrayOfInt[b3] = arrayOfInt[b3] + 64;
    arrayOfInt = this.bias;
    arrayOfInt[b3] = arrayOfInt[b3] - 65536;
    return b2;
  }
  
  public void inxbuild() {
    int i = 0;
    int j = 0;
    int k;
    for (k = 0; i < 256; k = n) {
      int[] arrayOfInt1 = this.network[i];
      int m = arrayOfInt1[1];
      int i1 = i + true;
      int n = i;
      int i2 = i1;
      byte b = n;
      n = i2;
      while (n < 256) {
        int[] arrayOfInt = this.network[n];
        i2 = m;
        if (arrayOfInt[1] < m) {
          i2 = arrayOfInt[1];
          b = n;
        } 
        n++;
        m = i2;
      } 
      int[] arrayOfInt2 = this.network[b];
      if (i != b) {
        n = arrayOfInt2[0];
        arrayOfInt2[0] = arrayOfInt1[0];
        arrayOfInt1[0] = n;
        n = arrayOfInt2[1];
        arrayOfInt2[1] = arrayOfInt1[1];
        arrayOfInt1[1] = n;
        n = arrayOfInt2[2];
        arrayOfInt2[2] = arrayOfInt1[2];
        arrayOfInt1[2] = n;
        n = arrayOfInt2[3];
        arrayOfInt2[3] = arrayOfInt1[3];
        arrayOfInt1[3] = n;
      } 
      i2 = j;
      n = k;
      if (m != j) {
        this.netindex[j] = k + i >> 1;
        while (true) {
          if (++j < m) {
            this.netindex[j] = i;
            continue;
          } 
          break;
        } 
        n = i;
        i2 = m;
      } 
      i = i1;
      j = i2;
    } 
    this.netindex[j] = k + 255 >> 1;
    for (i = j + 1; i < 256; i++)
      this.netindex[i] = 255; 
  }
  
  public void learn() {
    if (this.lengthcount < 1509)
      this.samplefac = 1; 
    int i = this.samplefac;
    this.alphadec = (i - 1) / 3 + 30;
    byte[] arrayOfByte = this.thepicture;
    int i2 = this.lengthcount;
    int i3 = i2 / i * 3;
    int n = i3 / 100;
    for (i = 0; i < 32; i++)
      this.radpower[i] = 1024 * (1024 - i * i) * 256 / 1024; 
    i = this.lengthcount;
    if (i < 1509) {
      i = 3;
    } else if (i % 499 != 0) {
      i = 1497;
    } else if (i % 491 != 0) {
      i = 1473;
    } else if (i % 487 != 0) {
      i = 1461;
    } else {
      i = 1509;
    } 
    byte b = 0;
    int i1 = 0;
    int k = 1024;
    int m = 32;
    int j = 2048;
    while (b < i3) {
      byte b1 = (arrayOfByte[i1 + false] & 0xFF) << 4;
      byte b2 = (arrayOfByte[i1 + true] & 0xFF) << 4;
      byte b3 = (arrayOfByte[i1 + 2] & 0xFF) << 4;
      int i6 = contest(b1, b2, b3);
      altersingle(k, i6, b1, b2, b3);
      if (m != 0)
        alterneigh(m, i6, b1, b2, b3); 
      int i5 = i1 + i;
      int i4 = i5;
      if (i5 >= i2)
        i4 = i5 - this.lengthcount; 
      b3 = b + true;
      i5 = n;
      if (n == 0)
        i5 = 1; 
      b = b3;
      i1 = i4;
      n = i5;
      if (b3 % i5 == 0) {
        m = k - k / this.alphadec;
        i6 = j - j / '\036';
        k = i6 >> 6;
        j = k;
        if (k <= 1)
          j = 0; 
        for (k = 0; k < j; k++) {
          int[] arrayOfInt = this.radpower;
          n = j * j;
          arrayOfInt[k] = (n - k * k) * 256 / n * m;
        } 
        b = b3;
        i1 = i4;
        k = m;
        m = j;
        n = i5;
        j = i6;
      } 
    } 
  }
  
  public int map(int paramInt1, int paramInt2, int paramInt3) {
    int m = this.netindex[paramInt2];
    int i = m - 1;
    int j = -1;
    int k = 1000;
    while (true) {
      if (m < 256 || i >= 0) {
        int n = m;
        int i2 = j;
        int i1 = k;
        if (m < 256) {
          int[] arrayOfInt = this.network[m];
          i1 = arrayOfInt[1] - paramInt2;
          if (i1 >= k) {
            n = 256;
            i2 = j;
            i1 = k;
          } else {
            m++;
            n = i1;
            if (i1 < 0)
              n = -i1; 
            i2 = arrayOfInt[0] - paramInt1;
            i1 = i2;
            if (i2 < 0)
              i1 = -i2; 
            int i3 = n + i1;
            n = m;
            i2 = j;
            i1 = k;
            if (i3 < k) {
              i1 = arrayOfInt[2] - paramInt3;
              n = i1;
              if (i1 < 0)
                n = -i1; 
              i3 += n;
              n = m;
              i2 = j;
              i1 = k;
              if (i3 < k) {
                i2 = arrayOfInt[3];
                i1 = i3;
                n = m;
              } 
            } 
          } 
        } 
        m = n;
        j = i2;
        k = i1;
        if (i >= 0) {
          int[] arrayOfInt = this.network[i];
          j = paramInt2 - arrayOfInt[1];
          if (j >= i1) {
            i = -1;
            m = n;
            j = i2;
            k = i1;
            continue;
          } 
          int i3 = i - 1;
          i = j;
          if (j < 0)
            i = -j; 
          k = arrayOfInt[0] - paramInt1;
          j = k;
          if (k < 0)
            j = -k; 
          int i4 = i + j;
          m = n;
          i = i3;
          j = i2;
          k = i1;
          if (i4 < i1) {
            j = arrayOfInt[2] - paramInt3;
            i = j;
            if (j < 0)
              i = -j; 
            i4 = i + i4;
            m = n;
            i = i3;
            j = i2;
            k = i1;
            if (i4 < i1) {
              j = arrayOfInt[3];
              k = i4;
              m = n;
              i = i3;
            } 
          } 
        } 
        continue;
      } 
      return j;
    } 
  }
  
  public byte[] process() {
    learn();
    unbiasnet();
    inxbuild();
    return colorMap();
  }
  
  public void unbiasnet() {
    for (byte b = 0; b < 'Ā'; b++) {
      int[][] arrayOfInt = this.network;
      int[] arrayOfInt1 = arrayOfInt[b];
      arrayOfInt1[0] = arrayOfInt1[0] >> 4;
      arrayOfInt1 = arrayOfInt[b];
      arrayOfInt1[1] = arrayOfInt1[1] >> 4;
      arrayOfInt1 = arrayOfInt[b];
      arrayOfInt1[2] = arrayOfInt1[2] >> 4;
      arrayOfInt[b][3] = b;
    } 
  }
}

package androidx.work.impl.utils;

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.annotation.RestrictTo;
import android.support.annotation.VisibleForTesting;
import androidx.work.Logger;
import androidx.work.impl.Schedulers;
import androidx.work.impl.WorkDatabase;
import androidx.work.impl.WorkManagerImpl;
import androidx.work.impl.model.WorkSpec;
import androidx.work.impl.model.WorkSpecDao;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.TimeUnit;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class ForceStopRunnable implements Runnable {
  @VisibleForTesting
  static final String ACTION_FORCE_STOP_RESCHEDULE = "ACTION_FORCE_STOP_RESCHEDULE";
  
  private static final int ALARM_ID = -1;
  
  private static final String TAG = Logger.tagWithPrefix("ForceStopRunnable");
  
  private static final long TEN_YEARS = TimeUnit.DAYS.toMillis(3650L);
  
  private final Context mContext;
  
  private final WorkManagerImpl mWorkManager;
  
  public ForceStopRunnable(@NonNull Context paramContext, @NonNull WorkManagerImpl paramWorkManagerImpl) {
    this.mContext = paramContext.getApplicationContext();
    this.mWorkManager = paramWorkManagerImpl;
  }
  
  @VisibleForTesting
  static Intent getIntent(Context paramContext) {
    Intent intent = new Intent();
    intent.setComponent(new ComponentName(paramContext, BroadcastReceiver.class));
    intent.setAction("ACTION_FORCE_STOP_RESCHEDULE");
    return intent;
  }
  
  private static PendingIntent getPendingIntent(Context paramContext, int paramInt) { return PendingIntent.getBroadcast(paramContext, -1, getIntent(paramContext), paramInt); }
  
  static void setAlarm(Context paramContext) {
    AlarmManager alarmManager = (AlarmManager)paramContext.getSystemService("alarm");
    PendingIntent pendingIntent = getPendingIntent(paramContext, 134217728);
    long l = System.currentTimeMillis() + TEN_YEARS;
    if (alarmManager != null) {
      if (Build.VERSION.SDK_INT >= 19) {
        alarmManager.setExact(0, l, pendingIntent);
        return;
      } 
      alarmManager.set(0, l, pendingIntent);
    } 
  }
  
  @VisibleForTesting
  public boolean isForceStopped() {
    if (getPendingIntent(this.mContext, 536870912) == null) {
      setAlarm(this.mContext);
      return true;
    } 
    return false;
  }
  
  public void run() {
    if (shouldRescheduleWorkers()) {
      Logger.get().debug(TAG, "Rescheduling Workers.", new Throwable[0]);
      this.mWorkManager.rescheduleEligibleWork();
      this.mWorkManager.getPreferences().setNeedsReschedule(false);
    } else if (isForceStopped()) {
      Logger.get().debug(TAG, "Application was force-stopped, rescheduling.", new Throwable[0]);
      this.mWorkManager.rescheduleEligibleWork();
    } else {
      WorkDatabase workDatabase = this.mWorkManager.getWorkDatabase();
      null = workDatabase.workSpecDao();
      try {
        workDatabase.beginTransaction();
        List list = null.getEnqueuedWork();
        if (list != null && !list.isEmpty()) {
          Logger.get().debug(TAG, "Found unfinished work, scheduling it.", new Throwable[0]);
          Iterator iterator = list.iterator();
          while (iterator.hasNext())
            null.markWorkSpecScheduled(((WorkSpec)iterator.next()).id, -1L); 
          Schedulers.schedule(this.mWorkManager.getConfiguration(), workDatabase, this.mWorkManager.getSchedulers());
        } 
        workDatabase.setTransactionSuccessful();
        workDatabase.endTransaction();
        Logger.get().debug(TAG, "Unfinished Workers exist, rescheduling.", new Throwable[0]);
        return;
      } finally {
        workDatabase.endTransaction();
      } 
    } 
    this.mWorkManager.onForceStopRunnableCompleted();
  }
  
  @VisibleForTesting
  boolean shouldRescheduleWorkers() { return this.mWorkManager.getPreferences().needsReschedule(); }
}

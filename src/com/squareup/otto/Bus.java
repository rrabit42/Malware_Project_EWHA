package com.squareup.otto;

import java.lang.reflect.InvocationTargetException;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArraySet;

public class Bus {
  public static final String DEFAULT_IDENTIFIER = "default";
  
  private final ThreadEnforcer enforcer;
  
  private final ThreadLocal<ConcurrentLinkedQueue<EventWithHandler>> eventsToDispatch = new Object(this);
  
  private final ConcurrentMap<Class<?>, Set<Class<?>>> flattenHierarchyCache = new ConcurrentHashMap();
  
  private final HandlerFinder handlerFinder;
  
  private final ConcurrentMap<Class<?>, Set<EventHandler>> handlersByType = new ConcurrentHashMap();
  
  private final String identifier;
  
  private final ThreadLocal<Boolean> isDispatching = new Object(this);
  
  private final ConcurrentMap<Class<?>, EventProducer> producersByType = new ConcurrentHashMap();
  
  public Bus() { this("default"); }
  
  public Bus(ThreadEnforcer paramThreadEnforcer) { this(paramThreadEnforcer, "default"); }
  
  public Bus(ThreadEnforcer paramThreadEnforcer, String paramString) { this(paramThreadEnforcer, paramString, HandlerFinder.ANNOTATED); }
  
  Bus(ThreadEnforcer paramThreadEnforcer, String paramString, HandlerFinder paramHandlerFinder) {
    this.enforcer = paramThreadEnforcer;
    this.identifier = paramString;
    this.handlerFinder = paramHandlerFinder;
  }
  
  public Bus(String paramString) { this(ThreadEnforcer.MAIN, paramString); }
  
  private void dispatchProducerResultToHandler(EventHandler paramEventHandler, EventProducer paramEventProducer) {
    Object object;
    try {
      Object object1 = paramEventProducer.produceEvent();
      object = object1;
    } catch (InvocationTargetException invocationTargetException) {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append("Producer ");
      stringBuilder.append(object);
      stringBuilder.append(" threw an exception.");
      throwRuntimeException(stringBuilder.toString(), invocationTargetException);
      object = null;
    } 
    if (object == null)
      return; 
    dispatch(object, paramEventHandler);
  }
  
  private Set<Class<?>> getClassesFor(Class<?> paramClass) {
    LinkedList linkedList = new LinkedList();
    HashSet hashSet = new HashSet();
    linkedList.add(paramClass);
    while (!linkedList.isEmpty()) {
      paramClass = (Class)linkedList.remove(0);
      hashSet.add(paramClass);
      paramClass = paramClass.getSuperclass();
      if (paramClass != null)
        linkedList.add(paramClass); 
    } 
    return hashSet;
  }
  
  private static void throwRuntimeException(String paramString, InvocationTargetException paramInvocationTargetException) {
    StringBuilder stringBuilder1;
    Throwable throwable = paramInvocationTargetException.getCause();
    if (throwable != null) {
      stringBuilder1 = new StringBuilder();
      stringBuilder1.append(paramString);
      stringBuilder1.append(": ");
      stringBuilder1.append(throwable.getMessage());
      throw new RuntimeException(stringBuilder1.toString(), throwable);
    } 
    StringBuilder stringBuilder2 = new StringBuilder();
    stringBuilder2.append(paramString);
    stringBuilder2.append(": ");
    stringBuilder2.append(stringBuilder1.getMessage());
    throw new RuntimeException(stringBuilder2.toString(), stringBuilder1);
  }
  
  protected void dispatch(Object paramObject, EventHandler paramEventHandler) {
    try {
      paramEventHandler.handleEvent(paramObject);
      return;
    } catch (InvocationTargetException invocationTargetException) {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append("Could not dispatch event: ");
      stringBuilder.append(paramObject.getClass());
      stringBuilder.append(" to handler ");
      stringBuilder.append(paramEventHandler);
      throwRuntimeException(stringBuilder.toString(), invocationTargetException);
      return;
    } 
  }
  
  protected void dispatchQueuedEvents() {
    if (((Boolean)this.isDispatching.get()).booleanValue())
      return; 
    this.isDispatching.set(Boolean.valueOf(true));
    try {
      while (true) {
        EventWithHandler eventWithHandler = (EventWithHandler)((ConcurrentLinkedQueue)this.eventsToDispatch.get()).poll();
        if (eventWithHandler == null)
          return; 
        if (eventWithHandler.handler.isValid())
          dispatch(eventWithHandler.event, eventWithHandler.handler); 
      } 
    } finally {
      this.isDispatching.set(Boolean.valueOf(false));
    } 
  }
  
  protected void enqueueEvent(Object paramObject, EventHandler paramEventHandler) { ((ConcurrentLinkedQueue)this.eventsToDispatch.get()).offer(new EventWithHandler(paramObject, paramEventHandler)); }
  
  Set<Class<?>> flattenHierarchy(Class<?> paramClass) {
    Set set2 = (Set)this.flattenHierarchyCache.get(paramClass);
    Set set1 = set2;
    if (set2 == null) {
      set2 = getClassesFor(paramClass);
      set1 = (Set)this.flattenHierarchyCache.putIfAbsent(paramClass, set2);
      if (set1 == null)
        return set2; 
    } 
    return set1;
  }
  
  Set<EventHandler> getHandlersForEventType(Class<?> paramClass) { return (Set)this.handlersByType.get(paramClass); }
  
  EventProducer getProducerForEventType(Class<?> paramClass) { return (EventProducer)this.producersByType.get(paramClass); }
  
  public void post(Object paramObject) {
    if (paramObject != null) {
      this.enforcer.enforce(this);
      Set set = flattenHierarchy(paramObject.getClass());
      byte b = 0;
      Iterator iterator = set.iterator();
      label23: while (iterator.hasNext()) {
        Set set1 = getHandlersForEventType((Class)iterator.next());
        if (set1 != null && !set1.isEmpty()) {
          byte b1 = 1;
          Iterator iterator1 = set1.iterator();
          while (true) {
            b = b1;
            if (iterator1.hasNext()) {
              enqueueEvent(paramObject, (EventHandler)iterator1.next());
              continue;
            } 
            continue label23;
          } 
        } 
      } 
      if (b == 0 && !(paramObject instanceof DeadEvent))
        post(new DeadEvent(this, paramObject)); 
      dispatchQueuedEvents();
      return;
    } 
    paramObject = new NullPointerException("Event to post must not be null.");
    throw paramObject;
  }
  
  public void register(Object paramObject) {
    if (paramObject != null) {
      this.enforcer.enforce(this);
      Map map = this.handlerFinder.findAllProducers(paramObject);
      for (Iterator iterator : map.keySet()) {
        EventProducer eventProducer1 = (EventProducer)map.get(iterator);
        EventProducer eventProducer2 = (EventProducer)this.producersByType.putIfAbsent(iterator, eventProducer1);
        if (eventProducer2 == null) {
          Set set = (Set)this.handlersByType.get(iterator);
          if (set != null && !set.isEmpty()) {
            iterator = set.iterator();
            while (iterator.hasNext())
              dispatchProducerResultToHandler((EventHandler)iterator.next(), eventProducer1); 
          } 
          continue;
        } 
        paramObject = new StringBuilder();
        paramObject.append("Producer method for type ");
        paramObject.append(iterator);
        paramObject.append(" found on type ");
        paramObject.append(eventProducer1.target.getClass());
        paramObject.append(", but already registered by type ");
        paramObject.append(eventProducer2.target.getClass());
        paramObject.append(".");
        throw new IllegalArgumentException(paramObject.toString());
      } 
      map = this.handlerFinder.findAllSubscribers(paramObject);
      for (Class clazz : map.keySet()) {
        Set set = (Set)this.handlersByType.get(clazz);
        paramObject = set;
        if (set == null) {
          paramObject = new CopyOnWriteArraySet();
          set = (Set)this.handlersByType.putIfAbsent(clazz, paramObject);
          if (set != null)
            paramObject = set; 
        } 
        if (paramObject.addAll((Set)map.get(clazz)))
          continue; 
        throw new IllegalArgumentException("Object already registered.");
      } 
      paramObject = map.entrySet().iterator();
      while (paramObject.hasNext()) {
        Map.Entry entry = (Map.Entry)paramObject.next();
        Class clazz = (Class)entry.getKey();
        EventProducer eventProducer = (EventProducer)this.producersByType.get(clazz);
        if (eventProducer != null && eventProducer.isValid())
          for (EventHandler eventHandler : (Set)entry.getValue()) {
            if (!eventProducer.isValid())
              break; 
            if (eventHandler.isValid())
              dispatchProducerResultToHandler(eventHandler, eventProducer); 
          }  
      } 
      return;
    } 
    paramObject = new NullPointerException("Object to register must not be null.");
    throw paramObject;
  }
  
  public String toString() {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("[Bus \"");
    stringBuilder.append(this.identifier);
    stringBuilder.append("\"]");
    return stringBuilder.toString();
  }
  
  public void unregister(Object paramObject) {
    if (paramObject != null) {
      this.enforcer.enforce(this);
      Iterator iterator = this.handlerFinder.findAllProducers(paramObject).entrySet().iterator();
      while (iterator.hasNext()) {
        Map.Entry entry = (Map.Entry)iterator.next();
        Class clazz = (Class)entry.getKey();
        EventProducer eventProducer1 = getProducerForEventType(clazz);
        EventProducer eventProducer2 = (EventProducer)entry.getValue();
        if (eventProducer2 != null && eventProducer2.equals(eventProducer1)) {
          ((EventProducer)this.producersByType.remove(clazz)).invalidate();
          continue;
        } 
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Missing event producer for an annotated method. Is ");
        stringBuilder.append(paramObject.getClass());
        stringBuilder.append(" registered?");
        throw new IllegalArgumentException(stringBuilder.toString());
      } 
      iterator = this.handlerFinder.findAllSubscribers(paramObject).entrySet().iterator();
      while (iterator.hasNext()) {
        Map.Entry entry = (Map.Entry)iterator.next();
        Set set = getHandlersForEventType((Class)entry.getKey());
        Collection collection = (Collection)entry.getValue();
        if (set != null && set.containsAll(collection)) {
          for (EventHandler eventHandler : set) {
            if (collection.contains(eventHandler))
              eventHandler.invalidate(); 
          } 
          set.removeAll(collection);
          continue;
        } 
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Missing event handler for an annotated method. Is ");
        stringBuilder.append(paramObject.getClass());
        stringBuilder.append(" registered?");
        throw new IllegalArgumentException(stringBuilder.toString());
      } 
      return;
    } 
    paramObject = new NullPointerException("Object to unregister must not be null.");
    throw paramObject;
  }
}

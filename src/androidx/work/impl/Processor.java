package androidx.work.impl;

import android.content.Context;
import android.support.annotation.NonNull;
import android.support.annotation.RestrictTo;
import androidx.work.Configuration;
import androidx.work.Logger;
import androidx.work.WorkerParameters;
import androidx.work.impl.utils.taskexecutor.TaskExecutor;
import com.google.common.util.concurrent.ListenableFuture;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class Processor implements ExecutionListener {
  private static final String TAG = Logger.tagWithPrefix("Processor");
  
  private Context mAppContext;
  
  private Set<String> mCancelledIds;
  
  private Configuration mConfiguration;
  
  private Map<String, WorkerWrapper> mEnqueuedWorkMap;
  
  private final Object mLock;
  
  private final List<ExecutionListener> mOuterListeners;
  
  private List<Scheduler> mSchedulers;
  
  private WorkDatabase mWorkDatabase;
  
  private TaskExecutor mWorkTaskExecutor;
  
  public Processor(Context paramContext, Configuration paramConfiguration, TaskExecutor paramTaskExecutor, WorkDatabase paramWorkDatabase, List<Scheduler> paramList) {
    this.mAppContext = paramContext;
    this.mConfiguration = paramConfiguration;
    this.mWorkTaskExecutor = paramTaskExecutor;
    this.mWorkDatabase = paramWorkDatabase;
    this.mEnqueuedWorkMap = new HashMap();
    this.mSchedulers = paramList;
    this.mCancelledIds = new HashSet();
    this.mOuterListeners = new ArrayList();
    this.mLock = new Object();
  }
  
  public void addExecutionListener(ExecutionListener paramExecutionListener) {
    synchronized (this.mLock) {
      this.mOuterListeners.add(paramExecutionListener);
      return;
    } 
  }
  
  public boolean hasWork() {
    synchronized (this.mLock) {
      if (!this.mEnqueuedWorkMap.isEmpty())
        return true; 
    } 
    boolean bool = false;
    /* monitor exit ClassFileLocalVariableReferenceExpression{type=ObjectType{java/lang/Object}, name=SYNTHETIC_LOCAL_VARIABLE_2} */
    return bool;
  }
  
  public boolean isCancelled(String paramString) {
    synchronized (this.mLock) {
      return this.mCancelledIds.contains(paramString);
    } 
  }
  
  public boolean isEnqueued(@NonNull String paramString) {
    synchronized (this.mLock) {
      return this.mEnqueuedWorkMap.containsKey(paramString);
    } 
  }
  
  public void onExecuted(@NonNull String paramString, boolean paramBoolean) {
    synchronized (this.mLock) {
      this.mEnqueuedWorkMap.remove(paramString);
      Logger.get().debug(TAG, String.format("%s %s executed; reschedule = %s", new Object[] { getClass().getSimpleName(), paramString, Boolean.valueOf(paramBoolean) }), new Throwable[0]);
      Iterator iterator = this.mOuterListeners.iterator();
      while (iterator.hasNext())
        ((ExecutionListener)iterator.next()).onExecuted(paramString, paramBoolean); 
      return;
    } 
  }
  
  public void removeExecutionListener(ExecutionListener paramExecutionListener) {
    synchronized (this.mLock) {
      this.mOuterListeners.remove(paramExecutionListener);
      return;
    } 
  }
  
  public boolean startWork(String paramString) { return startWork(paramString, null); }
  
  public boolean startWork(String paramString, WorkerParameters.RuntimeExtras paramRuntimeExtras) {
    synchronized (this.mLock) {
      if (this.mEnqueuedWorkMap.containsKey(paramString)) {
        Logger.get().debug(TAG, String.format("Work %s is already enqueued for processing", new Object[] { paramString }), new Throwable[0]);
        return false;
      } 
      WorkerWrapper workerWrapper = (new WorkerWrapper.Builder(this.mAppContext, this.mConfiguration, this.mWorkTaskExecutor, this.mWorkDatabase, paramString)).withSchedulers(this.mSchedulers).withRuntimeExtras(paramRuntimeExtras).build();
      ListenableFuture listenableFuture = workerWrapper.getFuture();
      listenableFuture.addListener(new FutureListener(this, paramString, listenableFuture), this.mWorkTaskExecutor.getMainThreadExecutor());
      this.mEnqueuedWorkMap.put(paramString, workerWrapper);
      this.mWorkTaskExecutor.getBackgroundExecutor().execute(workerWrapper);
      Logger.get().debug(TAG, String.format("%s: processing %s", new Object[] { getClass().getSimpleName(), paramString }), new Throwable[0]);
      return true;
    } 
  }
  
  public boolean stopAndCancelWork(String paramString) {
    synchronized (this.mLock) {
      Logger.get().debug(TAG, String.format("Processor cancelling %s", new Object[] { paramString }), new Throwable[0]);
      this.mCancelledIds.add(paramString);
      WorkerWrapper workerWrapper = (WorkerWrapper)this.mEnqueuedWorkMap.remove(paramString);
      if (workerWrapper != null) {
        workerWrapper.interrupt(true);
        Logger.get().debug(TAG, String.format("WorkerWrapper cancelled for %s", new Object[] { paramString }), new Throwable[0]);
        return true;
      } 
      Logger.get().debug(TAG, String.format("WorkerWrapper could not be found for %s", new Object[] { paramString }), new Throwable[0]);
      return false;
    } 
  }
  
  public boolean stopWork(String paramString) {
    synchronized (this.mLock) {
      Logger.get().debug(TAG, String.format("Processor stopping %s", new Object[] { paramString }), new Throwable[0]);
      WorkerWrapper workerWrapper = (WorkerWrapper)this.mEnqueuedWorkMap.remove(paramString);
      if (workerWrapper != null) {
        workerWrapper.interrupt(false);
        Logger.get().debug(TAG, String.format("WorkerWrapper stopped for %s", new Object[] { paramString }), new Throwable[0]);
        return true;
      } 
      Logger.get().debug(TAG, String.format("WorkerWrapper could not be found for %s", new Object[] { paramString }), new Throwable[0]);
      return false;
    } 
  }
}

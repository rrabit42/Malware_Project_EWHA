package androidx.work.impl;

import android.content.Context;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RestrictTo;
import android.support.annotation.VisibleForTesting;
import android.support.annotation.WorkerThread;
import androidx.work.Configuration;
import androidx.work.Data;
import androidx.work.InputMerger;
import androidx.work.ListenableWorker;
import androidx.work.Logger;
import androidx.work.WorkInfo;
import androidx.work.WorkerParameters;
import androidx.work.impl.model.DependencyDao;
import androidx.work.impl.model.WorkSpec;
import androidx.work.impl.model.WorkSpecDao;
import androidx.work.impl.model.WorkTagDao;
import androidx.work.impl.utils.PackageManagerHelper;
import androidx.work.impl.utils.futures.SettableFuture;
import androidx.work.impl.utils.taskexecutor.TaskExecutor;
import com.google.common.util.concurrent.ListenableFuture;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.UUID;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class WorkerWrapper implements Runnable {
  static final String TAG = Logger.tagWithPrefix("WorkerWrapper");
  
  private Context mAppContext;
  
  private Configuration mConfiguration;
  
  private DependencyDao mDependencyDao;
  
  @NonNull
  private SettableFuture<Boolean> mFuture = SettableFuture.create();
  
  @Nullable
  ListenableFuture<ListenableWorker.Result> mInnerFuture = null;
  
  @NonNull
  ListenableWorker.Result mResult = ListenableWorker.Result.failure();
  
  private WorkerParameters.RuntimeExtras mRuntimeExtras;
  
  private List<Scheduler> mSchedulers;
  
  private List<String> mTags;
  
  private WorkDatabase mWorkDatabase;
  
  private String mWorkDescription;
  
  WorkSpec mWorkSpec;
  
  private WorkSpecDao mWorkSpecDao;
  
  private String mWorkSpecId;
  
  private WorkTagDao mWorkTagDao;
  
  private TaskExecutor mWorkTaskExecutor;
  
  ListenableWorker mWorker;
  
  WorkerWrapper(Builder paramBuilder) {
    this.mAppContext = paramBuilder.mAppContext;
    this.mWorkTaskExecutor = paramBuilder.mWorkTaskExecutor;
    this.mWorkSpecId = paramBuilder.mWorkSpecId;
    this.mSchedulers = paramBuilder.mSchedulers;
    this.mRuntimeExtras = paramBuilder.mRuntimeExtras;
    this.mWorker = paramBuilder.mWorker;
    this.mConfiguration = paramBuilder.mConfiguration;
    this.mWorkDatabase = paramBuilder.mWorkDatabase;
    this.mWorkSpecDao = this.mWorkDatabase.workSpecDao();
    this.mDependencyDao = this.mWorkDatabase.dependencyDao();
    this.mWorkTagDao = this.mWorkDatabase.workTagDao();
  }
  
  private void assertBackgroundExecutorThread() {
    if (this.mWorkTaskExecutor.getBackgroundExecutorThread() == Thread.currentThread())
      return; 
    throw new IllegalStateException("Needs to be executed on the Background executor thread.");
  }
  
  private String createWorkDescription(List<String> paramList) {
    StringBuilder stringBuilder = new StringBuilder("Work [ id=");
    stringBuilder.append(this.mWorkSpecId);
    stringBuilder.append(", tags={ ");
    Iterator iterator = paramList.iterator();
    boolean bool = true;
    while (iterator.hasNext()) {
      String str = (String)iterator.next();
      if (bool) {
        bool = false;
      } else {
        stringBuilder.append(", ");
      } 
      stringBuilder.append(str);
    } 
    stringBuilder.append(" } ]");
    return stringBuilder.toString();
  }
  
  private void handleResult(ListenableWorker.Result paramResult) {
    if (paramResult instanceof ListenableWorker.Result.Success) {
      Logger.get().info(TAG, String.format("Worker result SUCCESS for %s", new Object[] { this.mWorkDescription }), new Throwable[0]);
      if (this.mWorkSpec.isPeriodic()) {
        resetPeriodicAndResolve();
        return;
      } 
      setSucceededAndResolve();
      return;
    } 
    if (paramResult instanceof ListenableWorker.Result.Retry) {
      Logger.get().info(TAG, String.format("Worker result RETRY for %s", new Object[] { this.mWorkDescription }), new Throwable[0]);
      rescheduleAndResolve();
      return;
    } 
    Logger.get().info(TAG, String.format("Worker result FAILURE for %s", new Object[] { this.mWorkDescription }), new Throwable[0]);
    if (this.mWorkSpec.isPeriodic()) {
      resetPeriodicAndResolve();
      return;
    } 
    setFailedAndResolve();
  }
  
  private void iterativelyFailWorkAndDependents(String paramString) {
    LinkedList linkedList = new LinkedList();
    linkedList.add(paramString);
    while (!linkedList.isEmpty()) {
      paramString = (String)linkedList.remove();
      if (this.mWorkSpecDao.getState(paramString) != WorkInfo.State.CANCELLED)
        this.mWorkSpecDao.setState(WorkInfo.State.FAILED, new String[] { paramString }); 
      linkedList.addAll(this.mDependencyDao.getDependentWorkIds(paramString));
    } 
  }
  
  private void rescheduleAndResolve() {
    this.mWorkDatabase.beginTransaction();
    try {
      this.mWorkSpecDao.setState(WorkInfo.State.ENQUEUED, new String[] { this.mWorkSpecId });
      this.mWorkSpecDao.setPeriodStartTime(this.mWorkSpecId, System.currentTimeMillis());
      if (Build.VERSION.SDK_INT < 23)
        this.mWorkSpecDao.markWorkSpecScheduled(this.mWorkSpecId, -1L); 
      this.mWorkDatabase.setTransactionSuccessful();
      return;
    } finally {
      this.mWorkDatabase.endTransaction();
      resolve(true);
    } 
  }
  
  private void resetPeriodicAndResolve() {
    this.mWorkDatabase.beginTransaction();
    try {
      this.mWorkSpecDao.setPeriodStartTime(this.mWorkSpecId, System.currentTimeMillis());
      this.mWorkSpecDao.setState(WorkInfo.State.ENQUEUED, new String[] { this.mWorkSpecId });
      this.mWorkSpecDao.resetWorkSpecRunAttemptCount(this.mWorkSpecId);
      if (Build.VERSION.SDK_INT < 23)
        this.mWorkSpecDao.markWorkSpecScheduled(this.mWorkSpecId, -1L); 
      this.mWorkDatabase.setTransactionSuccessful();
      return;
    } finally {
      this.mWorkDatabase.endTransaction();
      resolve(false);
    } 
  }
  
  private void resolve(boolean paramBoolean) {
    try {
      boolean bool;
      this.mWorkDatabase.beginTransaction();
      List list = this.mWorkDatabase.workSpecDao().getAllUnfinishedWork();
      if (list == null || list.isEmpty()) {
        bool = true;
      } else {
        bool = false;
      } 
      if (bool)
        PackageManagerHelper.setComponentEnabled(this.mAppContext, androidx.work.impl.background.systemalarm.RescheduleReceiver.class, false); 
      this.mWorkDatabase.setTransactionSuccessful();
      this.mWorkDatabase.endTransaction();
      return;
    } finally {
      this.mWorkDatabase.endTransaction();
    } 
  }
  
  private void resolveIncorrectStatus() {
    WorkInfo.State state = this.mWorkSpecDao.getState(this.mWorkSpecId);
    if (state == WorkInfo.State.RUNNING) {
      Logger.get().debug(TAG, String.format("Status for %s is RUNNING;not doing any work and rescheduling for later execution", new Object[] { this.mWorkSpecId }), new Throwable[0]);
      resolve(true);
      return;
    } 
    Logger.get().debug(TAG, String.format("Status for %s is %s; not doing any work", new Object[] { this.mWorkSpecId, state }), new Throwable[0]);
    resolve(false);
  }
  
  private void runWorker() {
    if (tryCheckForInterruptionAndResolve())
      return; 
    this.mWorkDatabase.beginTransaction();
    try {
      Data data;
      this.mWorkSpec = this.mWorkSpecDao.getWorkSpec(this.mWorkSpecId);
      if (this.mWorkSpec == null) {
        Logger.get().error(TAG, String.format("Didn't find WorkSpec for id %s", new Object[] { this.mWorkSpecId }), new Throwable[0]);
        resolve(false);
        return;
      } 
      if (this.mWorkSpec.state != WorkInfo.State.ENQUEUED) {
        resolveIncorrectStatus();
        this.mWorkDatabase.setTransactionSuccessful();
        Logger.get().debug(TAG, String.format("%s is not in ENQUEUED state. Nothing more to do.", new Object[] { this.mWorkSpec.workerClassName }), new Throwable[0]);
        return;
      } 
      if (this.mWorkSpec.isPeriodic() || this.mWorkSpec.isBackedOff()) {
        boolean bool;
        long l = System.currentTimeMillis();
        if (Build.VERSION.SDK_INT < 23 && this.mWorkSpec.intervalDuration != this.mWorkSpec.flexDuration && this.mWorkSpec.periodStartTime == 0L) {
          bool = true;
        } else {
          bool = false;
        } 
        if (!bool && l < this.mWorkSpec.calculateNextRunTime()) {
          Logger.get().debug(TAG, String.format("Delaying execution for %s because it is being executed before schedule.", new Object[] { this.mWorkSpec.workerClassName }), new Throwable[0]);
          resolve(true);
          return;
        } 
      } 
      this.mWorkDatabase.setTransactionSuccessful();
      this.mWorkDatabase.endTransaction();
      if (this.mWorkSpec.isPeriodic()) {
        data = this.mWorkSpec.input;
      } else {
        InputMerger inputMerger = InputMerger.fromClassName(this.mWorkSpec.inputMergerClassName);
        if (inputMerger == null) {
          Logger.get().error(TAG, String.format("Could not create Input Merger %s", new Object[] { this.mWorkSpec.inputMergerClassName }), new Throwable[0]);
          return;
        } 
        ArrayList arrayList = new ArrayList();
        arrayList.add(this.mWorkSpec.input);
        arrayList.addAll(this.mWorkSpecDao.getInputsFromPrerequisites(this.mWorkSpecId));
        data = inputMerger.merge(arrayList);
      } 
      WorkerParameters workerParameters = new WorkerParameters(UUID.fromString(this.mWorkSpecId), data, this.mTags, this.mRuntimeExtras, this.mWorkSpec.runAttemptCount, this.mConfiguration.getExecutor(), this.mWorkTaskExecutor, this.mConfiguration.getWorkerFactory());
      if (this.mWorker == null)
        this.mWorker = this.mConfiguration.getWorkerFactory().createWorkerWithDefaultFallback(this.mAppContext, this.mWorkSpec.workerClassName, workerParameters); 
      ListenableWorker listenableWorker = this.mWorker;
      if (listenableWorker == null) {
        Logger.get().error(TAG, String.format("Could not create Worker %s", new Object[] { this.mWorkSpec.workerClassName }), new Throwable[0]);
        return;
      } 
      if (listenableWorker.isUsed()) {
        Logger.get().error(TAG, String.format("Received an already-used Worker %s; WorkerFactory should return new instances", new Object[] { this.mWorkSpec.workerClassName }), new Throwable[0]);
        return;
      } 
      this.mWorker.setUsed();
      if (trySetRunning()) {
        if (tryCheckForInterruptionAndResolve())
          return; 
        settableFuture = SettableFuture.create();
        this.mWorkTaskExecutor.getMainThreadExecutor().execute(new Object(this, settableFuture));
        return;
      } 
      return;
    } finally {
      this.mWorkDatabase.endTransaction();
    } 
  }
  
  private void setSucceededAndResolve() {
    this.mWorkDatabase.beginTransaction();
    try {
      this.mWorkSpecDao.setState(WorkInfo.State.SUCCEEDED, new String[] { this.mWorkSpecId });
      Data data = ((ListenableWorker.Result.Success)this.mResult).getOutputData();
      this.mWorkSpecDao.setOutput(this.mWorkSpecId, data);
      long l = System.currentTimeMillis();
      for (String str : this.mDependencyDao.getDependentWorkIds(this.mWorkSpecId)) {
        if (this.mWorkSpecDao.getState(str) == WorkInfo.State.BLOCKED && this.mDependencyDao.hasCompletedAllPrerequisites(str)) {
          Logger.get().info(TAG, String.format("Setting status to enqueued for %s", new Object[] { str }), new Throwable[0]);
          this.mWorkSpecDao.setState(WorkInfo.State.ENQUEUED, new String[] { str });
          this.mWorkSpecDao.setPeriodStartTime(str, l);
        } 
      } 
      this.mWorkDatabase.setTransactionSuccessful();
      return;
    } finally {
      this.mWorkDatabase.endTransaction();
      resolve(false);
    } 
  }
  
  private boolean tryCheckForInterruptionAndResolve() {
    if (this.mInterrupted) {
      Logger.get().debug(TAG, String.format("Work interrupted for %s", new Object[] { this.mWorkDescription }), new Throwable[0]);
      WorkInfo.State state = this.mWorkSpecDao.getState(this.mWorkSpecId);
      if (state == null) {
        resolve(false);
        return true;
      } 
      resolve(state.isFinished() ^ true);
      return true;
    } 
    return false;
  }
  
  private boolean trySetRunning() {
    this.mWorkDatabase.beginTransaction();
    try {
      state1 = this.mWorkSpecDao.getState(this.mWorkSpecId);
      state2 = WorkInfo.State.ENQUEUED;
      bool1 = true;
    } finally {
      this.mWorkDatabase.endTransaction();
    } 
    boolean bool = false;
    this.mWorkDatabase.setTransactionSuccessful();
    this.mWorkDatabase.endTransaction();
    return bool;
  }
  
  @NonNull
  public ListenableFuture<Boolean> getFuture() { return this.mFuture; }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public void interrupt(boolean paramBoolean) {
    this.mInterrupted = true;
    tryCheckForInterruptionAndResolve();
    ListenableFuture listenableFuture = this.mInnerFuture;
    if (listenableFuture != null)
      listenableFuture.cancel(true); 
    ListenableWorker listenableWorker = this.mWorker;
    if (listenableWorker != null)
      listenableWorker.stop(); 
  }
  
  void onWorkFinished() {
    assertBackgroundExecutorThread();
    boolean bool2 = tryCheckForInterruptionAndResolve();
    boolean bool1 = false;
    boolean bool = false;
    if (!bool2)
      try {
        this.mWorkDatabase.beginTransaction();
        WorkInfo.State state = this.mWorkSpecDao.getState(this.mWorkSpecId);
        if (state == null) {
          resolve(false);
          bool1 = true;
        } else if (state == WorkInfo.State.RUNNING) {
          handleResult(this.mResult);
          bool1 = this.mWorkSpecDao.getState(this.mWorkSpecId).isFinished();
        } else {
          bool1 = bool;
          if (!state.isFinished()) {
            rescheduleAndResolve();
            bool1 = bool;
          } 
        } 
        this.mWorkDatabase.setTransactionSuccessful();
      } finally {
        this.mWorkDatabase.endTransaction();
      }  
    List list = this.mSchedulers;
    if (list != null) {
      if (bool1) {
        Iterator iterator = list.iterator();
        while (iterator.hasNext())
          ((Scheduler)iterator.next()).cancel(this.mWorkSpecId); 
      } 
      Schedulers.schedule(this.mConfiguration, this.mWorkDatabase, this.mSchedulers);
    } 
  }
  
  @WorkerThread
  public void run() {
    this.mTags = this.mWorkTagDao.getTagsForWorkSpecId(this.mWorkSpecId);
    this.mWorkDescription = createWorkDescription(this.mTags);
    runWorker();
  }
  
  @VisibleForTesting
  void setFailedAndResolve() {
    this.mWorkDatabase.beginTransaction();
    try {
      iterativelyFailWorkAndDependents(this.mWorkSpecId);
      Data data = ((ListenableWorker.Result.Failure)this.mResult).getOutputData();
      this.mWorkSpecDao.setOutput(this.mWorkSpecId, data);
      this.mWorkDatabase.setTransactionSuccessful();
      return;
    } finally {
      this.mWorkDatabase.endTransaction();
      resolve(false);
    } 
  }
}

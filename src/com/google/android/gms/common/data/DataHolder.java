package com.google.android.gms.common.data;

import android.database.CharArrayBuffer;
import android.database.Cursor;
import android.database.CursorIndexOutOfBoundsException;
import android.database.CursorWindow;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.Log;
import com.google.android.gms.common.annotation.KeepForSdk;
import com.google.android.gms.common.annotation.KeepName;
import com.google.android.gms.common.internal.Preconditions;
import com.google.android.gms.common.internal.safeparcel.AbstractSafeParcelable;
import com.google.android.gms.common.internal.safeparcel.SafeParcelWriter;
import com.google.android.gms.common.internal.safeparcel.SafeParcelable.Class;
import com.google.android.gms.common.internal.safeparcel.SafeParcelable.Constructor;
import com.google.android.gms.common.internal.safeparcel.SafeParcelable.Field;
import com.google.android.gms.common.internal.safeparcel.SafeParcelable.Param;
import com.google.android.gms.common.internal.safeparcel.SafeParcelable.VersionField;
import com.google.android.gms.common.sqlite.CursorWrapper;
import java.io.Closeable;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@KeepForSdk
@KeepName
@Class(creator = "DataHolderCreator", validate = true)
public final class DataHolder extends AbstractSafeParcelable implements Closeable {
  @KeepForSdk
  public static final Parcelable.Creator<DataHolder> CREATOR = new zac();
  
  private static final Builder zalx = new zab(new String[0], null);
  
  private boolean mClosed = false;
  
  @VersionField(id = 1000)
  private final int zale;
  
  @Field(getter = "getColumns", id = 1)
  private final String[] zalp;
  
  private Bundle zalq;
  
  @Field(getter = "getWindows", id = 2)
  private final CursorWindow[] zalr;
  
  @Field(getter = "getStatusCode", id = 3)
  private final int zals;
  
  @Field(getter = "getMetadata", id = 4)
  private final Bundle zalt;
  
  private int[] zalu;
  
  private int zalv;
  
  private boolean zalw = true;
  
  @Constructor
  DataHolder(@Param(id = 1000) int paramInt1, @Param(id = 1) String[] paramArrayOfString, @Param(id = 2) CursorWindow[] paramArrayOfCursorWindow, @Param(id = 3) int paramInt2, @Param(id = 4) Bundle paramBundle) {
    this.zale = paramInt1;
    this.zalp = paramArrayOfString;
    this.zalr = paramArrayOfCursorWindow;
    this.zals = paramInt2;
    this.zalt = paramBundle;
  }
  
  @KeepForSdk
  public DataHolder(Cursor paramCursor, int paramInt, Bundle paramBundle) { this(new CursorWrapper(paramCursor), paramInt, paramBundle); }
  
  private DataHolder(Builder paramBuilder, int paramInt, Bundle paramBundle) { this(Builder.zaa(paramBuilder), zaa(paramBuilder, -1), paramInt, null); }
  
  private DataHolder(Builder paramBuilder, int paramInt1, Bundle paramBundle, int paramInt2) { this(Builder.zaa(paramBuilder), zaa(paramBuilder, -1), paramInt1, paramBundle); }
  
  private DataHolder(CursorWrapper paramCursorWrapper, int paramInt, Bundle paramBundle) { this(paramCursorWrapper.getColumnNames(), zaa(paramCursorWrapper), paramInt, paramBundle); }
  
  @KeepForSdk
  public DataHolder(String[] paramArrayOfString, CursorWindow[] paramArrayOfCursorWindow, int paramInt, Bundle paramBundle) {
    this.zale = 1;
    this.zalp = (String[])Preconditions.checkNotNull(paramArrayOfString);
    this.zalr = (CursorWindow[])Preconditions.checkNotNull(paramArrayOfCursorWindow);
    this.zals = paramInt;
    this.zalt = paramBundle;
    zaca();
  }
  
  @KeepForSdk
  public static Builder builder(String[] paramArrayOfString) { return new Builder(paramArrayOfString, null, null); }
  
  @KeepForSdk
  public static DataHolder empty(int paramInt) { return new DataHolder(zalx, paramInt, null); }
  
  private final void zaa(String paramString, int paramInt) {
    Bundle bundle = this.zalq;
    if (bundle == null || !bundle.containsKey(paramString)) {
      paramString = String.valueOf(paramString);
      if (paramString.length() != 0) {
        paramString = "No such column: ".concat(paramString);
      } else {
        paramString = new String("No such column: ");
      } 
      throw new IllegalArgumentException(paramString);
    } 
    if (!isClosed()) {
      if (paramInt >= 0 && paramInt < this.zalv)
        return; 
      throw new CursorIndexOutOfBoundsException(paramInt, this.zalv);
    } 
    throw new IllegalArgumentException("Buffer is closed.");
  }
  
  private static CursorWindow[] zaa(Builder paramBuilder, int paramInt) {
    List list;
    int i = Builder.zaa(paramBuilder).length;
    int j = 0;
    if (i == 0)
      return new CursorWindow[0]; 
    if (paramInt < 0 || paramInt >= Builder.zab(paramBuilder).size()) {
      list = Builder.zab(paramBuilder);
    } else {
      list = Builder.zab(paramBuilder).subList(0, paramInt);
    } 
    int k = list.size();
    CursorWindow cursorWindow = new CursorWindow(false);
    ArrayList arrayList = new ArrayList();
    arrayList.add(cursorWindow);
    cursorWindow.setNumColumns(Builder.zaa(paramBuilder).length);
    paramInt = 0;
    i = 0;
    label71: while (true) {
      if (paramInt < k)
        try {
          CursorWindow cursorWindow1;
          boolean bool = cursorWindow.allocRow();
          if (!bool) {
            StringBuilder stringBuilder = new StringBuilder(72);
            stringBuilder.append("Allocating additional cursor window for large data set (row ");
            stringBuilder.append(paramInt);
            stringBuilder.append(")");
            Log.d("DataHolder", stringBuilder.toString());
            CursorWindow cursorWindow2 = new CursorWindow(false);
            cursorWindow2.setStartPosition(paramInt);
            cursorWindow2.setNumColumns(Builder.zaa(paramBuilder).length);
            arrayList.add(cursorWindow2);
            cursorWindow1 = cursorWindow2;
            if (!cursorWindow2.allocRow()) {
              Log.e("DataHolder", "Unable to allocate row to hold data.");
              arrayList.remove(cursorWindow2);
              return (CursorWindow[])arrayList.toArray(new CursorWindow[arrayList.size()]);
            } 
          } 
          Map map = (Map)list.get(paramInt);
          byte b = 0;
          bool = true;
          while (true) {
            StringBuilder stringBuilder;
            String str;
            if (b < Builder.zaa(paramBuilder).length && bool) {
              String str1 = Builder.zaa(paramBuilder)[b];
              Object object = map.get(str1);
              if (object == null) {
                bool = cursorWindow1.putNull(paramInt, b);
              } else if (object instanceof String) {
                bool = cursorWindow1.putString((String)object, paramInt, b);
              } else if (object instanceof Long) {
                bool = cursorWindow1.putLong(((Long)object).longValue(), paramInt, b);
              } else if (object instanceof Integer) {
                bool = cursorWindow1.putLong(((Integer)object).intValue(), paramInt, b);
              } else if (object instanceof Boolean) {
                long l;
                if (((Boolean)object).booleanValue()) {
                  l = 1L;
                } else {
                  l = 0L;
                } 
                bool = cursorWindow1.putLong(l, paramInt, b);
              } else if (object instanceof byte[]) {
                bool = cursorWindow1.putBlob((byte[])object, paramInt, b);
              } else if (object instanceof Double) {
                bool = cursorWindow1.putDouble(((Double)object).doubleValue(), paramInt, b);
              } else if (object instanceof Float) {
                bool = cursorWindow1.putDouble(((Float)object).floatValue(), paramInt, b);
              } else {
                stringBuilder = new StringBuilder((str = String.valueOf(object)).valueOf(str1).length() + 32 + String.valueOf(str).length());
                stringBuilder.append("Unsupported object for column ");
                stringBuilder.append(str1);
                stringBuilder.append(": ");
                stringBuilder.append(str);
                throw new IllegalArgumentException(stringBuilder.toString());
              } 
            } else {
              if (!bool) {
                if (i == 0) {
                  StringBuilder stringBuilder1 = new StringBuilder(74);
                  stringBuilder1.append("Couldn't populate window data for row ");
                  stringBuilder1.append(paramInt);
                  stringBuilder1.append(" - allocating new window.");
                  Log.d("DataHolder", stringBuilder1.toString());
                  stringBuilder.freeLastRow();
                  CursorWindow cursorWindow2 = new CursorWindow(false);
                  cursorWindow2.setStartPosition(paramInt);
                  cursorWindow2.setNumColumns(Builder.zaa(str).length);
                  arrayList.add(cursorWindow2);
                  paramInt--;
                  i = 1;
                } else {
                  throw new zaa("Could not add the value to a new CursorWindow. The size of value may be larger than what a CursorWindow can handle.");
                } 
              } else {
                i = 0;
              } 
              paramInt++;
              continue label71;
            } 
            b++;
          } 
          break;
        } catch (RuntimeException paramBuilder) {
          i = arrayList.size();
          for (paramInt = j; paramInt < i; paramInt++)
            ((CursorWindow)arrayList.get(paramInt)).close(); 
          throw paramBuilder;
        }  
      return (CursorWindow[])arrayList.toArray(new CursorWindow[arrayList.size()]);
    } 
  }
  
  private static CursorWindow[] zaa(CursorWrapper paramCursorWrapper) {
    arrayList = new ArrayList();
    try {
      int i;
      int j = paramCursorWrapper.getCount();
      CursorWindow cursorWindow = paramCursorWrapper.getWindow();
      if (cursorWindow != null && cursorWindow.getStartPosition() == 0) {
        cursorWindow.acquireReference();
        paramCursorWrapper.setWindow(null);
        arrayList.add(cursorWindow);
        i = cursorWindow.getNumRows();
      } else {
        i = 0;
      } 
      while (i < j && paramCursorWrapper.moveToPosition(i)) {
        cursorWindow = paramCursorWrapper.getWindow();
        if (cursorWindow != null) {
          cursorWindow.acquireReference();
          paramCursorWrapper.setWindow(null);
        } else {
          cursorWindow = new CursorWindow(false);
          cursorWindow.setStartPosition(i);
          paramCursorWrapper.fillWindow(i, cursorWindow);
        } 
        if (cursorWindow.getNumRows() != 0) {
          arrayList.add(cursorWindow);
          i = cursorWindow.getStartPosition();
          int k = cursorWindow.getNumRows();
          i += k;
        } 
      } 
      return (CursorWindow[])arrayList.toArray(new CursorWindow[arrayList.size()]);
    } finally {
      paramCursorWrapper.close();
    } 
  }
  
  @KeepForSdk
  public final void close() { // Byte code:
    //   0: aload_0
    //   1: monitorenter
    //   2: aload_0
    //   3: getfield mClosed : Z
    //   6: ifne -> 41
    //   9: aload_0
    //   10: iconst_1
    //   11: putfield mClosed : Z
    //   14: iconst_0
    //   15: istore_1
    //   16: iload_1
    //   17: aload_0
    //   18: getfield zalr : [Landroid/database/CursorWindow;
    //   21: arraylength
    //   22: if_icmpge -> 41
    //   25: aload_0
    //   26: getfield zalr : [Landroid/database/CursorWindow;
    //   29: iload_1
    //   30: aaload
    //   31: invokevirtual close : ()V
    //   34: iload_1
    //   35: iconst_1
    //   36: iadd
    //   37: istore_1
    //   38: goto -> 16
    //   41: aload_0
    //   42: monitorexit
    //   43: return
    //   44: astore_2
    //   45: aload_0
    //   46: monitorexit
    //   47: goto -> 52
    //   50: aload_2
    //   51: athrow
    //   52: goto -> 50
    // Exception table:
    //   from	to	target	type
    //   2	14	44	finally
    //   16	34	44	finally
    //   41	43	44	finally
    //   45	47	44	finally }
  
  protected final void finalize() {
    try {
      if (this.zalw && this.zalr.length > 0 && !isClosed()) {
        close();
        String str;
        StringBuilder stringBuilder = new StringBuilder((str = toString()).valueOf(str).length() + 178);
        stringBuilder.append("Internal data leak within a DataBuffer object detected!  Be sure to explicitly call release() on all DataBuffer extending objects when you are done with them. (internal object: ");
        stringBuilder.append(str);
        stringBuilder.append(")");
        Log.e("DataBuffer", stringBuilder.toString());
      } 
      return;
    } finally {
      super.finalize();
    } 
  }
  
  @KeepForSdk
  public final boolean getBoolean(String paramString, int paramInt1, int paramInt2) {
    zaa(paramString, paramInt1);
    return (Long.valueOf(this.zalr[paramInt2].getLong(paramInt1, this.zalq.getInt(paramString))).longValue() == 1L);
  }
  
  @KeepForSdk
  public final byte[] getByteArray(String paramString, int paramInt1, int paramInt2) {
    zaa(paramString, paramInt1);
    return this.zalr[paramInt2].getBlob(paramInt1, this.zalq.getInt(paramString));
  }
  
  @KeepForSdk
  public final int getCount() { return this.zalv; }
  
  @KeepForSdk
  public final int getInteger(String paramString, int paramInt1, int paramInt2) {
    zaa(paramString, paramInt1);
    return this.zalr[paramInt2].getInt(paramInt1, this.zalq.getInt(paramString));
  }
  
  @KeepForSdk
  public final long getLong(String paramString, int paramInt1, int paramInt2) {
    zaa(paramString, paramInt1);
    return this.zalr[paramInt2].getLong(paramInt1, this.zalq.getInt(paramString));
  }
  
  @KeepForSdk
  public final Bundle getMetadata() { return this.zalt; }
  
  @KeepForSdk
  public final int getStatusCode() { return this.zals; }
  
  @KeepForSdk
  public final String getString(String paramString, int paramInt1, int paramInt2) {
    zaa(paramString, paramInt1);
    return this.zalr[paramInt2].getString(paramInt1, this.zalq.getInt(paramString));
  }
  
  @KeepForSdk
  public final int getWindowIndex(int paramInt) {
    boolean bool;
    int i;
    byte b = 0;
    if (paramInt >= 0 && paramInt < this.zalv) {
      bool = true;
    } else {
      bool = false;
    } 
    Preconditions.checkState(bool);
    while (true) {
      int[] arrayOfInt = this.zalu;
      i = b;
      if (b < arrayOfInt.length) {
        if (paramInt < arrayOfInt[b]) {
          i = b - true;
          break;
        } 
        b++;
        continue;
      } 
      break;
    } 
    paramInt = i;
    if (i == this.zalu.length)
      paramInt = i - 1; 
    return paramInt;
  }
  
  @KeepForSdk
  public final boolean hasColumn(String paramString) { return this.zalq.containsKey(paramString); }
  
  @KeepForSdk
  public final boolean hasNull(String paramString, int paramInt1, int paramInt2) {
    zaa(paramString, paramInt1);
    return this.zalr[paramInt2].isNull(paramInt1, this.zalq.getInt(paramString));
  }
  
  @KeepForSdk
  public final boolean isClosed() { // Byte code:
    //   0: aload_0
    //   1: monitorenter
    //   2: aload_0
    //   3: getfield mClosed : Z
    //   6: istore_1
    //   7: aload_0
    //   8: monitorexit
    //   9: iload_1
    //   10: ireturn
    //   11: astore_2
    //   12: aload_0
    //   13: monitorexit
    //   14: aload_2
    //   15: athrow
    // Exception table:
    //   from	to	target	type
    //   2	9	11	finally
    //   12	14	11	finally }
  
  public final void writeToParcel(Parcel paramParcel, int paramInt) {
    int i = SafeParcelWriter.beginObjectHeader(paramParcel);
    SafeParcelWriter.writeStringArray(paramParcel, 1, this.zalp, false);
    SafeParcelWriter.writeTypedArray(paramParcel, 2, this.zalr, paramInt, false);
    SafeParcelWriter.writeInt(paramParcel, 3, getStatusCode());
    SafeParcelWriter.writeBundle(paramParcel, 4, getMetadata(), false);
    SafeParcelWriter.writeInt(paramParcel, 1000, this.zale);
    SafeParcelWriter.finishObjectHeader(paramParcel, i);
    if ((paramInt & true) != 0)
      close(); 
  }
  
  public final float zaa(String paramString, int paramInt1, int paramInt2) {
    zaa(paramString, paramInt1);
    return this.zalr[paramInt2].getFloat(paramInt1, this.zalq.getInt(paramString));
  }
  
  public final void zaa(String paramString, int paramInt1, int paramInt2, CharArrayBuffer paramCharArrayBuffer) {
    zaa(paramString, paramInt1);
    this.zalr[paramInt2].copyStringToBuffer(paramInt1, this.zalq.getInt(paramString), paramCharArrayBuffer);
  }
  
  public final double zab(String paramString, int paramInt1, int paramInt2) {
    zaa(paramString, paramInt1);
    return this.zalr[paramInt2].getDouble(paramInt1, this.zalq.getInt(paramString));
  }
  
  public final void zaca() {
    this.zalq = new Bundle();
    int j = 0;
    byte b = 0;
    while (true) {
      String[] arrayOfString = this.zalp;
      if (b < arrayOfString.length) {
        this.zalq.putInt(arrayOfString[b], b);
        b++;
        continue;
      } 
      break;
    } 
    this.zalu = new int[this.zalr.length];
    int i = 0;
    b = j;
    while (true) {
      CursorWindow[] arrayOfCursorWindow = this.zalr;
      if (b < arrayOfCursorWindow.length) {
        this.zalu[b] = i;
        j = arrayOfCursorWindow[b].getStartPosition();
        i += this.zalr[b].getNumRows() - i - j;
        b++;
        continue;
      } 
      break;
    } 
    this.zalv = i;
  }
}

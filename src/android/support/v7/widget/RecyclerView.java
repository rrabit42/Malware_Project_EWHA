package android.support.v7.widget;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.StateListDrawable;
import android.os.Build;
import android.os.Parcelable;
import android.os.SystemClock;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.Px;
import android.support.annotation.VisibleForTesting;
import android.support.v4.os.TraceCompat;
import android.support.v4.util.Preconditions;
import android.support.v4.view.MotionEventCompat;
import android.support.v4.view.NestedScrollingChild2;
import android.support.v4.view.NestedScrollingChildHelper;
import android.support.v4.view.ScrollingView;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.ViewConfigurationCompat;
import android.support.v4.view.accessibility.AccessibilityEventCompat;
import android.support.v7.recyclerview.R;
import android.util.AttributeSet;
import android.util.Log;
import android.util.SparseArray;
import android.view.FocusFinder;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewGroup;
import android.view.ViewParent;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.animation.Interpolator;
import android.widget.EdgeEffect;
import android.widget.OverScroller;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;

public class RecyclerView extends ViewGroup implements ScrollingView, NestedScrollingChild2 {
  static final boolean ALLOW_SIZE_IN_UNSPECIFIED_SPEC;
  
  static final boolean ALLOW_THREAD_GAP_WORK;
  
  private static final int[] CLIP_TO_PADDING_ATTR;
  
  static final boolean DEBUG = false;
  
  static final int DEFAULT_ORIENTATION = 1;
  
  static final boolean DISPATCH_TEMP_DETACH = false;
  
  private static final boolean FORCE_ABS_FOCUS_SEARCH_DIRECTION;
  
  static final boolean FORCE_INVALIDATE_DISPLAY_LIST;
  
  static final long FOREVER_NS = 9223372036854775807L;
  
  public static final int HORIZONTAL = 0;
  
  private static final boolean IGNORE_DETACHED_FOCUSED_CHILD;
  
  private static final int INVALID_POINTER = -1;
  
  public static final int INVALID_TYPE = -1;
  
  private static final Class<?>[] LAYOUT_MANAGER_CONSTRUCTOR_SIGNATURE;
  
  static final int MAX_SCROLL_DURATION = 2000;
  
  private static final int[] NESTED_SCROLLING_ATTRS;
  
  public static final long NO_ID = -1L;
  
  public static final int NO_POSITION = -1;
  
  static final boolean POST_UPDATES_ON_ANIMATION;
  
  public static final int SCROLL_STATE_DRAGGING = 1;
  
  public static final int SCROLL_STATE_IDLE = 0;
  
  public static final int SCROLL_STATE_SETTLING = 2;
  
  static final String TAG = "RecyclerView";
  
  public static final int TOUCH_SLOP_DEFAULT = 0;
  
  public static final int TOUCH_SLOP_PAGING = 1;
  
  static final String TRACE_BIND_VIEW_TAG = "RV OnBindView";
  
  static final String TRACE_CREATE_VIEW_TAG = "RV CreateView";
  
  private static final String TRACE_HANDLE_ADAPTER_UPDATES_TAG = "RV PartialInvalidate";
  
  static final String TRACE_NESTED_PREFETCH_TAG = "RV Nested Prefetch";
  
  private static final String TRACE_ON_DATA_SET_CHANGE_LAYOUT_TAG = "RV FullInvalidate";
  
  private static final String TRACE_ON_LAYOUT_TAG = "RV OnLayout";
  
  static final String TRACE_PREFETCH_TAG = "RV Prefetch";
  
  static final String TRACE_SCROLL_TAG = "RV Scroll";
  
  static final boolean VERBOSE_TRACING = false;
  
  public static final int VERTICAL = 1;
  
  static final Interpolator sQuinticInterpolator;
  
  RecyclerViewAccessibilityDelegate mAccessibilityDelegate;
  
  private final AccessibilityManager mAccessibilityManager;
  
  private OnItemTouchListener mActiveOnItemTouchListener;
  
  Adapter mAdapter;
  
  AdapterHelper mAdapterHelper;
  
  boolean mAdapterUpdateDuringMeasure;
  
  private EdgeEffect mBottomGlow;
  
  private ChildDrawingOrderCallback mChildDrawingOrderCallback;
  
  ChildHelper mChildHelper;
  
  boolean mClipToPadding;
  
  boolean mDataSetHasChangedAfterLayout = false;
  
  boolean mDispatchItemsChangedEvent = false;
  
  private int mDispatchScrollCounter = 0;
  
  private int mEatenAccessibilityChangeFlags;
  
  @NonNull
  private EdgeEffectFactory mEdgeEffectFactory = new EdgeEffectFactory();
  
  boolean mEnableFastScroller;
  
  @VisibleForTesting
  boolean mFirstLayoutComplete;
  
  GapWorker mGapWorker;
  
  boolean mHasFixedSize;
  
  private boolean mIgnoreMotionEventTillDown;
  
  private int mInitialTouchX;
  
  private int mInitialTouchY;
  
  private int mInterceptRequestLayoutDepth = 0;
  
  boolean mIsAttached;
  
  ItemAnimator mItemAnimator = new DefaultItemAnimator();
  
  private ItemAnimator.ItemAnimatorListener mItemAnimatorListener;
  
  private Runnable mItemAnimatorRunner;
  
  final ArrayList<ItemDecoration> mItemDecorations = new ArrayList();
  
  boolean mItemsAddedOrRemoved;
  
  boolean mItemsChanged;
  
  private int mLastTouchX;
  
  private int mLastTouchY;
  
  @VisibleForTesting
  LayoutManager mLayout;
  
  boolean mLayoutFrozen;
  
  private int mLayoutOrScrollCounter = 0;
  
  boolean mLayoutWasDefered;
  
  private EdgeEffect mLeftGlow;
  
  private final int mMaxFlingVelocity;
  
  private final int mMinFlingVelocity;
  
  private final int[] mMinMaxLayoutPositions;
  
  private final int[] mNestedOffsets;
  
  private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver(this);
  
  private List<OnChildAttachStateChangeListener> mOnChildAttachStateListeners;
  
  private OnFlingListener mOnFlingListener;
  
  private final ArrayList<OnItemTouchListener> mOnItemTouchListeners = new ArrayList();
  
  @VisibleForTesting
  final List<ViewHolder> mPendingAccessibilityImportanceChange;
  
  private SavedState mPendingSavedState;
  
  boolean mPostedAnimatorRunner;
  
  GapWorker.LayoutPrefetchRegistryImpl mPrefetchRegistry;
  
  private boolean mPreserveFocusAfterLayout;
  
  final Recycler mRecycler = new Recycler(this);
  
  RecyclerListener mRecyclerListener;
  
  private EdgeEffect mRightGlow;
  
  private float mScaledHorizontalScrollFactor = Float.MIN_VALUE;
  
  private float mScaledVerticalScrollFactor = Float.MIN_VALUE;
  
  final int[] mScrollConsumed;
  
  private OnScrollListener mScrollListener;
  
  private List<OnScrollListener> mScrollListeners;
  
  private final int[] mScrollOffset;
  
  private int mScrollPointerId = -1;
  
  private int mScrollState = 0;
  
  final int[] mScrollStepConsumed;
  
  private NestedScrollingChildHelper mScrollingChildHelper;
  
  final State mState;
  
  final Rect mTempRect = new Rect();
  
  private final Rect mTempRect2 = new Rect();
  
  final RectF mTempRectF = new RectF();
  
  private EdgeEffect mTopGlow;
  
  private int mTouchSlop;
  
  final Runnable mUpdateChildViewsRunnable = new Object(this);
  
  private VelocityTracker mVelocityTracker;
  
  final ViewFlinger mViewFlinger;
  
  private final ViewInfoStore.ProcessCallback mViewInfoProcessCallback;
  
  final ViewInfoStore mViewInfoStore = new ViewInfoStore();
  
  static  {
    boolean bool;
    NESTED_SCROLLING_ATTRS = new int[] { 16843830 };
    CLIP_TO_PADDING_ATTR = new int[] { 16842987 };
    if (Build.VERSION.SDK_INT == 18 || Build.VERSION.SDK_INT == 19 || Build.VERSION.SDK_INT == 20) {
      bool = true;
    } else {
      bool = false;
    } 
    FORCE_INVALIDATE_DISPLAY_LIST = bool;
    if (Build.VERSION.SDK_INT >= 23) {
      bool = true;
    } else {
      bool = false;
    } 
    ALLOW_SIZE_IN_UNSPECIFIED_SPEC = bool;
    if (Build.VERSION.SDK_INT >= 16) {
      bool = true;
    } else {
      bool = false;
    } 
    POST_UPDATES_ON_ANIMATION = bool;
    if (Build.VERSION.SDK_INT >= 21) {
      bool = true;
    } else {
      bool = false;
    } 
    ALLOW_THREAD_GAP_WORK = bool;
    if (Build.VERSION.SDK_INT <= 15) {
      bool = true;
    } else {
      bool = false;
    } 
    FORCE_ABS_FOCUS_SEARCH_DIRECTION = bool;
    if (Build.VERSION.SDK_INT <= 15) {
      bool = true;
    } else {
      bool = false;
    } 
    IGNORE_DETACHED_FOCUSED_CHILD = bool;
    LAYOUT_MANAGER_CONSTRUCTOR_SIGNATURE = new Class[] { Context.class, AttributeSet.class, int.class, int.class };
    sQuinticInterpolator = new Object();
  }
  
  public RecyclerView(@NonNull Context paramContext) { this(paramContext, null); }
  
  public RecyclerView(@NonNull Context paramContext, @Nullable AttributeSet paramAttributeSet) { this(paramContext, paramAttributeSet, 0); }
  
  public RecyclerView(@NonNull Context paramContext, @Nullable AttributeSet paramAttributeSet, int paramInt) {
    super(paramContext, paramAttributeSet, paramInt);
    boolean bool1 = true;
    this.mPreserveFocusAfterLayout = true;
    this.mViewFlinger = new ViewFlinger(this);
    if (ALLOW_THREAD_GAP_WORK) {
      typedArray = new GapWorker.LayoutPrefetchRegistryImpl();
    } else {
      typedArray = null;
    } 
    this.mPrefetchRegistry = typedArray;
    this.mState = new State();
    this.mItemsAddedOrRemoved = false;
    this.mItemsChanged = false;
    this.mItemAnimatorListener = new ItemAnimatorRestoreListener(this);
    this.mPostedAnimatorRunner = false;
    this.mMinMaxLayoutPositions = new int[2];
    this.mScrollOffset = new int[2];
    this.mScrollConsumed = new int[2];
    this.mNestedOffsets = new int[2];
    this.mScrollStepConsumed = new int[2];
    this.mPendingAccessibilityImportanceChange = new ArrayList();
    this.mItemAnimatorRunner = new Object(this);
    this.mViewInfoProcessCallback = new Object(this);
    if (paramAttributeSet != null) {
      typedArray = paramContext.obtainStyledAttributes(paramAttributeSet, CLIP_TO_PADDING_ATTR, paramInt, 0);
      this.mClipToPadding = typedArray.getBoolean(0, true);
      typedArray.recycle();
    } else {
      this.mClipToPadding = true;
    } 
    setScrollContainer(true);
    setFocusableInTouchMode(true);
    ViewConfiguration viewConfiguration = ViewConfiguration.get(paramContext);
    this.mTouchSlop = viewConfiguration.getScaledTouchSlop();
    this.mScaledHorizontalScrollFactor = ViewConfigurationCompat.getScaledHorizontalScrollFactor(viewConfiguration, paramContext);
    this.mScaledVerticalScrollFactor = ViewConfigurationCompat.getScaledVerticalScrollFactor(viewConfiguration, paramContext);
    this.mMinFlingVelocity = viewConfiguration.getScaledMinimumFlingVelocity();
    this.mMaxFlingVelocity = viewConfiguration.getScaledMaximumFlingVelocity();
    if (getOverScrollMode() == 2) {
      bool = true;
    } else {
      bool = false;
    } 
    setWillNotDraw(bool);
    this.mItemAnimator.setListener(this.mItemAnimatorListener);
    initAdapterManager();
    initChildrenHelper();
    initAutofill();
    if (ViewCompat.getImportantForAccessibility(this) == 0)
      ViewCompat.setImportantForAccessibility(this, 1); 
    this.mAccessibilityManager = (AccessibilityManager)getContext().getSystemService("accessibility");
    setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));
    if (paramAttributeSet != null) {
      TypedArray typedArray1 = paramContext.obtainStyledAttributes(paramAttributeSet, R.styleable.RecyclerView, paramInt, 0);
      String str = typedArray1.getString(R.styleable.RecyclerView_layoutManager);
      if (typedArray1.getInt(R.styleable.RecyclerView_android_descendantFocusability, -1) == -1)
        setDescendantFocusability(262144); 
      this.mEnableFastScroller = typedArray1.getBoolean(R.styleable.RecyclerView_fastScrollEnabled, false);
      if (this.mEnableFastScroller)
        initFastScroller((StateListDrawable)typedArray1.getDrawable(R.styleable.RecyclerView_fastScrollVerticalThumbDrawable), typedArray1.getDrawable(R.styleable.RecyclerView_fastScrollVerticalTrackDrawable), (StateListDrawable)typedArray1.getDrawable(R.styleable.RecyclerView_fastScrollHorizontalThumbDrawable), typedArray1.getDrawable(R.styleable.RecyclerView_fastScrollHorizontalTrackDrawable)); 
      typedArray1.recycle();
      createLayoutManager(paramContext, str, paramAttributeSet, paramInt, 0);
      bool = bool1;
      if (Build.VERSION.SDK_INT >= 21) {
        TypedArray typedArray2 = paramContext.obtainStyledAttributes(paramAttributeSet, NESTED_SCROLLING_ATTRS, paramInt, 0);
        bool = typedArray2.getBoolean(0, true);
        typedArray2.recycle();
      } 
    } else {
      setDescendantFocusability(262144);
      bool = bool1;
    } 
    setNestedScrollingEnabled(bool);
  }
  
  private void addAnimatingView(ViewHolder paramViewHolder) {
    boolean bool;
    View view = paramViewHolder.itemView;
    if (view.getParent() == this) {
      bool = true;
    } else {
      bool = false;
    } 
    this.mRecycler.unscrapView(getChildViewHolder(view));
    if (paramViewHolder.isTmpDetached()) {
      this.mChildHelper.attachViewToParent(view, -1, view.getLayoutParams(), true);
      return;
    } 
    if (!bool) {
      this.mChildHelper.addView(view, true);
      return;
    } 
    this.mChildHelper.hide(view);
  }
  
  private void animateChange(@NonNull ViewHolder paramViewHolder1, @NonNull ViewHolder paramViewHolder2, @NonNull ItemAnimator.ItemHolderInfo paramItemHolderInfo1, @NonNull ItemAnimator.ItemHolderInfo paramItemHolderInfo2, boolean paramBoolean1, boolean paramBoolean2) {
    paramViewHolder1.setIsRecyclable(false);
    if (paramBoolean1)
      addAnimatingView(paramViewHolder1); 
    if (paramViewHolder1 != paramViewHolder2) {
      if (paramBoolean2)
        addAnimatingView(paramViewHolder2); 
      paramViewHolder1.mShadowedHolder = paramViewHolder2;
      addAnimatingView(paramViewHolder1);
      this.mRecycler.unscrapView(paramViewHolder1);
      paramViewHolder2.setIsRecyclable(false);
      paramViewHolder2.mShadowingHolder = paramViewHolder1;
    } 
    if (this.mItemAnimator.animateChange(paramViewHolder1, paramViewHolder2, paramItemHolderInfo1, paramItemHolderInfo2))
      postAnimationRunner(); 
  }
  
  private void cancelTouch() {
    resetTouch();
    setScrollState(0);
  }
  
  static void clearNestedRecyclerViewIfNotNested(@NonNull ViewHolder paramViewHolder) {
    if (paramViewHolder.mNestedRecyclerView != null) {
      View view = (View)paramViewHolder.mNestedRecyclerView.get();
      while (view != null) {
        if (view == paramViewHolder.itemView)
          return; 
        ViewParent viewParent = view.getParent();
        if (viewParent instanceof View) {
          View view1 = (View)viewParent;
          continue;
        } 
        viewParent = null;
      } 
      paramViewHolder.mNestedRecyclerView = null;
    } 
  }
  
  private void createLayoutManager(Context paramContext, String paramString, AttributeSet paramAttributeSet, int paramInt1, int paramInt2) {
    if (paramString != null) {
      paramString = paramString.trim();
      if (!paramString.isEmpty()) {
        String str = getFullClassName(paramContext, paramString);
        try {
          StringBuilder stringBuilder;
          if (isInEditMode()) {
            classLoader = getClass().getClassLoader();
          } else {
            classLoader = paramContext.getClassLoader();
          } 
          Class clazz = classLoader.loadClass(str).asSubclass(LayoutManager.class);
          Context context = null;
          try {
            Constructor constructor = clazz.getConstructor(LAYOUT_MANAGER_CONSTRUCTOR_SIGNATURE);
            stringBuilder = new Object[] { paramContext, paramAttributeSet, Integer.valueOf(paramInt1), Integer.valueOf(paramInt2) };
          } catch (NoSuchMethodException paramContext) {
            try {
              Constructor constructor = clazz.getConstructor(new Class[0]);
              paramContext = context;
              constructor.setAccessible(true);
              setLayoutManager((LayoutManager)constructor.newInstance(paramContext));
              return;
            } catch (NoSuchMethodException classLoader) {
              classLoader.initCause(paramContext);
              stringBuilder = new StringBuilder();
              stringBuilder.append(paramAttributeSet.getPositionDescription());
              stringBuilder.append(": Error creating LayoutManager ");
              stringBuilder.append(str);
              throw new IllegalStateException(stringBuilder.toString(), classLoader);
            } 
          } 
          classLoader.setAccessible(true);
          setLayoutManager((LayoutManager)classLoader.newInstance(stringBuilder));
          return;
        } catch (ClassNotFoundException paramContext) {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.append(paramAttributeSet.getPositionDescription());
          stringBuilder.append(": Unable to find LayoutManager ");
          stringBuilder.append(str);
          throw new IllegalStateException(stringBuilder.toString(), paramContext);
        } catch (InvocationTargetException paramContext) {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.append(paramAttributeSet.getPositionDescription());
          stringBuilder.append(": Could not instantiate the LayoutManager: ");
          stringBuilder.append(str);
          throw new IllegalStateException(stringBuilder.toString(), paramContext);
        } catch (InstantiationException paramContext) {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.append(paramAttributeSet.getPositionDescription());
          stringBuilder.append(": Could not instantiate the LayoutManager: ");
          stringBuilder.append(str);
          throw new IllegalStateException(stringBuilder.toString(), paramContext);
        } catch (IllegalAccessException paramContext) {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.append(paramAttributeSet.getPositionDescription());
          stringBuilder.append(": Cannot access non-public constructor ");
          stringBuilder.append(str);
          throw new IllegalStateException(stringBuilder.toString(), paramContext);
        } catch (ClassCastException paramContext) {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.append(paramAttributeSet.getPositionDescription());
          stringBuilder.append(": Class is not a LayoutManager ");
          stringBuilder.append(str);
          throw new IllegalStateException(stringBuilder.toString(), paramContext);
        } 
      } 
    } 
  }
  
  private boolean didChildRangeChange(int paramInt1, int paramInt2) {
    findMinMaxChildLayoutPositions(this.mMinMaxLayoutPositions);
    int[] arrayOfInt = this.mMinMaxLayoutPositions;
    boolean bool = false;
    if (arrayOfInt[0] != paramInt1 || arrayOfInt[1] != paramInt2)
      bool = true; 
    return bool;
  }
  
  private void dispatchContentChangedIfNecessary() {
    int i = this.mEatenAccessibilityChangeFlags;
    this.mEatenAccessibilityChangeFlags = 0;
    if (i != 0 && isAccessibilityEnabled()) {
      AccessibilityEvent accessibilityEvent = AccessibilityEvent.obtain();
      accessibilityEvent.setEventType(2048);
      AccessibilityEventCompat.setContentChangeTypes(accessibilityEvent, i);
      sendAccessibilityEventUnchecked(accessibilityEvent);
    } 
  }
  
  private void dispatchLayoutStep1() {
    State state = this.mState;
    boolean bool = true;
    state.assertLayoutStep(1);
    fillRemainingScrollValues(this.mState);
    this.mState.mIsMeasuring = false;
    startInterceptRequestLayout();
    this.mViewInfoStore.clear();
    onEnterLayoutOrScroll();
    processAdapterUpdatesAndSetAnimationFlags();
    saveFocusInfo();
    state = this.mState;
    if (!state.mRunSimpleAnimations || !this.mItemsChanged)
      bool = false; 
    state.mTrackOldChangeHolders = bool;
    this.mItemsChanged = false;
    this.mItemsAddedOrRemoved = false;
    state = this.mState;
    state.mInPreLayout = state.mRunPredictiveAnimations;
    this.mState.mItemCount = this.mAdapter.getItemCount();
    findMinMaxChildLayoutPositions(this.mMinMaxLayoutPositions);
    if (this.mState.mRunSimpleAnimations) {
      int i = this.mChildHelper.getChildCount();
      for (byte b = 0; b < i; b++) {
        ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getChildAt(b));
        if (!viewHolder.shouldIgnore() && (!viewHolder.isInvalid() || this.mAdapter.hasStableIds())) {
          ItemAnimator.ItemHolderInfo itemHolderInfo = this.mItemAnimator.recordPreLayoutInformation(this.mState, viewHolder, ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder), viewHolder.getUnmodifiedPayloads());
          this.mViewInfoStore.addToPreLayout(viewHolder, itemHolderInfo);
          if (this.mState.mTrackOldChangeHolders && viewHolder.isUpdated() && !viewHolder.isRemoved() && !viewHolder.shouldIgnore() && !viewHolder.isInvalid()) {
            long l = getChangedHolderKey(viewHolder);
            this.mViewInfoStore.addToOldChangeHolders(l, viewHolder);
          } 
        } 
      } 
    } 
    if (this.mState.mRunPredictiveAnimations) {
      saveOldPositions();
      bool = this.mState.mStructureChanged;
      state = this.mState;
      state.mStructureChanged = false;
      this.mLayout.onLayoutChildren(this.mRecycler, state);
      this.mState.mStructureChanged = bool;
      for (byte b = 0; b < this.mChildHelper.getChildCount(); b++) {
        ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getChildAt(b));
        if (!viewHolder.shouldIgnore() && !this.mViewInfoStore.isInPreLayout(viewHolder)) {
          int j = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);
          bool = viewHolder.hasAnyOfTheFlags(8192);
          int i = j;
          if (!bool)
            i = j | 0x1000; 
          ItemAnimator.ItemHolderInfo itemHolderInfo = this.mItemAnimator.recordPreLayoutInformation(this.mState, viewHolder, i, viewHolder.getUnmodifiedPayloads());
          if (bool) {
            recordAnimationInfoIfBouncedHiddenView(viewHolder, itemHolderInfo);
          } else {
            this.mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, itemHolderInfo);
          } 
        } 
      } 
      clearOldPositions();
    } else {
      clearOldPositions();
    } 
    onExitLayoutOrScroll();
    stopInterceptRequestLayout(false);
    this.mState.mLayoutStep = 2;
  }
  
  private void dispatchLayoutStep2() {
    boolean bool;
    startInterceptRequestLayout();
    onEnterLayoutOrScroll();
    this.mState.assertLayoutStep(6);
    this.mAdapterHelper.consumeUpdatesInOnePass();
    this.mState.mItemCount = this.mAdapter.getItemCount();
    State state = this.mState;
    state.mDeletedInvisibleItemCountSincePreviousLayout = 0;
    state.mInPreLayout = false;
    this.mLayout.onLayoutChildren(this.mRecycler, state);
    state = this.mState;
    state.mStructureChanged = false;
    this.mPendingSavedState = null;
    if (state.mRunSimpleAnimations && this.mItemAnimator != null) {
      bool = true;
    } else {
      bool = false;
    } 
    state.mRunSimpleAnimations = bool;
    this.mState.mLayoutStep = 4;
    onExitLayoutOrScroll();
    stopInterceptRequestLayout(false);
  }
  
  private void dispatchLayoutStep3() {
    this.mState.assertLayoutStep(4);
    startInterceptRequestLayout();
    onEnterLayoutOrScroll();
    State state = this.mState;
    state.mLayoutStep = 1;
    if (state.mRunSimpleAnimations) {
      for (int i = this.mChildHelper.getChildCount() - 1; i >= 0; i--) {
        ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getChildAt(i));
        if (!viewHolder.shouldIgnore()) {
          long l = getChangedHolderKey(viewHolder);
          ItemAnimator.ItemHolderInfo itemHolderInfo = this.mItemAnimator.recordPostLayoutInformation(this.mState, viewHolder);
          ViewHolder viewHolder1 = this.mViewInfoStore.getFromOldChangeHolders(l);
          if (viewHolder1 != null && !viewHolder1.shouldIgnore()) {
            boolean bool1 = this.mViewInfoStore.isDisappearing(viewHolder1);
            boolean bool2 = this.mViewInfoStore.isDisappearing(viewHolder);
            if (bool1 && viewHolder1 == viewHolder) {
              this.mViewInfoStore.addToPostLayout(viewHolder, itemHolderInfo);
            } else {
              ItemAnimator.ItemHolderInfo itemHolderInfo1 = this.mViewInfoStore.popFromPreLayout(viewHolder1);
              this.mViewInfoStore.addToPostLayout(viewHolder, itemHolderInfo);
              itemHolderInfo = this.mViewInfoStore.popFromPostLayout(viewHolder);
              if (itemHolderInfo1 == null) {
                handleMissingPreInfoForChangeError(l, viewHolder, viewHolder1);
              } else {
                animateChange(viewHolder1, viewHolder, itemHolderInfo1, itemHolderInfo, bool1, bool2);
              } 
            } 
          } else {
            this.mViewInfoStore.addToPostLayout(viewHolder, itemHolderInfo);
          } 
        } 
      } 
      this.mViewInfoStore.process(this.mViewInfoProcessCallback);
    } 
    this.mLayout.removeAndRecycleScrapInt(this.mRecycler);
    state = this.mState;
    state.mPreviousLayoutItemCount = state.mItemCount;
    this.mDataSetHasChangedAfterLayout = false;
    this.mDispatchItemsChangedEvent = false;
    state = this.mState;
    state.mRunSimpleAnimations = false;
    state.mRunPredictiveAnimations = false;
    this.mLayout.mRequestedSimpleAnimations = false;
    if (this.mRecycler.mChangedScrap != null)
      this.mRecycler.mChangedScrap.clear(); 
    if (this.mLayout.mPrefetchMaxObservedInInitialPrefetch) {
      LayoutManager layoutManager = this.mLayout;
      layoutManager.mPrefetchMaxCountObserved = 0;
      layoutManager.mPrefetchMaxObservedInInitialPrefetch = false;
      this.mRecycler.updateViewCacheSize();
    } 
    this.mLayout.onLayoutCompleted(this.mState);
    onExitLayoutOrScroll();
    stopInterceptRequestLayout(false);
    this.mViewInfoStore.clear();
    int[] arrayOfInt = this.mMinMaxLayoutPositions;
    if (didChildRangeChange(arrayOfInt[0], arrayOfInt[1]))
      dispatchOnScrolled(0, 0); 
    recoverFocusFromState();
    resetFocusInfo();
  }
  
  private boolean dispatchOnItemTouch(MotionEvent paramMotionEvent) {
    int i = paramMotionEvent.getAction();
    OnItemTouchListener onItemTouchListener = this.mActiveOnItemTouchListener;
    if (onItemTouchListener != null)
      if (i == 0) {
        this.mActiveOnItemTouchListener = null;
      } else {
        onItemTouchListener.onTouchEvent(this, paramMotionEvent);
        if (i == 3 || i == 1)
          this.mActiveOnItemTouchListener = null; 
        return true;
      }  
    if (i != 0) {
      int j = this.mOnItemTouchListeners.size();
      for (i = 0; i < j; i++) {
        onItemTouchListener = (OnItemTouchListener)this.mOnItemTouchListeners.get(i);
        if (onItemTouchListener.onInterceptTouchEvent(this, paramMotionEvent)) {
          this.mActiveOnItemTouchListener = onItemTouchListener;
          return true;
        } 
      } 
    } 
    return false;
  }
  
  private boolean dispatchOnItemTouchIntercept(MotionEvent paramMotionEvent) {
    int i = paramMotionEvent.getAction();
    if (i == 3 || i == 0)
      this.mActiveOnItemTouchListener = null; 
    int j = this.mOnItemTouchListeners.size();
    for (byte b = 0; b < j; b++) {
      OnItemTouchListener onItemTouchListener = (OnItemTouchListener)this.mOnItemTouchListeners.get(b);
      if (onItemTouchListener.onInterceptTouchEvent(this, paramMotionEvent) && i != 3) {
        this.mActiveOnItemTouchListener = onItemTouchListener;
        return true;
      } 
    } 
    return false;
  }
  
  private void findMinMaxChildLayoutPositions(int[] paramArrayOfInt) {
    int k = this.mChildHelper.getChildCount();
    if (k == 0) {
      paramArrayOfInt[0] = -1;
      paramArrayOfInt[1] = -1;
      return;
    } 
    byte b = 0;
    int i = Integer.MAX_VALUE;
    int j;
    for (j = Integer.MIN_VALUE; b < k; j = m) {
      int m;
      ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getChildAt(b));
      if (viewHolder.shouldIgnore()) {
        m = j;
      } else {
        int i1 = viewHolder.getLayoutPosition();
        int n = i;
        if (i1 < i)
          n = i1; 
        i = n;
        m = j;
        if (i1 > j) {
          m = i1;
          i = n;
        } 
      } 
      b++;
    } 
    paramArrayOfInt[0] = i;
    paramArrayOfInt[1] = j;
  }
  
  @Nullable
  static RecyclerView findNestedRecyclerView(@NonNull View paramView) {
    if (!(paramView instanceof ViewGroup))
      return null; 
    if (paramView instanceof RecyclerView)
      return (RecyclerView)paramView; 
    ViewGroup viewGroup = (ViewGroup)paramView;
    int i = viewGroup.getChildCount();
    for (byte b = 0; b < i; b++) {
      RecyclerView recyclerView = findNestedRecyclerView(viewGroup.getChildAt(b));
      if (recyclerView != null)
        return recyclerView; 
    } 
    return null;
  }
  
  @Nullable
  private View findNextViewToFocus() {
    if (this.mState.mFocusedItemPosition != -1) {
      i = this.mState.mFocusedItemPosition;
    } else {
      i = 0;
    } 
    int j = this.mState.getItemCount();
    for (byte b = i; b < j; b++) {
      ViewHolder viewHolder = findViewHolderForAdapterPosition(b);
      if (viewHolder == null)
        break; 
      if (viewHolder.itemView.hasFocusable())
        return viewHolder.itemView; 
    } 
    for (int i = Math.min(j, i) - 1; i >= 0; i--) {
      ViewHolder viewHolder = findViewHolderForAdapterPosition(i);
      if (viewHolder == null)
        return null; 
      if (viewHolder.itemView.hasFocusable())
        return viewHolder.itemView; 
    } 
    return null;
  }
  
  static ViewHolder getChildViewHolderInt(View paramView) { return (paramView == null) ? null : ((LayoutParams)paramView.getLayoutParams()).mViewHolder; }
  
  static void getDecoratedBoundsWithMarginsInt(View paramView, Rect paramRect) {
    LayoutParams layoutParams = (LayoutParams)paramView.getLayoutParams();
    Rect rect = layoutParams.mDecorInsets;
    paramRect.set(paramView.getLeft() - rect.left - layoutParams.leftMargin, paramView.getTop() - rect.top - layoutParams.topMargin, paramView.getRight() + rect.right + layoutParams.rightMargin, paramView.getBottom() + rect.bottom + layoutParams.bottomMargin);
  }
  
  private int getDeepestFocusedViewWithId(View paramView) {
    int i = paramView.getId();
    while (!paramView.isFocused() && paramView instanceof ViewGroup && paramView.hasFocus()) {
      View view = ((ViewGroup)paramView).getFocusedChild();
      paramView = view;
      if (view.getId() != -1) {
        i = view.getId();
        paramView = view;
      } 
    } 
    return i;
  }
  
  private String getFullClassName(Context paramContext, String paramString) {
    if (paramString.charAt(0) == '.') {
      StringBuilder stringBuilder1 = new StringBuilder();
      stringBuilder1.append(paramContext.getPackageName());
      stringBuilder1.append(paramString);
      return stringBuilder1.toString();
    } 
    if (paramString.contains("."))
      return paramString; 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(RecyclerView.class.getPackage().getName());
    stringBuilder.append('.');
    stringBuilder.append(paramString);
    return stringBuilder.toString();
  }
  
  private NestedScrollingChildHelper getScrollingChildHelper() {
    if (this.mScrollingChildHelper == null)
      this.mScrollingChildHelper = new NestedScrollingChildHelper(this); 
    return this.mScrollingChildHelper;
  }
  
  private void handleMissingPreInfoForChangeError(long paramLong, ViewHolder paramViewHolder1, ViewHolder paramViewHolder2) {
    StringBuilder stringBuilder1;
    int i = this.mChildHelper.getChildCount();
    byte b;
    for (b = 0; b < i; b++) {
      ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getChildAt(b));
      if (viewHolder != paramViewHolder1 && getChangedHolderKey(viewHolder) == paramLong) {
        Adapter adapter = this.mAdapter;
        if (adapter != null && adapter.hasStableIds()) {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.append("Two different ViewHolders have the same stable ID. Stable IDs in your adapter MUST BE unique and SHOULD NOT change.\n ViewHolder 1:");
          stringBuilder.append(viewHolder);
          stringBuilder.append(" \n View Holder 2:");
          stringBuilder.append(paramViewHolder1);
          stringBuilder.append(exceptionLabel());
          throw new IllegalStateException(stringBuilder.toString());
        } 
        stringBuilder1 = new StringBuilder();
        stringBuilder1.append("Two different ViewHolders have the same change ID. This might happen due to inconsistent Adapter update events or if the LayoutManager lays out the same View multiple times.\n ViewHolder 1:");
        stringBuilder1.append(viewHolder);
        stringBuilder1.append(" \n View Holder 2:");
        stringBuilder1.append(paramViewHolder1);
        stringBuilder1.append(exceptionLabel());
        throw new IllegalStateException(stringBuilder1.toString());
      } 
    } 
    StringBuilder stringBuilder2 = new StringBuilder();
    stringBuilder2.append("Problem while matching changed view holders with the newones. The pre-layout information for the change holder ");
    stringBuilder2.append(stringBuilder1);
    stringBuilder2.append(" cannot be found but it is necessary for ");
    stringBuilder2.append(paramViewHolder1);
    stringBuilder2.append(exceptionLabel());
    Log.e("RecyclerView", stringBuilder2.toString());
  }
  
  private boolean hasUpdatedView() {
    int i = this.mChildHelper.getChildCount();
    for (byte b = 0; b < i; b++) {
      ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getChildAt(b));
      if (viewHolder != null && !viewHolder.shouldIgnore() && viewHolder.isUpdated())
        return true; 
    } 
    return false;
  }
  
  @SuppressLint({"InlinedApi"})
  private void initAutofill() {
    if (ViewCompat.getImportantForAutofill(this) == 0)
      ViewCompat.setImportantForAutofill(this, 8); 
  }
  
  private void initChildrenHelper() { this.mChildHelper = new ChildHelper(new Object(this)); }
  
  private boolean isPreferredNextFocus(View paramView1, View paramView2, int paramInt) {
    boolean bool1 = false;
    boolean bool2 = false;
    boolean bool3 = false;
    byte b1 = 0;
    byte b3 = 0;
    byte b2 = 0;
    null = b3;
    if (paramView2 != null) {
      int j;
      if (paramView2 == this)
        return false; 
      if (findContainingItemView(paramView2) == null)
        return false; 
      if (paramView1 == null)
        return true; 
      if (findContainingItemView(paramView1) == null)
        return true; 
      this.mTempRect.set(0, 0, paramView1.getWidth(), paramView1.getHeight());
      this.mTempRect2.set(0, 0, paramView2.getWidth(), paramView2.getHeight());
      offsetDescendantRectToMyCoords(paramView1, this.mTempRect);
      offsetDescendantRectToMyCoords(paramView2, this.mTempRect2);
      int i = this.mLayout.getLayoutDirection();
      byte b = -1;
      if (i == 1) {
        j = -1;
      } else {
        j = 1;
      } 
      if ((this.mTempRect.left < this.mTempRect2.left || this.mTempRect.right <= this.mTempRect2.left) && this.mTempRect.right < this.mTempRect2.right) {
        i = 1;
      } else if ((this.mTempRect.right > this.mTempRect2.right || this.mTempRect.left >= this.mTempRect2.right) && this.mTempRect.left > this.mTempRect2.left) {
        i = -1;
      } else {
        i = 0;
      } 
      if ((this.mTempRect.top < this.mTempRect2.top || this.mTempRect.bottom <= this.mTempRect2.top) && this.mTempRect.bottom < this.mTempRect2.bottom) {
        b = 1;
      } else if ((this.mTempRect.bottom <= this.mTempRect2.bottom && this.mTempRect.top < this.mTempRect2.bottom) || this.mTempRect.top <= this.mTempRect2.top) {
        b = 0;
      } 
      if (paramInt != 1) {
        if (paramInt != 2) {
          if (paramInt != 17) {
            if (paramInt != 33) {
              if (paramInt != 66) {
                if (paramInt == 130) {
                  null = b2;
                  if (b > 0)
                    null = true; 
                  return null;
                } 
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Invalid direction: ");
                stringBuilder.append(paramInt);
                stringBuilder.append(exceptionLabel());
                throw new IllegalArgumentException(stringBuilder.toString());
              } 
              boolean bool5 = bool1;
              if (i > 0)
                bool5 = true; 
              return bool5;
            } 
            boolean bool4 = bool2;
            if (b < 0)
              bool4 = true; 
            return bool4;
          } 
          boolean bool = bool3;
          if (i < 0)
            bool = true; 
          return bool;
        } 
        if (b <= 0) {
          int k = b1;
          if (b == 0) {
            k = b1;
            if (i * j >= 0)
              return true; 
          } 
          return k;
        } 
      } else {
        if (b >= 0) {
          int k = b3;
          if (b == 0) {
            k = b3;
            if (i * j <= 0)
              k = 1; 
          } 
          return k;
        } 
        null = true;
      } 
    } else {
      return null;
    } 
    return true;
  }
  
  private void onPointerUp(MotionEvent paramMotionEvent) {
    int i = paramMotionEvent.getActionIndex();
    if (paramMotionEvent.getPointerId(i) == this.mScrollPointerId) {
      if (i == 0) {
        i = 1;
      } else {
        i = 0;
      } 
      this.mScrollPointerId = paramMotionEvent.getPointerId(i);
      int j = (int)(paramMotionEvent.getX(i) + 0.5F);
      this.mLastTouchX = j;
      this.mInitialTouchX = j;
      i = (int)(paramMotionEvent.getY(i) + 0.5F);
      this.mLastTouchY = i;
      this.mInitialTouchY = i;
    } 
  }
  
  private boolean predictiveItemAnimationsEnabled() { return (this.mItemAnimator != null && this.mLayout.supportsPredictiveItemAnimations()); }
  
  private void processAdapterUpdatesAndSetAnimationFlags() {
    boolean bool1;
    if (this.mDataSetHasChangedAfterLayout) {
      this.mAdapterHelper.reset();
      if (this.mDispatchItemsChangedEvent)
        this.mLayout.onItemsChanged(this); 
    } 
    if (predictiveItemAnimationsEnabled()) {
      this.mAdapterHelper.preProcess();
    } else {
      this.mAdapterHelper.consumeUpdatesInOnePass();
    } 
    boolean bool = this.mItemsAddedOrRemoved;
    boolean bool2 = false;
    if (bool || this.mItemsChanged) {
      bool1 = true;
    } else {
      bool1 = false;
    } 
    State state = this.mState;
    if (this.mFirstLayoutComplete && this.mItemAnimator != null && (this.mDataSetHasChangedAfterLayout || bool1 || this.mLayout.mRequestedSimpleAnimations) && (!this.mDataSetHasChangedAfterLayout || this.mAdapter.hasStableIds())) {
      bool = true;
    } else {
      bool = false;
    } 
    state.mRunSimpleAnimations = bool;
    state = this.mState;
    bool = bool2;
    if (state.mRunSimpleAnimations) {
      bool = bool2;
      if (bool1) {
        bool = bool2;
        if (!this.mDataSetHasChangedAfterLayout) {
          bool = bool2;
          if (predictiveItemAnimationsEnabled())
            bool = true; 
        } 
      } 
    } 
    state.mRunPredictiveAnimations = bool;
  }
  
  private void pullGlows(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4) { // Byte code:
    //   0: iconst_1
    //   1: istore #6
    //   3: fload_2
    //   4: fconst_0
    //   5: fcmpg
    //   6: ifge -> 43
    //   9: aload_0
    //   10: invokevirtual ensureLeftGlow : ()V
    //   13: aload_0
    //   14: getfield mLeftGlow : Landroid/widget/EdgeEffect;
    //   17: fload_2
    //   18: fneg
    //   19: aload_0
    //   20: invokevirtual getWidth : ()I
    //   23: i2f
    //   24: fdiv
    //   25: fconst_1
    //   26: fload_3
    //   27: aload_0
    //   28: invokevirtual getHeight : ()I
    //   31: i2f
    //   32: fdiv
    //   33: fsub
    //   34: invokestatic onPull : (Landroid/widget/EdgeEffect;FF)V
    //   37: iconst_1
    //   38: istore #5
    //   40: goto -> 80
    //   43: fload_2
    //   44: fconst_0
    //   45: fcmpl
    //   46: ifle -> 77
    //   49: aload_0
    //   50: invokevirtual ensureRightGlow : ()V
    //   53: aload_0
    //   54: getfield mRightGlow : Landroid/widget/EdgeEffect;
    //   57: fload_2
    //   58: aload_0
    //   59: invokevirtual getWidth : ()I
    //   62: i2f
    //   63: fdiv
    //   64: fload_3
    //   65: aload_0
    //   66: invokevirtual getHeight : ()I
    //   69: i2f
    //   70: fdiv
    //   71: invokestatic onPull : (Landroid/widget/EdgeEffect;FF)V
    //   74: goto -> 37
    //   77: iconst_0
    //   78: istore #5
    //   80: fload #4
    //   82: fconst_0
    //   83: fcmpg
    //   84: ifge -> 121
    //   87: aload_0
    //   88: invokevirtual ensureTopGlow : ()V
    //   91: aload_0
    //   92: getfield mTopGlow : Landroid/widget/EdgeEffect;
    //   95: fload #4
    //   97: fneg
    //   98: aload_0
    //   99: invokevirtual getHeight : ()I
    //   102: i2f
    //   103: fdiv
    //   104: fload_1
    //   105: aload_0
    //   106: invokevirtual getWidth : ()I
    //   109: i2f
    //   110: fdiv
    //   111: invokestatic onPull : (Landroid/widget/EdgeEffect;FF)V
    //   114: iload #6
    //   116: istore #5
    //   118: goto -> 163
    //   121: fload #4
    //   123: fconst_0
    //   124: fcmpl
    //   125: ifle -> 163
    //   128: aload_0
    //   129: invokevirtual ensureBottomGlow : ()V
    //   132: aload_0
    //   133: getfield mBottomGlow : Landroid/widget/EdgeEffect;
    //   136: fload #4
    //   138: aload_0
    //   139: invokevirtual getHeight : ()I
    //   142: i2f
    //   143: fdiv
    //   144: fconst_1
    //   145: fload_1
    //   146: aload_0
    //   147: invokevirtual getWidth : ()I
    //   150: i2f
    //   151: fdiv
    //   152: fsub
    //   153: invokestatic onPull : (Landroid/widget/EdgeEffect;FF)V
    //   156: iload #6
    //   158: istore #5
    //   160: goto -> 163
    //   163: iload #5
    //   165: ifne -> 181
    //   168: fload_2
    //   169: fconst_0
    //   170: fcmpl
    //   171: ifne -> 181
    //   174: fload #4
    //   176: fconst_0
    //   177: fcmpl
    //   178: ifeq -> 185
    //   181: aload_0
    //   182: invokestatic postInvalidateOnAnimation : (Landroid/view/View;)V
    //   185: return }
  
  private void recoverFocusFromState() {
    if (this.mPreserveFocusAfterLayout && this.mAdapter != null && hasFocus() && getDescendantFocusability() != 393216) {
      View view1;
      if (getDescendantFocusability() == 131072 && isFocused())
        return; 
      if (!isFocused()) {
        view1 = getFocusedChild();
        if (IGNORE_DETACHED_FOCUSED_CHILD && (view1.getParent() == null || !view1.hasFocus())) {
          if (this.mChildHelper.getChildCount() == 0) {
            requestFocus();
            return;
          } 
        } else if (!this.mChildHelper.isHidden(view1)) {
          return;
        } 
      } 
      long l = this.mState.mFocusedItemId;
      View view2 = null;
      if (l != -1L && this.mAdapter.hasStableIds()) {
        view1 = findViewHolderForItemId(this.mState.mFocusedItemId);
      } else {
        view1 = null;
      } 
      if (view1 == null || this.mChildHelper.isHidden(view1.itemView) || !view1.itemView.hasFocusable()) {
        view1 = view2;
        if (this.mChildHelper.getChildCount() > 0)
          view1 = findNextViewToFocus(); 
      } else {
        view1 = view1.itemView;
      } 
      if (view1 != null) {
        if (this.mState.mFocusedSubChildId != -1L) {
          view2 = view1.findViewById(this.mState.mFocusedSubChildId);
          if (view2 != null && view2.isFocusable())
            view1 = view2; 
        } 
        view1.requestFocus();
      } 
    } 
  }
  
  private void releaseGlows() {
    EdgeEffect edgeEffect = this.mLeftGlow;
    if (edgeEffect != null) {
      edgeEffect.onRelease();
      bool2 = this.mLeftGlow.isFinished();
    } else {
      bool2 = false;
    } 
    edgeEffect = this.mTopGlow;
    boolean bool1 = bool2;
    if (edgeEffect != null) {
      edgeEffect.onRelease();
      bool1 = bool2 | this.mTopGlow.isFinished();
    } 
    edgeEffect = this.mRightGlow;
    boolean bool2 = bool1;
    if (edgeEffect != null) {
      edgeEffect.onRelease();
      bool2 = bool1 | this.mRightGlow.isFinished();
    } 
    edgeEffect = this.mBottomGlow;
    bool1 = bool2;
    if (edgeEffect != null) {
      edgeEffect.onRelease();
      bool1 = bool2 | this.mBottomGlow.isFinished();
    } 
    if (bool1)
      ViewCompat.postInvalidateOnAnimation(this); 
  }
  
  private void requestChildOnScreen(@NonNull View paramView1, @Nullable View paramView2) {
    View view;
    boolean bool1;
    if (paramView2 != null) {
      view = paramView2;
    } else {
      view = paramView1;
    } 
    this.mTempRect.set(0, 0, view.getWidth(), view.getHeight());
    ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
    if (layoutParams instanceof LayoutParams) {
      LayoutParams layoutParams1 = (LayoutParams)layoutParams;
      if (!layoutParams1.mInsetsDirty) {
        Rect rect1 = layoutParams1.mDecorInsets;
        Rect rect2 = this.mTempRect;
        rect2.left -= rect1.left;
        rect2 = this.mTempRect;
        rect2.right += rect1.right;
        rect2 = this.mTempRect;
        rect2.top -= rect1.top;
        rect2 = this.mTempRect;
        rect2.bottom += rect1.bottom;
      } 
    } 
    if (paramView2 != null) {
      offsetDescendantRectToMyCoords(paramView2, this.mTempRect);
      offsetRectIntoDescendantCoords(paramView1, this.mTempRect);
    } 
    LayoutManager layoutManager = this.mLayout;
    Rect rect = this.mTempRect;
    boolean bool2 = this.mFirstLayoutComplete;
    if (paramView2 == null) {
      bool1 = true;
    } else {
      bool1 = false;
    } 
    layoutManager.requestChildRectangleOnScreen(this, paramView1, rect, bool2 ^ true, bool1);
  }
  
  private void resetFocusInfo() {
    State state = this.mState;
    state.mFocusedItemId = -1L;
    state.mFocusedItemPosition = -1;
    state.mFocusedSubChildId = -1;
  }
  
  private void resetTouch() {
    VelocityTracker velocityTracker = this.mVelocityTracker;
    if (velocityTracker != null)
      velocityTracker.clear(); 
    stopNestedScroll(0);
    releaseGlows();
  }
  
  private void saveFocusInfo() {
    ViewHolder viewHolder;
    long l;
    int i;
    boolean bool = this.mPreserveFocusAfterLayout;
    State state = null;
    if (bool && hasFocus() && this.mAdapter != null) {
      viewHolder = getFocusedChild();
    } else {
      viewHolder = null;
    } 
    if (viewHolder == null) {
      viewHolder = state;
    } else {
      viewHolder = findContainingViewHolder(viewHolder);
    } 
    if (viewHolder == null) {
      resetFocusInfo();
      return;
    } 
    state = this.mState;
    if (this.mAdapter.hasStableIds()) {
      l = viewHolder.getItemId();
    } else {
      l = -1L;
    } 
    state.mFocusedItemId = l;
    state = this.mState;
    if (this.mDataSetHasChangedAfterLayout) {
      i = -1;
    } else if (viewHolder.isRemoved()) {
      i = viewHolder.mOldPosition;
    } else {
      i = viewHolder.getAdapterPosition();
    } 
    state.mFocusedItemPosition = i;
    this.mState.mFocusedSubChildId = getDeepestFocusedViewWithId(viewHolder.itemView);
  }
  
  private void setAdapterInternal(@Nullable Adapter paramAdapter, boolean paramBoolean1, boolean paramBoolean2) {
    Adapter adapter = this.mAdapter;
    if (adapter != null) {
      adapter.unregisterAdapterDataObserver(this.mObserver);
      this.mAdapter.onDetachedFromRecyclerView(this);
    } 
    if (!paramBoolean1 || paramBoolean2)
      removeAndRecycleViews(); 
    this.mAdapterHelper.reset();
    adapter = this.mAdapter;
    this.mAdapter = paramAdapter;
    if (paramAdapter != null) {
      paramAdapter.registerAdapterDataObserver(this.mObserver);
      paramAdapter.onAttachedToRecyclerView(this);
    } 
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null)
      layoutManager.onAdapterChanged(adapter, this.mAdapter); 
    this.mRecycler.onAdapterChanged(adapter, this.mAdapter, paramBoolean1);
    this.mState.mStructureChanged = true;
  }
  
  private void stopScrollersInternal() {
    this.mViewFlinger.stop();
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null)
      layoutManager.stopSmoothScroller(); 
  }
  
  void absorbGlows(int paramInt1, int paramInt2) {
    if (paramInt1 < 0) {
      ensureLeftGlow();
      this.mLeftGlow.onAbsorb(-paramInt1);
    } else if (paramInt1 > 0) {
      ensureRightGlow();
      this.mRightGlow.onAbsorb(paramInt1);
    } 
    if (paramInt2 < 0) {
      ensureTopGlow();
      this.mTopGlow.onAbsorb(-paramInt2);
    } else if (paramInt2 > 0) {
      ensureBottomGlow();
      this.mBottomGlow.onAbsorb(paramInt2);
    } 
    if (paramInt1 != 0 || paramInt2 != 0)
      ViewCompat.postInvalidateOnAnimation(this); 
  }
  
  public void addFocusables(ArrayList<View> paramArrayList, int paramInt1, int paramInt2) {
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager == null || !layoutManager.onAddFocusables(this, paramArrayList, paramInt1, paramInt2))
      super.addFocusables(paramArrayList, paramInt1, paramInt2); 
  }
  
  public void addItemDecoration(@NonNull ItemDecoration paramItemDecoration) { addItemDecoration(paramItemDecoration, -1); }
  
  public void addItemDecoration(@NonNull ItemDecoration paramItemDecoration, int paramInt) {
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null)
      layoutManager.assertNotInLayoutOrScroll("Cannot add item decoration during a scroll  or layout"); 
    if (this.mItemDecorations.isEmpty())
      setWillNotDraw(false); 
    if (paramInt < 0) {
      this.mItemDecorations.add(paramItemDecoration);
    } else {
      this.mItemDecorations.add(paramInt, paramItemDecoration);
    } 
    markItemDecorInsetsDirty();
    requestLayout();
  }
  
  public void addOnChildAttachStateChangeListener(@NonNull OnChildAttachStateChangeListener paramOnChildAttachStateChangeListener) {
    if (this.mOnChildAttachStateListeners == null)
      this.mOnChildAttachStateListeners = new ArrayList(); 
    this.mOnChildAttachStateListeners.add(paramOnChildAttachStateChangeListener);
  }
  
  public void addOnItemTouchListener(@NonNull OnItemTouchListener paramOnItemTouchListener) { this.mOnItemTouchListeners.add(paramOnItemTouchListener); }
  
  public void addOnScrollListener(@NonNull OnScrollListener paramOnScrollListener) {
    if (this.mScrollListeners == null)
      this.mScrollListeners = new ArrayList(); 
    this.mScrollListeners.add(paramOnScrollListener);
  }
  
  void animateAppearance(@NonNull ViewHolder paramViewHolder, @Nullable ItemAnimator.ItemHolderInfo paramItemHolderInfo1, @NonNull ItemAnimator.ItemHolderInfo paramItemHolderInfo2) {
    paramViewHolder.setIsRecyclable(false);
    if (this.mItemAnimator.animateAppearance(paramViewHolder, paramItemHolderInfo1, paramItemHolderInfo2))
      postAnimationRunner(); 
  }
  
  void animateDisappearance(@NonNull ViewHolder paramViewHolder, @NonNull ItemAnimator.ItemHolderInfo paramItemHolderInfo1, @Nullable ItemAnimator.ItemHolderInfo paramItemHolderInfo2) {
    addAnimatingView(paramViewHolder);
    paramViewHolder.setIsRecyclable(false);
    if (this.mItemAnimator.animateDisappearance(paramViewHolder, paramItemHolderInfo1, paramItemHolderInfo2))
      postAnimationRunner(); 
  }
  
  void assertInLayoutOrScroll(String paramString) {
    if (!isComputingLayout()) {
      StringBuilder stringBuilder1;
      if (paramString == null) {
        stringBuilder1 = new StringBuilder();
        stringBuilder1.append("Cannot call this method unless RecyclerView is computing a layout or scrolling");
        stringBuilder1.append(exceptionLabel());
        throw new IllegalStateException(stringBuilder1.toString());
      } 
      StringBuilder stringBuilder2 = new StringBuilder();
      stringBuilder2.append(stringBuilder1);
      stringBuilder2.append(exceptionLabel());
      throw new IllegalStateException(stringBuilder2.toString());
    } 
  }
  
  void assertNotInLayoutOrScroll(String paramString) {
    if (isComputingLayout()) {
      StringBuilder stringBuilder;
      if (paramString == null) {
        stringBuilder = new StringBuilder();
        stringBuilder.append("Cannot call this method while RecyclerView is computing a layout or scrolling");
        stringBuilder.append(exceptionLabel());
        throw new IllegalStateException(stringBuilder.toString());
      } 
      throw new IllegalStateException(stringBuilder);
    } 
    if (this.mDispatchScrollCounter > 0) {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append("");
      stringBuilder.append(exceptionLabel());
      Log.w("RecyclerView", "Cannot call this method in a scroll callback. Scroll callbacks mightbe run during a measure & layout pass where you cannot change theRecyclerView data. Any method call that might change the structureof the RecyclerView or the adapter contents should be postponed tothe next frame.", new IllegalStateException(stringBuilder.toString()));
    } 
  }
  
  boolean canReuseUpdatedViewHolder(ViewHolder paramViewHolder) {
    ItemAnimator itemAnimator = this.mItemAnimator;
    return (itemAnimator == null || itemAnimator.canReuseUpdatedViewHolder(paramViewHolder, paramViewHolder.getUnmodifiedPayloads()));
  }
  
  protected boolean checkLayoutParams(ViewGroup.LayoutParams paramLayoutParams) { return (paramLayoutParams instanceof LayoutParams && this.mLayout.checkLayoutParams((LayoutParams)paramLayoutParams)); }
  
  void clearOldPositions() {
    int i = this.mChildHelper.getUnfilteredChildCount();
    for (byte b = 0; b < i; b++) {
      ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getUnfilteredChildAt(b));
      if (!viewHolder.shouldIgnore())
        viewHolder.clearOldPosition(); 
    } 
    this.mRecycler.clearOldPositions();
  }
  
  public void clearOnChildAttachStateChangeListeners() {
    List list = this.mOnChildAttachStateListeners;
    if (list != null)
      list.clear(); 
  }
  
  public void clearOnScrollListeners() {
    List list = this.mScrollListeners;
    if (list != null)
      list.clear(); 
  }
  
  public int computeHorizontalScrollExtent() {
    LayoutManager layoutManager = this.mLayout;
    int i = 0;
    if (layoutManager == null)
      return 0; 
    if (layoutManager.canScrollHorizontally())
      i = this.mLayout.computeHorizontalScrollExtent(this.mState); 
    return i;
  }
  
  public int computeHorizontalScrollOffset() {
    LayoutManager layoutManager = this.mLayout;
    int i = 0;
    if (layoutManager == null)
      return 0; 
    if (layoutManager.canScrollHorizontally())
      i = this.mLayout.computeHorizontalScrollOffset(this.mState); 
    return i;
  }
  
  public int computeHorizontalScrollRange() {
    LayoutManager layoutManager = this.mLayout;
    int i = 0;
    if (layoutManager == null)
      return 0; 
    if (layoutManager.canScrollHorizontally())
      i = this.mLayout.computeHorizontalScrollRange(this.mState); 
    return i;
  }
  
  public int computeVerticalScrollExtent() {
    LayoutManager layoutManager = this.mLayout;
    int i = 0;
    if (layoutManager == null)
      return 0; 
    if (layoutManager.canScrollVertically())
      i = this.mLayout.computeVerticalScrollExtent(this.mState); 
    return i;
  }
  
  public int computeVerticalScrollOffset() {
    LayoutManager layoutManager = this.mLayout;
    int i = 0;
    if (layoutManager == null)
      return 0; 
    if (layoutManager.canScrollVertically())
      i = this.mLayout.computeVerticalScrollOffset(this.mState); 
    return i;
  }
  
  public int computeVerticalScrollRange() {
    LayoutManager layoutManager = this.mLayout;
    int i = 0;
    if (layoutManager == null)
      return 0; 
    if (layoutManager.canScrollVertically())
      i = this.mLayout.computeVerticalScrollRange(this.mState); 
    return i;
  }
  
  void considerReleasingGlowsOnScroll(int paramInt1, int paramInt2) {
    EdgeEffect edgeEffect = this.mLeftGlow;
    if (edgeEffect != null && !edgeEffect.isFinished() && paramInt1 > 0) {
      this.mLeftGlow.onRelease();
      b2 = this.mLeftGlow.isFinished();
    } else {
      b2 = 0;
    } 
    edgeEffect = this.mRightGlow;
    byte b1 = b2;
    if (edgeEffect != null) {
      b1 = b2;
      if (!edgeEffect.isFinished()) {
        b1 = b2;
        if (paramInt1 < 0) {
          this.mRightGlow.onRelease();
          b1 = b2 | this.mRightGlow.isFinished();
        } 
      } 
    } 
    edgeEffect = this.mTopGlow;
    byte b2 = b1;
    if (edgeEffect != null) {
      b2 = b1;
      if (!edgeEffect.isFinished()) {
        b2 = b1;
        if (paramInt2 > 0) {
          this.mTopGlow.onRelease();
          b2 = b1 | this.mTopGlow.isFinished();
        } 
      } 
    } 
    edgeEffect = this.mBottomGlow;
    b1 = b2;
    if (edgeEffect != null) {
      b1 = b2;
      if (!edgeEffect.isFinished()) {
        b1 = b2;
        if (paramInt2 < 0) {
          this.mBottomGlow.onRelease();
          b1 = b2 | this.mBottomGlow.isFinished();
        } 
      } 
    } 
    if (b1 != 0)
      ViewCompat.postInvalidateOnAnimation(this); 
  }
  
  void consumePendingUpdateOperations() {
    if (!this.mFirstLayoutComplete || this.mDataSetHasChangedAfterLayout) {
      TraceCompat.beginSection("RV FullInvalidate");
      dispatchLayout();
      TraceCompat.endSection();
      return;
    } 
    if (!this.mAdapterHelper.hasPendingUpdates())
      return; 
    if (this.mAdapterHelper.hasAnyUpdateTypes(4) && !this.mAdapterHelper.hasAnyUpdateTypes(11)) {
      TraceCompat.beginSection("RV PartialInvalidate");
      startInterceptRequestLayout();
      onEnterLayoutOrScroll();
      this.mAdapterHelper.preProcess();
      if (!this.mLayoutWasDefered)
        if (hasUpdatedView()) {
          dispatchLayout();
        } else {
          this.mAdapterHelper.consumePostponedUpdates();
        }  
      stopInterceptRequestLayout(true);
      onExitLayoutOrScroll();
      TraceCompat.endSection();
      return;
    } 
    if (this.mAdapterHelper.hasPendingUpdates()) {
      TraceCompat.beginSection("RV FullInvalidate");
      dispatchLayout();
      TraceCompat.endSection();
    } 
  }
  
  void defaultOnMeasure(int paramInt1, int paramInt2) { setMeasuredDimension(LayoutManager.chooseSize(paramInt1, getPaddingLeft() + getPaddingRight(), ViewCompat.getMinimumWidth(this)), LayoutManager.chooseSize(paramInt2, getPaddingTop() + getPaddingBottom(), ViewCompat.getMinimumHeight(this))); }
  
  void dispatchChildAttached(View paramView) {
    ViewHolder viewHolder = getChildViewHolderInt(paramView);
    onChildAttachedToWindow(paramView);
    Adapter adapter = this.mAdapter;
    if (adapter != null && viewHolder != null)
      adapter.onViewAttachedToWindow(viewHolder); 
    List list = this.mOnChildAttachStateListeners;
    if (list != null)
      for (int i = list.size() - 1; i >= 0; i--)
        ((OnChildAttachStateChangeListener)this.mOnChildAttachStateListeners.get(i)).onChildViewAttachedToWindow(paramView);  
  }
  
  void dispatchChildDetached(View paramView) {
    ViewHolder viewHolder = getChildViewHolderInt(paramView);
    onChildDetachedFromWindow(paramView);
    Adapter adapter = this.mAdapter;
    if (adapter != null && viewHolder != null)
      adapter.onViewDetachedFromWindow(viewHolder); 
    List list = this.mOnChildAttachStateListeners;
    if (list != null)
      for (int i = list.size() - 1; i >= 0; i--)
        ((OnChildAttachStateChangeListener)this.mOnChildAttachStateListeners.get(i)).onChildViewDetachedFromWindow(paramView);  
  }
  
  void dispatchLayout() {
    if (this.mAdapter == null) {
      Log.e("RecyclerView", "No adapter attached; skipping layout");
      return;
    } 
    if (this.mLayout == null) {
      Log.e("RecyclerView", "No layout manager attached; skipping layout");
      return;
    } 
    State state = this.mState;
    state.mIsMeasuring = false;
    if (state.mLayoutStep == 1) {
      dispatchLayoutStep1();
      this.mLayout.setExactMeasureSpecsFrom(this);
      dispatchLayoutStep2();
    } else if (this.mAdapterHelper.hasUpdates() || this.mLayout.getWidth() != getWidth() || this.mLayout.getHeight() != getHeight()) {
      this.mLayout.setExactMeasureSpecsFrom(this);
      dispatchLayoutStep2();
    } else {
      this.mLayout.setExactMeasureSpecsFrom(this);
    } 
    dispatchLayoutStep3();
  }
  
  public boolean dispatchNestedFling(float paramFloat1, float paramFloat2, boolean paramBoolean) { return getScrollingChildHelper().dispatchNestedFling(paramFloat1, paramFloat2, paramBoolean); }
  
  public boolean dispatchNestedPreFling(float paramFloat1, float paramFloat2) { return getScrollingChildHelper().dispatchNestedPreFling(paramFloat1, paramFloat2); }
  
  public boolean dispatchNestedPreScroll(int paramInt1, int paramInt2, int[] paramArrayOfInt1, int[] paramArrayOfInt2) { return getScrollingChildHelper().dispatchNestedPreScroll(paramInt1, paramInt2, paramArrayOfInt1, paramArrayOfInt2); }
  
  public boolean dispatchNestedPreScroll(int paramInt1, int paramInt2, int[] paramArrayOfInt1, int[] paramArrayOfInt2, int paramInt3) { return getScrollingChildHelper().dispatchNestedPreScroll(paramInt1, paramInt2, paramArrayOfInt1, paramArrayOfInt2, paramInt3); }
  
  public boolean dispatchNestedScroll(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int[] paramArrayOfInt) { return getScrollingChildHelper().dispatchNestedScroll(paramInt1, paramInt2, paramInt3, paramInt4, paramArrayOfInt); }
  
  public boolean dispatchNestedScroll(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int[] paramArrayOfInt, int paramInt5) { return getScrollingChildHelper().dispatchNestedScroll(paramInt1, paramInt2, paramInt3, paramInt4, paramArrayOfInt, paramInt5); }
  
  void dispatchOnScrollStateChanged(int paramInt) {
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null)
      layoutManager.onScrollStateChanged(paramInt); 
    onScrollStateChanged(paramInt);
    OnScrollListener onScrollListener = this.mScrollListener;
    if (onScrollListener != null)
      onScrollListener.onScrollStateChanged(this, paramInt); 
    List list = this.mScrollListeners;
    if (list != null)
      for (int i = list.size() - 1; i >= 0; i--)
        ((OnScrollListener)this.mScrollListeners.get(i)).onScrollStateChanged(this, paramInt);  
  }
  
  void dispatchOnScrolled(int paramInt1, int paramInt2) {
    this.mDispatchScrollCounter++;
    int i = getScrollX();
    int j = getScrollY();
    onScrollChanged(i, j, i, j);
    onScrolled(paramInt1, paramInt2);
    OnScrollListener onScrollListener = this.mScrollListener;
    if (onScrollListener != null)
      onScrollListener.onScrolled(this, paramInt1, paramInt2); 
    List list = this.mScrollListeners;
    if (list != null)
      for (i = list.size() - 1; i >= 0; i--)
        ((OnScrollListener)this.mScrollListeners.get(i)).onScrolled(this, paramInt1, paramInt2);  
    this.mDispatchScrollCounter--;
  }
  
  void dispatchPendingImportantForAccessibilityChanges() {
    for (int i = this.mPendingAccessibilityImportanceChange.size() - 1; i >= 0; i--) {
      ViewHolder viewHolder = (ViewHolder)this.mPendingAccessibilityImportanceChange.get(i);
      if (viewHolder.itemView.getParent() == this && !viewHolder.shouldIgnore()) {
        int j = viewHolder.mPendingAccessibilityState;
        if (j != -1) {
          ViewCompat.setImportantForAccessibility(viewHolder.itemView, j);
          viewHolder.mPendingAccessibilityState = -1;
        } 
      } 
    } 
    this.mPendingAccessibilityImportanceChange.clear();
  }
  
  protected void dispatchRestoreInstanceState(SparseArray<Parcelable> paramSparseArray) { dispatchThawSelfOnly(paramSparseArray); }
  
  protected void dispatchSaveInstanceState(SparseArray<Parcelable> paramSparseArray) { dispatchFreezeSelfOnly(paramSparseArray); }
  
  public void draw(Canvas paramCanvas) {
    super.draw(paramCanvas);
    int j = this.mItemDecorations.size();
    int k = 0;
    int i;
    for (i = 0; i < j; i++)
      ((ItemDecoration)this.mItemDecorations.get(i)).onDrawOver(paramCanvas, this, this.mState); 
    EdgeEffect edgeEffect = this.mLeftGlow;
    if (edgeEffect != null && !edgeEffect.isFinished()) {
      int m = paramCanvas.save();
      if (this.mClipToPadding) {
        i = getPaddingBottom();
      } else {
        i = 0;
      } 
      paramCanvas.rotate(270.0F);
      paramCanvas.translate((-getHeight() + i), 0.0F);
      edgeEffect = this.mLeftGlow;
      if (edgeEffect != null && edgeEffect.draw(paramCanvas)) {
        j = 1;
      } else {
        j = 0;
      } 
      paramCanvas.restoreToCount(m);
    } else {
      j = 0;
    } 
    edgeEffect = this.mTopGlow;
    i = j;
    if (edgeEffect != null) {
      i = j;
      if (!edgeEffect.isFinished()) {
        int m = paramCanvas.save();
        if (this.mClipToPadding)
          paramCanvas.translate(getPaddingLeft(), getPaddingTop()); 
        edgeEffect = this.mTopGlow;
        if (edgeEffect != null && edgeEffect.draw(paramCanvas)) {
          i = 1;
        } else {
          i = 0;
        } 
        i = j | i;
        paramCanvas.restoreToCount(m);
      } 
    } 
    edgeEffect = this.mRightGlow;
    j = i;
    if (edgeEffect != null) {
      j = i;
      if (!edgeEffect.isFinished()) {
        int m = paramCanvas.save();
        int n = getWidth();
        if (this.mClipToPadding) {
          j = getPaddingTop();
        } else {
          j = 0;
        } 
        paramCanvas.rotate(90.0F);
        paramCanvas.translate(-j, -n);
        edgeEffect = this.mRightGlow;
        if (edgeEffect != null && edgeEffect.draw(paramCanvas)) {
          j = 1;
        } else {
          j = 0;
        } 
        j = i | j;
        paramCanvas.restoreToCount(m);
      } 
    } 
    edgeEffect = this.mBottomGlow;
    if (edgeEffect != null && !edgeEffect.isFinished()) {
      int m = paramCanvas.save();
      paramCanvas.rotate(180.0F);
      if (this.mClipToPadding) {
        paramCanvas.translate((-getWidth() + getPaddingRight()), (-getHeight() + getPaddingBottom()));
      } else {
        paramCanvas.translate(-getWidth(), -getHeight());
      } 
      edgeEffect = this.mBottomGlow;
      i = k;
      if (edgeEffect != null) {
        i = k;
        if (edgeEffect.draw(paramCanvas))
          i = 1; 
      } 
      i |= j;
      paramCanvas.restoreToCount(m);
    } else {
      i = j;
    } 
    j = i;
    if (i == 0) {
      j = i;
      if (this.mItemAnimator != null) {
        j = i;
        if (this.mItemDecorations.size() > 0) {
          j = i;
          if (this.mItemAnimator.isRunning())
            j = 1; 
        } 
      } 
    } 
    if (j != 0)
      ViewCompat.postInvalidateOnAnimation(this); 
  }
  
  public boolean drawChild(Canvas paramCanvas, View paramView, long paramLong) { return super.drawChild(paramCanvas, paramView, paramLong); }
  
  void ensureBottomGlow() {
    if (this.mBottomGlow != null)
      return; 
    this.mBottomGlow = this.mEdgeEffectFactory.createEdgeEffect(this, 3);
    if (this.mClipToPadding) {
      this.mBottomGlow.setSize(getMeasuredWidth() - getPaddingLeft() - getPaddingRight(), getMeasuredHeight() - getPaddingTop() - getPaddingBottom());
      return;
    } 
    this.mBottomGlow.setSize(getMeasuredWidth(), getMeasuredHeight());
  }
  
  void ensureLeftGlow() {
    if (this.mLeftGlow != null)
      return; 
    this.mLeftGlow = this.mEdgeEffectFactory.createEdgeEffect(this, 0);
    if (this.mClipToPadding) {
      this.mLeftGlow.setSize(getMeasuredHeight() - getPaddingTop() - getPaddingBottom(), getMeasuredWidth() - getPaddingLeft() - getPaddingRight());
      return;
    } 
    this.mLeftGlow.setSize(getMeasuredHeight(), getMeasuredWidth());
  }
  
  void ensureRightGlow() {
    if (this.mRightGlow != null)
      return; 
    this.mRightGlow = this.mEdgeEffectFactory.createEdgeEffect(this, 2);
    if (this.mClipToPadding) {
      this.mRightGlow.setSize(getMeasuredHeight() - getPaddingTop() - getPaddingBottom(), getMeasuredWidth() - getPaddingLeft() - getPaddingRight());
      return;
    } 
    this.mRightGlow.setSize(getMeasuredHeight(), getMeasuredWidth());
  }
  
  void ensureTopGlow() {
    if (this.mTopGlow != null)
      return; 
    this.mTopGlow = this.mEdgeEffectFactory.createEdgeEffect(this, 1);
    if (this.mClipToPadding) {
      this.mTopGlow.setSize(getMeasuredWidth() - getPaddingLeft() - getPaddingRight(), getMeasuredHeight() - getPaddingTop() - getPaddingBottom());
      return;
    } 
    this.mTopGlow.setSize(getMeasuredWidth(), getMeasuredHeight());
  }
  
  String exceptionLabel() {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(" ");
    stringBuilder.append(toString());
    stringBuilder.append(", adapter:");
    stringBuilder.append(this.mAdapter);
    stringBuilder.append(", layout:");
    stringBuilder.append(this.mLayout);
    stringBuilder.append(", context:");
    stringBuilder.append(getContext());
    return stringBuilder.toString();
  }
  
  final void fillRemainingScrollValues(State paramState) {
    if (getScrollState() == 2) {
      OverScroller overScroller = this.mViewFlinger.mScroller;
      paramState.mRemainingScrollHorizontal = overScroller.getFinalX() - overScroller.getCurrX();
      paramState.mRemainingScrollVertical = overScroller.getFinalY() - overScroller.getCurrY();
      return;
    } 
    paramState.mRemainingScrollHorizontal = 0;
    paramState.mRemainingScrollVertical = 0;
  }
  
  @Nullable
  public View findChildViewUnder(float paramFloat1, float paramFloat2) {
    int i;
    for (i = this.mChildHelper.getChildCount() - 1; i >= 0; i--) {
      View view = this.mChildHelper.getChildAt(i);
      float f1 = view.getTranslationX();
      float f2 = view.getTranslationY();
      if (paramFloat1 >= view.getLeft() + f1 && paramFloat1 <= view.getRight() + f1 && paramFloat2 >= view.getTop() + f2 && paramFloat2 <= view.getBottom() + f2)
        return view; 
    } 
    return null;
  }
  
  @Nullable
  public View findContainingItemView(@NonNull View paramView) {
    ViewParent viewParent2 = paramView.getParent();
    View view = paramView;
    ViewParent viewParent1;
    for (viewParent1 = viewParent2; viewParent1 != null && viewParent1 != this && viewParent1 instanceof View; viewParent1 = view.getParent())
      view = (View)viewParent1; 
    return (viewParent1 == this) ? view : null;
  }
  
  @Nullable
  public ViewHolder findContainingViewHolder(@NonNull View paramView) {
    paramView = findContainingItemView(paramView);
    return (paramView == null) ? null : getChildViewHolder(paramView);
  }
  
  @Nullable
  public ViewHolder findViewHolderForAdapterPosition(int paramInt) {
    boolean bool = this.mDataSetHasChangedAfterLayout;
    ViewHolder viewHolder = null;
    if (bool)
      return null; 
    int i = this.mChildHelper.getUnfilteredChildCount();
    byte b = 0;
    while (b < i) {
      ViewHolder viewHolder2 = getChildViewHolderInt(this.mChildHelper.getUnfilteredChildAt(b));
      ViewHolder viewHolder1 = viewHolder;
      if (viewHolder2 != null) {
        viewHolder1 = viewHolder;
        if (!viewHolder2.isRemoved()) {
          viewHolder1 = viewHolder;
          if (getAdapterPositionFor(viewHolder2) == paramInt)
            if (this.mChildHelper.isHidden(viewHolder2.itemView)) {
              viewHolder1 = viewHolder2;
            } else {
              return viewHolder2;
            }  
        } 
      } 
      b++;
      viewHolder = viewHolder1;
    } 
    return viewHolder;
  }
  
  public ViewHolder findViewHolderForItemId(long paramLong) {
    Adapter adapter = this.mAdapter;
    ViewHolder viewHolder2 = null;
    ViewHolder viewHolder1 = null;
    if (adapter != null) {
      if (!adapter.hasStableIds())
        return null; 
      int i = this.mChildHelper.getUnfilteredChildCount();
      byte b = 0;
      while (true) {
        viewHolder2 = viewHolder1;
        if (b < i) {
          ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getUnfilteredChildAt(b));
          viewHolder2 = viewHolder1;
          if (viewHolder != null) {
            viewHolder2 = viewHolder1;
            if (!viewHolder.isRemoved()) {
              viewHolder2 = viewHolder1;
              if (viewHolder.getItemId() == paramLong)
                if (this.mChildHelper.isHidden(viewHolder.itemView)) {
                  viewHolder2 = viewHolder;
                } else {
                  return viewHolder;
                }  
            } 
          } 
          b++;
          viewHolder1 = viewHolder2;
          continue;
        } 
        break;
      } 
    } 
    return viewHolder2;
  }
  
  @Nullable
  public ViewHolder findViewHolderForLayoutPosition(int paramInt) { return findViewHolderForPosition(paramInt, false); }
  
  @Deprecated
  @Nullable
  public ViewHolder findViewHolderForPosition(int paramInt) { return findViewHolderForPosition(paramInt, false); }
  
  @Nullable
  ViewHolder findViewHolderForPosition(int paramInt, boolean paramBoolean) {
    int i = this.mChildHelper.getUnfilteredChildCount();
    Object object = null;
    byte b = 0;
    while (b < i) {
      ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getUnfilteredChildAt(b));
      Object object1 = object;
      if (viewHolder != null) {
        object1 = object;
        if (!viewHolder.isRemoved()) {
          if (paramBoolean) {
            if (viewHolder.mPosition != paramInt) {
              object1 = object;
              continue;
            } 
          } else if (viewHolder.getLayoutPosition() != paramInt) {
            object1 = object;
            continue;
          } 
          if (this.mChildHelper.isHidden(viewHolder.itemView)) {
            object1 = viewHolder;
          } else {
            return viewHolder;
          } 
        } 
      } 
      continue;
      b++;
      object = SYNTHETIC_LOCAL_VARIABLE_6;
    } 
    return object;
  }
  
  public boolean fling(int paramInt1, int paramInt2) { // Byte code:
    //   0: aload_0
    //   1: getfield mLayout : Landroid/support/v7/widget/RecyclerView$LayoutManager;
    //   4: astore #11
    //   6: iconst_0
    //   7: istore #7
    //   9: aload #11
    //   11: ifnonnull -> 25
    //   14: ldc 'RecyclerView'
    //   16: ldc_w 'Cannot fling without a LayoutManager set. Call setLayoutManager with a non-null argument.'
    //   19: invokestatic e : (Ljava/lang/String;Ljava/lang/String;)I
    //   22: pop
    //   23: iconst_0
    //   24: ireturn
    //   25: aload_0
    //   26: getfield mLayoutFrozen : Z
    //   29: ifeq -> 34
    //   32: iconst_0
    //   33: ireturn
    //   34: aload #11
    //   36: invokevirtual canScrollHorizontally : ()Z
    //   39: istore #9
    //   41: aload_0
    //   42: getfield mLayout : Landroid/support/v7/widget/RecyclerView$LayoutManager;
    //   45: invokevirtual canScrollVertically : ()Z
    //   48: istore #10
    //   50: iload #9
    //   52: ifeq -> 69
    //   55: iload_1
    //   56: istore #5
    //   58: iload_1
    //   59: invokestatic abs : (I)I
    //   62: aload_0
    //   63: getfield mMinFlingVelocity : I
    //   66: if_icmpge -> 72
    //   69: iconst_0
    //   70: istore #5
    //   72: iload #10
    //   74: ifeq -> 91
    //   77: iload_2
    //   78: istore #6
    //   80: iload_2
    //   81: invokestatic abs : (I)I
    //   84: aload_0
    //   85: getfield mMinFlingVelocity : I
    //   88: if_icmpge -> 94
    //   91: iconst_0
    //   92: istore #6
    //   94: iload #5
    //   96: ifne -> 106
    //   99: iload #6
    //   101: ifne -> 106
    //   104: iconst_0
    //   105: ireturn
    //   106: iload #5
    //   108: i2f
    //   109: fstore_3
    //   110: iload #6
    //   112: i2f
    //   113: fstore #4
    //   115: aload_0
    //   116: fload_3
    //   117: fload #4
    //   119: invokevirtual dispatchNestedPreFling : (FF)Z
    //   122: ifne -> 260
    //   125: iload #9
    //   127: ifne -> 144
    //   130: iload #10
    //   132: ifeq -> 138
    //   135: goto -> 144
    //   138: iconst_0
    //   139: istore #8
    //   141: goto -> 147
    //   144: iconst_1
    //   145: istore #8
    //   147: aload_0
    //   148: fload_3
    //   149: fload #4
    //   151: iload #8
    //   153: invokevirtual dispatchNestedFling : (FFZ)Z
    //   156: pop
    //   157: aload_0
    //   158: getfield mOnFlingListener : Landroid/support/v7/widget/RecyclerView$OnFlingListener;
    //   161: astore #11
    //   163: aload #11
    //   165: ifnull -> 182
    //   168: aload #11
    //   170: iload #5
    //   172: iload #6
    //   174: invokevirtual onFling : (II)Z
    //   177: ifeq -> 182
    //   180: iconst_1
    //   181: ireturn
    //   182: iload #8
    //   184: ifeq -> 260
    //   187: iload #7
    //   189: istore_1
    //   190: iload #9
    //   192: ifeq -> 197
    //   195: iconst_1
    //   196: istore_1
    //   197: iload_1
    //   198: istore_2
    //   199: iload #10
    //   201: ifeq -> 208
    //   204: iload_1
    //   205: iconst_2
    //   206: ior
    //   207: istore_2
    //   208: aload_0
    //   209: iload_2
    //   210: iconst_1
    //   211: invokevirtual startNestedScroll : (II)Z
    //   214: pop
    //   215: aload_0
    //   216: getfield mMaxFlingVelocity : I
    //   219: istore_1
    //   220: iload_1
    //   221: ineg
    //   222: iload #5
    //   224: iload_1
    //   225: invokestatic min : (II)I
    //   228: invokestatic max : (II)I
    //   231: istore_1
    //   232: aload_0
    //   233: getfield mMaxFlingVelocity : I
    //   236: istore_2
    //   237: iload_2
    //   238: ineg
    //   239: iload #6
    //   241: iload_2
    //   242: invokestatic min : (II)I
    //   245: invokestatic max : (II)I
    //   248: istore_2
    //   249: aload_0
    //   250: getfield mViewFlinger : Landroid/support/v7/widget/RecyclerView$ViewFlinger;
    //   253: iload_1
    //   254: iload_2
    //   255: invokevirtual fling : (II)V
    //   258: iconst_1
    //   259: ireturn
    //   260: iconst_0
    //   261: ireturn }
  
  public View focusSearch(View paramView, int paramInt) {
    int i;
    View view2 = this.mLayout.onInterceptFocusSearch(paramView, paramInt);
    if (view2 != null)
      return view2; 
    if (this.mAdapter != null && this.mLayout != null && !isComputingLayout() && !this.mLayoutFrozen) {
      i = 1;
    } else {
      i = 0;
    } 
    View view1 = FocusFinder.getInstance();
    if (i && (paramInt == 2 || paramInt == 1)) {
      if (this.mLayout.canScrollVertically()) {
        byte b1;
        int k;
        if (paramInt == 2) {
          k = 130;
        } else {
          k = 33;
        } 
        if (view1.findNextFocus(this, paramView, k) == null) {
          b1 = 1;
        } else {
          b1 = 0;
        } 
        i = b1;
        if (FORCE_ABS_FOCUS_SEARCH_DIRECTION) {
          paramInt = k;
          i = b1;
        } 
      } else {
        i = 0;
      } 
      byte b = i;
      int j = paramInt;
      if (i == 0) {
        b = i;
        j = paramInt;
        if (this.mLayout.canScrollHorizontally()) {
          byte b1;
          if (this.mLayout.getLayoutDirection() == 1) {
            i = 1;
          } else {
            i = 0;
          } 
          if (paramInt == 2) {
            b1 = 1;
          } else {
            b1 = 0;
          } 
          if ((i ^ b1) != 0) {
            i = 66;
          } else {
            i = 17;
          } 
          if (view1.findNextFocus(this, paramView, i) == null) {
            b1 = 1;
          } else {
            b1 = 0;
          } 
          b = b1;
          j = paramInt;
          if (FORCE_ABS_FOCUS_SEARCH_DIRECTION) {
            j = i;
            b = b1;
          } 
        } 
      } 
      if (b != 0) {
        consumePendingUpdateOperations();
        if (findContainingItemView(paramView) == null)
          return null; 
        startInterceptRequestLayout();
        this.mLayout.onFocusSearchFailed(paramView, j, this.mRecycler, this.mState);
        stopInterceptRequestLayout(false);
      } 
      view1 = view1.findNextFocus(this, paramView, j);
      paramInt = j;
    } else {
      view1 = view1.findNextFocus(this, paramView, paramInt);
      if (view1 == null && i != 0) {
        consumePendingUpdateOperations();
        if (findContainingItemView(paramView) == null)
          return null; 
        startInterceptRequestLayout();
        view1 = this.mLayout.onFocusSearchFailed(paramView, paramInt, this.mRecycler, this.mState);
        stopInterceptRequestLayout(false);
      } 
    } 
    if (view1 != null && !view1.hasFocusable()) {
      if (getFocusedChild() == null)
        return super.focusSearch(paramView, paramInt); 
      requestChildOnScreen(view1, null);
      return paramView;
    } 
    return isPreferredNextFocus(paramView, view1, paramInt) ? view1 : super.focusSearch(paramView, paramInt);
  }
  
  protected ViewGroup.LayoutParams generateDefaultLayoutParams() {
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null)
      return layoutManager.generateDefaultLayoutParams(); 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("RecyclerView has no LayoutManager");
    stringBuilder.append(exceptionLabel());
    throw new IllegalStateException(stringBuilder.toString());
  }
  
  public ViewGroup.LayoutParams generateLayoutParams(AttributeSet paramAttributeSet) {
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null)
      return layoutManager.generateLayoutParams(getContext(), paramAttributeSet); 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("RecyclerView has no LayoutManager");
    stringBuilder.append(exceptionLabel());
    throw new IllegalStateException(stringBuilder.toString());
  }
  
  protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams paramLayoutParams) {
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null)
      return layoutManager.generateLayoutParams(paramLayoutParams); 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("RecyclerView has no LayoutManager");
    stringBuilder.append(exceptionLabel());
    throw new IllegalStateException(stringBuilder.toString());
  }
  
  @Nullable
  public Adapter getAdapter() { return this.mAdapter; }
  
  int getAdapterPositionFor(ViewHolder paramViewHolder) { return (paramViewHolder.hasAnyOfTheFlags(524) || !paramViewHolder.isBound()) ? -1 : this.mAdapterHelper.applyPendingUpdatesToPosition(paramViewHolder.mPosition); }
  
  public int getBaseline() {
    LayoutManager layoutManager = this.mLayout;
    return (layoutManager != null) ? layoutManager.getBaseline() : super.getBaseline();
  }
  
  long getChangedHolderKey(ViewHolder paramViewHolder) { return this.mAdapter.hasStableIds() ? paramViewHolder.getItemId() : paramViewHolder.mPosition; }
  
  public int getChildAdapterPosition(@NonNull View paramView) {
    ViewHolder viewHolder = getChildViewHolderInt(paramView);
    return (viewHolder != null) ? viewHolder.getAdapterPosition() : -1;
  }
  
  protected int getChildDrawingOrder(int paramInt1, int paramInt2) {
    ChildDrawingOrderCallback childDrawingOrderCallback = this.mChildDrawingOrderCallback;
    return (childDrawingOrderCallback == null) ? super.getChildDrawingOrder(paramInt1, paramInt2) : childDrawingOrderCallback.onGetChildDrawingOrder(paramInt1, paramInt2);
  }
  
  public long getChildItemId(@NonNull View paramView) {
    Adapter adapter = this.mAdapter;
    long l2 = -1L;
    long l1 = l2;
    if (adapter != null) {
      if (!adapter.hasStableIds())
        return -1L; 
      ViewHolder viewHolder = getChildViewHolderInt(paramView);
      l1 = l2;
      if (viewHolder != null)
        l1 = viewHolder.getItemId(); 
    } 
    return l1;
  }
  
  public int getChildLayoutPosition(@NonNull View paramView) {
    ViewHolder viewHolder = getChildViewHolderInt(paramView);
    return (viewHolder != null) ? viewHolder.getLayoutPosition() : -1;
  }
  
  @Deprecated
  public int getChildPosition(@NonNull View paramView) { return getChildAdapterPosition(paramView); }
  
  public ViewHolder getChildViewHolder(@NonNull View paramView) {
    ViewParent viewParent = paramView.getParent();
    if (viewParent == null || viewParent == this)
      return getChildViewHolderInt(paramView); 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("View ");
    stringBuilder.append(paramView);
    stringBuilder.append(" is not a direct child of ");
    stringBuilder.append(this);
    throw new IllegalArgumentException(stringBuilder.toString());
  }
  
  public boolean getClipToPadding() { return this.mClipToPadding; }
  
  @Nullable
  public RecyclerViewAccessibilityDelegate getCompatAccessibilityDelegate() { return this.mAccessibilityDelegate; }
  
  public void getDecoratedBoundsWithMargins(@NonNull View paramView, @NonNull Rect paramRect) { getDecoratedBoundsWithMarginsInt(paramView, paramRect); }
  
  @NonNull
  public EdgeEffectFactory getEdgeEffectFactory() { return this.mEdgeEffectFactory; }
  
  @Nullable
  public ItemAnimator getItemAnimator() { return this.mItemAnimator; }
  
  Rect getItemDecorInsetsForChild(View paramView) {
    LayoutParams layoutParams = (LayoutParams)paramView.getLayoutParams();
    if (!layoutParams.mInsetsDirty)
      return layoutParams.mDecorInsets; 
    if (this.mState.isPreLayout() && (layoutParams.isItemChanged() || layoutParams.isViewInvalid()))
      return layoutParams.mDecorInsets; 
    Rect rect = layoutParams.mDecorInsets;
    rect.set(0, 0, 0, 0);
    int i = this.mItemDecorations.size();
    for (byte b = 0; b < i; b++) {
      this.mTempRect.set(0, 0, 0, 0);
      ((ItemDecoration)this.mItemDecorations.get(b)).getItemOffsets(this.mTempRect, paramView, this, this.mState);
      rect.left += this.mTempRect.left;
      rect.top += this.mTempRect.top;
      rect.right += this.mTempRect.right;
      rect.bottom += this.mTempRect.bottom;
    } 
    layoutParams.mInsetsDirty = false;
    return rect;
  }
  
  @NonNull
  public ItemDecoration getItemDecorationAt(int paramInt) {
    int i = getItemDecorationCount();
    if (paramInt >= 0 && paramInt < i)
      return (ItemDecoration)this.mItemDecorations.get(paramInt); 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(paramInt);
    stringBuilder.append(" is an invalid index for size ");
    stringBuilder.append(i);
    throw new IndexOutOfBoundsException(stringBuilder.toString());
  }
  
  public int getItemDecorationCount() { return this.mItemDecorations.size(); }
  
  @Nullable
  public LayoutManager getLayoutManager() { return this.mLayout; }
  
  public int getMaxFlingVelocity() { return this.mMaxFlingVelocity; }
  
  public int getMinFlingVelocity() { return this.mMinFlingVelocity; }
  
  long getNanoTime() { return ALLOW_THREAD_GAP_WORK ? System.nanoTime() : 0L; }
  
  @Nullable
  public OnFlingListener getOnFlingListener() { return this.mOnFlingListener; }
  
  public boolean getPreserveFocusAfterLayout() { return this.mPreserveFocusAfterLayout; }
  
  @NonNull
  public RecycledViewPool getRecycledViewPool() { return this.mRecycler.getRecycledViewPool(); }
  
  public int getScrollState() { return this.mScrollState; }
  
  public boolean hasFixedSize() { return this.mHasFixedSize; }
  
  public boolean hasNestedScrollingParent() { return getScrollingChildHelper().hasNestedScrollingParent(); }
  
  public boolean hasNestedScrollingParent(int paramInt) { return getScrollingChildHelper().hasNestedScrollingParent(paramInt); }
  
  public boolean hasPendingAdapterUpdates() { return (!this.mFirstLayoutComplete || this.mDataSetHasChangedAfterLayout || this.mAdapterHelper.hasPendingUpdates()); }
  
  void initAdapterManager() { this.mAdapterHelper = new AdapterHelper(new Object(this)); }
  
  @VisibleForTesting
  void initFastScroller(StateListDrawable paramStateListDrawable1, Drawable paramDrawable1, StateListDrawable paramStateListDrawable2, Drawable paramDrawable2) {
    if (paramStateListDrawable1 != null && paramDrawable1 != null && paramStateListDrawable2 != null && paramDrawable2 != null) {
      Resources resources = getContext().getResources();
      new FastScroller(this, paramStateListDrawable1, paramDrawable1, paramStateListDrawable2, paramDrawable2, resources.getDimensionPixelSize(R.dimen.fastscroll_default_thickness), resources.getDimensionPixelSize(R.dimen.fastscroll_minimum_range), resources.getDimensionPixelOffset(R.dimen.fastscroll_margin));
      return;
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("Trying to set fast scroller without both required drawables.");
    stringBuilder.append(exceptionLabel());
    throw new IllegalArgumentException(stringBuilder.toString());
  }
  
  void invalidateGlows() {
    this.mBottomGlow = null;
    this.mTopGlow = null;
    this.mRightGlow = null;
    this.mLeftGlow = null;
  }
  
  public void invalidateItemDecorations() {
    if (this.mItemDecorations.size() == 0)
      return; 
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null)
      layoutManager.assertNotInLayoutOrScroll("Cannot invalidate item decorations during a scroll or layout"); 
    markItemDecorInsetsDirty();
    requestLayout();
  }
  
  boolean isAccessibilityEnabled() {
    AccessibilityManager accessibilityManager = this.mAccessibilityManager;
    return (accessibilityManager != null && accessibilityManager.isEnabled());
  }
  
  public boolean isAnimating() {
    ItemAnimator itemAnimator = this.mItemAnimator;
    return (itemAnimator != null && itemAnimator.isRunning());
  }
  
  public boolean isAttachedToWindow() { return this.mIsAttached; }
  
  public boolean isComputingLayout() { return (this.mLayoutOrScrollCounter > 0); }
  
  public boolean isLayoutFrozen() { return this.mLayoutFrozen; }
  
  public boolean isNestedScrollingEnabled() { return getScrollingChildHelper().isNestedScrollingEnabled(); }
  
  void jumpToPositionForSmoothScroller(int paramInt) {
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager == null)
      return; 
    layoutManager.scrollToPosition(paramInt);
    awakenScrollBars();
  }
  
  void markItemDecorInsetsDirty() {
    int i = this.mChildHelper.getUnfilteredChildCount();
    for (byte b = 0; b < i; b++)
      ((LayoutParams)this.mChildHelper.getUnfilteredChildAt(b).getLayoutParams()).mInsetsDirty = true; 
    this.mRecycler.markItemDecorInsetsDirty();
  }
  
  void markKnownViewsInvalid() {
    int i = this.mChildHelper.getUnfilteredChildCount();
    for (byte b = 0; b < i; b++) {
      ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getUnfilteredChildAt(b));
      if (viewHolder != null && !viewHolder.shouldIgnore())
        viewHolder.addFlags(6); 
    } 
    markItemDecorInsetsDirty();
    this.mRecycler.markKnownViewsInvalid();
  }
  
  public void offsetChildrenHorizontal(@Px int paramInt) {
    int i = this.mChildHelper.getChildCount();
    for (byte b = 0; b < i; b++)
      this.mChildHelper.getChildAt(b).offsetLeftAndRight(paramInt); 
  }
  
  public void offsetChildrenVertical(@Px int paramInt) {
    int i = this.mChildHelper.getChildCount();
    for (byte b = 0; b < i; b++)
      this.mChildHelper.getChildAt(b).offsetTopAndBottom(paramInt); 
  }
  
  void offsetPositionRecordsForInsert(int paramInt1, int paramInt2) {
    int i = this.mChildHelper.getUnfilteredChildCount();
    for (byte b = 0; b < i; b++) {
      ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getUnfilteredChildAt(b));
      if (viewHolder != null && !viewHolder.shouldIgnore() && viewHolder.mPosition >= paramInt1) {
        viewHolder.offsetPosition(paramInt2, false);
        this.mState.mStructureChanged = true;
      } 
    } 
    this.mRecycler.offsetPositionRecordsForInsert(paramInt1, paramInt2);
    requestLayout();
  }
  
  void offsetPositionRecordsForMove(int paramInt1, int paramInt2) {
    byte b1;
    int j;
    int i;
    int k = this.mChildHelper.getUnfilteredChildCount();
    if (paramInt1 < paramInt2) {
      i = paramInt1;
      j = paramInt2;
      b1 = -1;
    } else {
      j = paramInt1;
      i = paramInt2;
      b1 = 1;
    } 
    byte b2;
    for (b2 = 0; b2 < k; b2++) {
      ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getUnfilteredChildAt(b2));
      if (viewHolder != null && viewHolder.mPosition >= i && viewHolder.mPosition <= j) {
        if (viewHolder.mPosition == paramInt1) {
          viewHolder.offsetPosition(paramInt2 - paramInt1, false);
        } else {
          viewHolder.offsetPosition(b1, false);
        } 
        this.mState.mStructureChanged = true;
      } 
    } 
    this.mRecycler.offsetPositionRecordsForMove(paramInt1, paramInt2);
    requestLayout();
  }
  
  void offsetPositionRecordsForRemove(int paramInt1, int paramInt2, boolean paramBoolean) {
    int i = this.mChildHelper.getUnfilteredChildCount();
    byte b;
    for (b = 0; b < i; b++) {
      ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getUnfilteredChildAt(b));
      if (viewHolder != null && !viewHolder.shouldIgnore())
        if (viewHolder.mPosition >= paramInt1 + paramInt2) {
          viewHolder.offsetPosition(-paramInt2, paramBoolean);
          this.mState.mStructureChanged = true;
        } else if (viewHolder.mPosition >= paramInt1) {
          viewHolder.flagRemovedAndOffsetPosition(paramInt1 - 1, -paramInt2, paramBoolean);
          this.mState.mStructureChanged = true;
        }  
    } 
    this.mRecycler.offsetPositionRecordsForRemove(paramInt1, paramInt2, paramBoolean);
    requestLayout();
  }
  
  protected void onAttachedToWindow() { // Byte code:
    //   0: aload_0
    //   1: invokespecial onAttachedToWindow : ()V
    //   4: aload_0
    //   5: iconst_0
    //   6: putfield mLayoutOrScrollCounter : I
    //   9: iconst_1
    //   10: istore_2
    //   11: aload_0
    //   12: iconst_1
    //   13: putfield mIsAttached : Z
    //   16: aload_0
    //   17: getfield mFirstLayoutComplete : Z
    //   20: ifeq -> 33
    //   23: aload_0
    //   24: invokevirtual isLayoutRequested : ()Z
    //   27: ifne -> 33
    //   30: goto -> 35
    //   33: iconst_0
    //   34: istore_2
    //   35: aload_0
    //   36: iload_2
    //   37: putfield mFirstLayoutComplete : Z
    //   40: aload_0
    //   41: getfield mLayout : Landroid/support/v7/widget/RecyclerView$LayoutManager;
    //   44: astore_3
    //   45: aload_3
    //   46: ifnull -> 54
    //   49: aload_3
    //   50: aload_0
    //   51: invokevirtual dispatchAttachedToWindow : (Landroid/support/v7/widget/RecyclerView;)V
    //   54: aload_0
    //   55: iconst_0
    //   56: putfield mPostedAnimatorRunner : Z
    //   59: getstatic android/support/v7/widget/RecyclerView.ALLOW_THREAD_GAP_WORK : Z
    //   62: ifeq -> 163
    //   65: aload_0
    //   66: getstatic android/support/v7/widget/GapWorker.sGapWorker : Ljava/lang/ThreadLocal;
    //   69: invokevirtual get : ()Ljava/lang/Object;
    //   72: checkcast android/support/v7/widget/GapWorker
    //   75: putfield mGapWorker : Landroid/support/v7/widget/GapWorker;
    //   78: aload_0
    //   79: getfield mGapWorker : Landroid/support/v7/widget/GapWorker;
    //   82: ifnonnull -> 155
    //   85: aload_0
    //   86: new android/support/v7/widget/GapWorker
    //   89: dup
    //   90: invokespecial <init> : ()V
    //   93: putfield mGapWorker : Landroid/support/v7/widget/GapWorker;
    //   96: aload_0
    //   97: invokestatic getDisplay : (Landroid/view/View;)Landroid/view/Display;
    //   100: astore_3
    //   101: aload_0
    //   102: invokevirtual isInEditMode : ()Z
    //   105: ifne -> 128
    //   108: aload_3
    //   109: ifnull -> 128
    //   112: aload_3
    //   113: invokevirtual getRefreshRate : ()F
    //   116: fstore_1
    //   117: fload_1
    //   118: ldc_w 30.0
    //   121: fcmpl
    //   122: iflt -> 128
    //   125: goto -> 132
    //   128: ldc_w 60.0
    //   131: fstore_1
    //   132: aload_0
    //   133: getfield mGapWorker : Landroid/support/v7/widget/GapWorker;
    //   136: ldc_w 1.0E9
    //   139: fload_1
    //   140: fdiv
    //   141: f2l
    //   142: putfield mFrameIntervalNs : J
    //   145: getstatic android/support/v7/widget/GapWorker.sGapWorker : Ljava/lang/ThreadLocal;
    //   148: aload_0
    //   149: getfield mGapWorker : Landroid/support/v7/widget/GapWorker;
    //   152: invokevirtual set : (Ljava/lang/Object;)V
    //   155: aload_0
    //   156: getfield mGapWorker : Landroid/support/v7/widget/GapWorker;
    //   159: aload_0
    //   160: invokevirtual add : (Landroid/support/v7/widget/RecyclerView;)V
    //   163: return }
  
  public void onChildAttachedToWindow(@NonNull View paramView) {}
  
  public void onChildDetachedFromWindow(@NonNull View paramView) {}
  
  protected void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    ItemAnimator itemAnimator = this.mItemAnimator;
    if (itemAnimator != null)
      itemAnimator.endAnimations(); 
    stopScroll();
    this.mIsAttached = false;
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null)
      layoutManager.dispatchDetachedFromWindow(this, this.mRecycler); 
    this.mPendingAccessibilityImportanceChange.clear();
    removeCallbacks(this.mItemAnimatorRunner);
    this.mViewInfoStore.onDetach();
    if (ALLOW_THREAD_GAP_WORK) {
      GapWorker gapWorker = this.mGapWorker;
      if (gapWorker != null) {
        gapWorker.remove(this);
        this.mGapWorker = null;
      } 
    } 
  }
  
  public void onDraw(Canvas paramCanvas) {
    super.onDraw(paramCanvas);
    int i = this.mItemDecorations.size();
    for (byte b = 0; b < i; b++)
      ((ItemDecoration)this.mItemDecorations.get(b)).onDraw(paramCanvas, this, this.mState); 
  }
  
  void onEnterLayoutOrScroll() { this.mLayoutOrScrollCounter++; }
  
  void onExitLayoutOrScroll() { onExitLayoutOrScroll(true); }
  
  void onExitLayoutOrScroll(boolean paramBoolean) {
    this.mLayoutOrScrollCounter--;
    if (this.mLayoutOrScrollCounter < 1) {
      this.mLayoutOrScrollCounter = 0;
      if (paramBoolean) {
        dispatchContentChangedIfNecessary();
        dispatchPendingImportantForAccessibilityChanges();
      } 
    } 
  }
  
  public boolean onGenericMotionEvent(MotionEvent paramMotionEvent) { // Byte code:
    //   0: aload_0
    //   1: getfield mLayout : Landroid/support/v7/widget/RecyclerView$LayoutManager;
    //   4: ifnonnull -> 9
    //   7: iconst_0
    //   8: ireturn
    //   9: aload_0
    //   10: getfield mLayoutFrozen : Z
    //   13: ifeq -> 18
    //   16: iconst_0
    //   17: ireturn
    //   18: aload_1
    //   19: invokevirtual getAction : ()I
    //   22: bipush #8
    //   24: if_icmpne -> 172
    //   27: aload_1
    //   28: invokevirtual getSource : ()I
    //   31: iconst_2
    //   32: iand
    //   33: ifeq -> 87
    //   36: aload_0
    //   37: getfield mLayout : Landroid/support/v7/widget/RecyclerView$LayoutManager;
    //   40: invokevirtual canScrollVertically : ()Z
    //   43: ifeq -> 57
    //   46: aload_1
    //   47: bipush #9
    //   49: invokevirtual getAxisValue : (I)F
    //   52: fneg
    //   53: fstore_3
    //   54: goto -> 59
    //   57: fconst_0
    //   58: fstore_3
    //   59: fload_3
    //   60: fstore_2
    //   61: aload_0
    //   62: getfield mLayout : Landroid/support/v7/widget/RecyclerView$LayoutManager;
    //   65: invokevirtual canScrollHorizontally : ()Z
    //   68: ifeq -> 138
    //   71: aload_1
    //   72: bipush #10
    //   74: invokevirtual getAxisValue : (I)F
    //   77: fstore #4
    //   79: fload_3
    //   80: fstore_2
    //   81: fload #4
    //   83: fstore_3
    //   84: goto -> 140
    //   87: aload_1
    //   88: invokevirtual getSource : ()I
    //   91: ldc_w 4194304
    //   94: iand
    //   95: ifeq -> 136
    //   98: aload_1
    //   99: bipush #26
    //   101: invokevirtual getAxisValue : (I)F
    //   104: fstore_3
    //   105: aload_0
    //   106: getfield mLayout : Landroid/support/v7/widget/RecyclerView$LayoutManager;
    //   109: invokevirtual canScrollVertically : ()Z
    //   112: ifeq -> 121
    //   115: fload_3
    //   116: fneg
    //   117: fstore_2
    //   118: goto -> 138
    //   121: aload_0
    //   122: getfield mLayout : Landroid/support/v7/widget/RecyclerView$LayoutManager;
    //   125: invokevirtual canScrollHorizontally : ()Z
    //   128: ifeq -> 136
    //   131: fconst_0
    //   132: fstore_2
    //   133: goto -> 140
    //   136: fconst_0
    //   137: fstore_2
    //   138: fconst_0
    //   139: fstore_3
    //   140: fload_2
    //   141: fconst_0
    //   142: fcmpl
    //   143: ifne -> 152
    //   146: fload_3
    //   147: fconst_0
    //   148: fcmpl
    //   149: ifeq -> 172
    //   152: aload_0
    //   153: fload_3
    //   154: aload_0
    //   155: getfield mScaledHorizontalScrollFactor : F
    //   158: fmul
    //   159: f2i
    //   160: fload_2
    //   161: aload_0
    //   162: getfield mScaledVerticalScrollFactor : F
    //   165: fmul
    //   166: f2i
    //   167: aload_1
    //   168: invokevirtual scrollByInternal : (IILandroid/view/MotionEvent;)Z
    //   171: pop
    //   172: iconst_0
    //   173: ireturn }
  
  public boolean onInterceptTouchEvent(MotionEvent paramMotionEvent) {
    StringBuilder stringBuilder;
    boolean bool2 = this.mLayoutFrozen;
    boolean bool1 = false;
    if (bool2)
      return false; 
    if (dispatchOnItemTouchIntercept(paramMotionEvent)) {
      cancelTouch();
      return true;
    } 
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager == null)
      return false; 
    bool2 = layoutManager.canScrollHorizontally();
    boolean bool3 = this.mLayout.canScrollVertically();
    if (this.mVelocityTracker == null)
      this.mVelocityTracker = VelocityTracker.obtain(); 
    this.mVelocityTracker.addMovement(paramMotionEvent);
    int j = paramMotionEvent.getActionMasked();
    int i = paramMotionEvent.getActionIndex();
    if (j != 0) {
      if (j != 1) {
        if (j != 2) {
          if (j != 3) {
            if (j != 5) {
              if (j == 6)
                onPointerUp(paramMotionEvent); 
            } else {
              this.mScrollPointerId = paramMotionEvent.getPointerId(i);
              j = (int)(paramMotionEvent.getX(i) + 0.5F);
              this.mLastTouchX = j;
              this.mInitialTouchX = j;
              i = (int)(paramMotionEvent.getY(i) + 0.5F);
              this.mLastTouchY = i;
              this.mInitialTouchY = i;
            } 
          } else {
            cancelTouch();
          } 
        } else {
          j = paramMotionEvent.findPointerIndex(this.mScrollPointerId);
          if (j < 0) {
            stringBuilder = new StringBuilder();
            stringBuilder.append("Error processing scroll; pointer index for id ");
            stringBuilder.append(this.mScrollPointerId);
            stringBuilder.append(" not found. Did any MotionEvents get skipped?");
            Log.e("RecyclerView", stringBuilder.toString());
            return false;
          } 
          i = (int)(stringBuilder.getX(j) + 0.5F);
          int k = (int)(stringBuilder.getY(j) + 0.5F);
          if (this.mScrollState != 1) {
            j = this.mInitialTouchX;
            int m = this.mInitialTouchY;
            if (bool2 && Math.abs(i - j) > this.mTouchSlop) {
              this.mLastTouchX = i;
              i = 1;
            } else {
              i = 0;
            } 
            j = i;
            if (bool3) {
              j = i;
              if (Math.abs(k - m) > this.mTouchSlop) {
                this.mLastTouchY = k;
                j = 1;
              } 
            } 
            if (j != 0)
              setScrollState(1); 
          } 
        } 
      } else {
        this.mVelocityTracker.clear();
        stopNestedScroll(0);
      } 
    } else {
      if (this.mIgnoreMotionEventTillDown)
        this.mIgnoreMotionEventTillDown = false; 
      this.mScrollPointerId = stringBuilder.getPointerId(0);
      i = (int)(stringBuilder.getX() + 0.5F);
      this.mLastTouchX = i;
      this.mInitialTouchX = i;
      i = (int)(stringBuilder.getY() + 0.5F);
      this.mLastTouchY = i;
      this.mInitialTouchY = i;
      if (this.mScrollState == 2) {
        getParent().requestDisallowInterceptTouchEvent(true);
        setScrollState(1);
      } 
      int[] arrayOfInt = this.mNestedOffsets;
      arrayOfInt[1] = 0;
      arrayOfInt[0] = 0;
      if (bool2) {
        i = 1;
      } else {
        i = 0;
      } 
      j = i;
      if (bool3)
        j = i | 0x2; 
      startNestedScroll(j, 0);
    } 
    if (this.mScrollState == 1)
      bool1 = true; 
    return bool1;
  }
  
  protected void onLayout(boolean paramBoolean, int paramInt1, int paramInt2, int paramInt3, int paramInt4) {
    TraceCompat.beginSection("RV OnLayout");
    dispatchLayout();
    TraceCompat.endSection();
    this.mFirstLayoutComplete = true;
  }
  
  protected void onMeasure(int paramInt1, int paramInt2) {
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager == null) {
      defaultOnMeasure(paramInt1, paramInt2);
      return;
    } 
    boolean bool = layoutManager.isAutoMeasureEnabled();
    byte b = 0;
    if (bool) {
      int i = View.MeasureSpec.getMode(paramInt1);
      int j = View.MeasureSpec.getMode(paramInt2);
      this.mLayout.onMeasure(this.mRecycler, this.mState, paramInt1, paramInt2);
      byte b1 = b;
      if (i == 1073741824) {
        b1 = b;
        if (j == 1073741824)
          b1 = 1; 
      } 
      if (b1 == 0) {
        if (this.mAdapter == null)
          return; 
        if (this.mState.mLayoutStep == 1)
          dispatchLayoutStep1(); 
        this.mLayout.setMeasureSpecs(paramInt1, paramInt2);
        this.mState.mIsMeasuring = true;
        dispatchLayoutStep2();
        this.mLayout.setMeasuredDimensionFromChildren(paramInt1, paramInt2);
        if (this.mLayout.shouldMeasureTwice()) {
          this.mLayout.setMeasureSpecs(View.MeasureSpec.makeMeasureSpec(getMeasuredWidth(), 1073741824), View.MeasureSpec.makeMeasureSpec(getMeasuredHeight(), 1073741824));
          this.mState.mIsMeasuring = true;
          dispatchLayoutStep2();
          this.mLayout.setMeasuredDimensionFromChildren(paramInt1, paramInt2);
          return;
        } 
      } else {
        return;
      } 
    } else {
      if (this.mHasFixedSize) {
        this.mLayout.onMeasure(this.mRecycler, this.mState, paramInt1, paramInt2);
        return;
      } 
      if (this.mAdapterUpdateDuringMeasure) {
        startInterceptRequestLayout();
        onEnterLayoutOrScroll();
        processAdapterUpdatesAndSetAnimationFlags();
        onExitLayoutOrScroll();
        if (this.mState.mRunPredictiveAnimations) {
          this.mState.mInPreLayout = true;
        } else {
          this.mAdapterHelper.consumeUpdatesInOnePass();
          this.mState.mInPreLayout = false;
        } 
        this.mAdapterUpdateDuringMeasure = false;
        stopInterceptRequestLayout(false);
      } else if (this.mState.mRunPredictiveAnimations) {
        setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());
        return;
      } 
      Adapter adapter = this.mAdapter;
      if (adapter != null) {
        this.mState.mItemCount = adapter.getItemCount();
      } else {
        this.mState.mItemCount = 0;
      } 
      startInterceptRequestLayout();
      this.mLayout.onMeasure(this.mRecycler, this.mState, paramInt1, paramInt2);
      stopInterceptRequestLayout(false);
      this.mState.mInPreLayout = false;
    } 
  }
  
  protected boolean onRequestFocusInDescendants(int paramInt, Rect paramRect) { return isComputingLayout() ? false : super.onRequestFocusInDescendants(paramInt, paramRect); }
  
  protected void onRestoreInstanceState(Parcelable paramParcelable) {
    if (!(paramParcelable instanceof SavedState)) {
      super.onRestoreInstanceState(paramParcelable);
      return;
    } 
    this.mPendingSavedState = (SavedState)paramParcelable;
    super.onRestoreInstanceState(this.mPendingSavedState.getSuperState());
    if (this.mLayout != null && this.mPendingSavedState.mLayoutState != null)
      this.mLayout.onRestoreInstanceState(this.mPendingSavedState.mLayoutState); 
  }
  
  protected Parcelable onSaveInstanceState() {
    SavedState savedState1 = new SavedState(super.onSaveInstanceState());
    SavedState savedState2 = this.mPendingSavedState;
    if (savedState2 != null) {
      savedState1.copyFrom(savedState2);
      return savedState1;
    } 
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null) {
      savedState1.mLayoutState = layoutManager.onSaveInstanceState();
      return savedState1;
    } 
    savedState1.mLayoutState = null;
    return savedState1;
  }
  
  public void onScrollStateChanged(int paramInt) {}
  
  public void onScrolled(@Px int paramInt1, @Px int paramInt2) {}
  
  protected void onSizeChanged(int paramInt1, int paramInt2, int paramInt3, int paramInt4) {
    super.onSizeChanged(paramInt1, paramInt2, paramInt3, paramInt4);
    if (paramInt1 != paramInt3 || paramInt2 != paramInt4)
      invalidateGlows(); 
  }
  
  public boolean onTouchEvent(MotionEvent paramMotionEvent) { // Byte code:
    //   0: aload_0
    //   1: getfield mLayoutFrozen : Z
    //   4: istore #14
    //   6: iconst_0
    //   7: istore #10
    //   9: iload #14
    //   11: ifne -> 1004
    //   14: aload_0
    //   15: getfield mIgnoreMotionEventTillDown : Z
    //   18: ifeq -> 23
    //   21: iconst_0
    //   22: ireturn
    //   23: aload_0
    //   24: aload_1
    //   25: invokespecial dispatchOnItemTouch : (Landroid/view/MotionEvent;)Z
    //   28: ifeq -> 37
    //   31: aload_0
    //   32: invokespecial cancelTouch : ()V
    //   35: iconst_1
    //   36: ireturn
    //   37: aload_0
    //   38: getfield mLayout : Landroid/support/v7/widget/RecyclerView$LayoutManager;
    //   41: astore #16
    //   43: aload #16
    //   45: ifnonnull -> 50
    //   48: iconst_0
    //   49: ireturn
    //   50: aload #16
    //   52: invokevirtual canScrollHorizontally : ()Z
    //   55: istore #14
    //   57: aload_0
    //   58: getfield mLayout : Landroid/support/v7/widget/RecyclerView$LayoutManager;
    //   61: invokevirtual canScrollVertically : ()Z
    //   64: istore #15
    //   66: aload_0
    //   67: getfield mVelocityTracker : Landroid/view/VelocityTracker;
    //   70: ifnonnull -> 80
    //   73: aload_0
    //   74: invokestatic obtain : ()Landroid/view/VelocityTracker;
    //   77: putfield mVelocityTracker : Landroid/view/VelocityTracker;
    //   80: aload_1
    //   81: invokestatic obtain : (Landroid/view/MotionEvent;)Landroid/view/MotionEvent;
    //   84: astore #16
    //   86: aload_1
    //   87: invokevirtual getActionMasked : ()I
    //   90: istore #5
    //   92: aload_1
    //   93: invokevirtual getActionIndex : ()I
    //   96: istore #4
    //   98: iload #5
    //   100: ifne -> 119
    //   103: aload_0
    //   104: getfield mNestedOffsets : [I
    //   107: astore #17
    //   109: aload #17
    //   111: iconst_1
    //   112: iconst_0
    //   113: iastore
    //   114: aload #17
    //   116: iconst_0
    //   117: iconst_0
    //   118: iastore
    //   119: aload_0
    //   120: getfield mNestedOffsets : [I
    //   123: astore #17
    //   125: aload #16
    //   127: aload #17
    //   129: iconst_0
    //   130: iaload
    //   131: i2f
    //   132: aload #17
    //   134: iconst_1
    //   135: iaload
    //   136: i2f
    //   137: invokevirtual offsetLocation : (FF)V
    //   140: iload #5
    //   142: ifeq -> 887
    //   145: iload #5
    //   147: iconst_1
    //   148: if_icmpeq -> 779
    //   151: iload #5
    //   153: iconst_2
    //   154: if_icmpeq -> 273
    //   157: iload #5
    //   159: iconst_3
    //   160: if_icmpeq -> 262
    //   163: iload #5
    //   165: iconst_5
    //   166: if_icmpeq -> 195
    //   169: iload #5
    //   171: bipush #6
    //   173: if_icmpeq -> 183
    //   176: iload #10
    //   178: istore #4
    //   180: goto -> 983
    //   183: aload_0
    //   184: aload_1
    //   185: invokespecial onPointerUp : (Landroid/view/MotionEvent;)V
    //   188: iload #10
    //   190: istore #4
    //   192: goto -> 983
    //   195: aload_0
    //   196: aload_1
    //   197: iload #4
    //   199: invokevirtual getPointerId : (I)I
    //   202: putfield mScrollPointerId : I
    //   205: aload_1
    //   206: iload #4
    //   208: invokevirtual getX : (I)F
    //   211: ldc_w 0.5
    //   214: fadd
    //   215: f2i
    //   216: istore #5
    //   218: aload_0
    //   219: iload #5
    //   221: putfield mLastTouchX : I
    //   224: aload_0
    //   225: iload #5
    //   227: putfield mInitialTouchX : I
    //   230: aload_1
    //   231: iload #4
    //   233: invokevirtual getY : (I)F
    //   236: ldc_w 0.5
    //   239: fadd
    //   240: f2i
    //   241: istore #4
    //   243: aload_0
    //   244: iload #4
    //   246: putfield mLastTouchY : I
    //   249: aload_0
    //   250: iload #4
    //   252: putfield mInitialTouchY : I
    //   255: iload #10
    //   257: istore #4
    //   259: goto -> 983
    //   262: aload_0
    //   263: invokespecial cancelTouch : ()V
    //   266: iload #10
    //   268: istore #4
    //   270: goto -> 983
    //   273: aload_1
    //   274: aload_0
    //   275: getfield mScrollPointerId : I
    //   278: invokevirtual findPointerIndex : (I)I
    //   281: istore #4
    //   283: iload #4
    //   285: ifge -> 333
    //   288: new java/lang/StringBuilder
    //   291: dup
    //   292: invokespecial <init> : ()V
    //   295: astore_1
    //   296: aload_1
    //   297: ldc_w 'Error processing scroll; pointer index for id '
    //   300: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   303: pop
    //   304: aload_1
    //   305: aload_0
    //   306: getfield mScrollPointerId : I
    //   309: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   312: pop
    //   313: aload_1
    //   314: ldc_w ' not found. Did any MotionEvents get skipped?'
    //   317: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   320: pop
    //   321: ldc 'RecyclerView'
    //   323: aload_1
    //   324: invokevirtual toString : ()Ljava/lang/String;
    //   327: invokestatic e : (Ljava/lang/String;Ljava/lang/String;)I
    //   330: pop
    //   331: iconst_0
    //   332: ireturn
    //   333: aload_1
    //   334: iload #4
    //   336: invokevirtual getX : (I)F
    //   339: ldc_w 0.5
    //   342: fadd
    //   343: f2i
    //   344: istore #11
    //   346: aload_1
    //   347: iload #4
    //   349: invokevirtual getY : (I)F
    //   352: ldc_w 0.5
    //   355: fadd
    //   356: f2i
    //   357: istore #12
    //   359: aload_0
    //   360: getfield mLastTouchX : I
    //   363: iload #11
    //   365: isub
    //   366: istore #7
    //   368: aload_0
    //   369: getfield mLastTouchY : I
    //   372: iload #12
    //   374: isub
    //   375: istore #6
    //   377: iload #7
    //   379: istore #5
    //   381: iload #6
    //   383: istore #4
    //   385: aload_0
    //   386: iload #7
    //   388: iload #6
    //   390: aload_0
    //   391: getfield mScrollConsumed : [I
    //   394: aload_0
    //   395: getfield mScrollOffset : [I
    //   398: iconst_0
    //   399: invokevirtual dispatchNestedPreScroll : (II[I[II)Z
    //   402: ifeq -> 481
    //   405: aload_0
    //   406: getfield mScrollConsumed : [I
    //   409: astore_1
    //   410: iload #7
    //   412: aload_1
    //   413: iconst_0
    //   414: iaload
    //   415: isub
    //   416: istore #5
    //   418: iload #6
    //   420: aload_1
    //   421: iconst_1
    //   422: iaload
    //   423: isub
    //   424: istore #4
    //   426: aload_0
    //   427: getfield mScrollOffset : [I
    //   430: astore_1
    //   431: aload #16
    //   433: aload_1
    //   434: iconst_0
    //   435: iaload
    //   436: i2f
    //   437: aload_1
    //   438: iconst_1
    //   439: iaload
    //   440: i2f
    //   441: invokevirtual offsetLocation : (FF)V
    //   444: aload_0
    //   445: getfield mNestedOffsets : [I
    //   448: astore_1
    //   449: aload_1
    //   450: iconst_0
    //   451: iaload
    //   452: istore #6
    //   454: aload_0
    //   455: getfield mScrollOffset : [I
    //   458: astore #17
    //   460: aload_1
    //   461: iconst_0
    //   462: iload #6
    //   464: aload #17
    //   466: iconst_0
    //   467: iaload
    //   468: iadd
    //   469: iastore
    //   470: aload_1
    //   471: iconst_1
    //   472: aload_1
    //   473: iconst_1
    //   474: iaload
    //   475: aload #17
    //   477: iconst_1
    //   478: iaload
    //   479: iadd
    //   480: iastore
    //   481: iload #5
    //   483: istore #6
    //   485: iload #4
    //   487: istore #7
    //   489: aload_0
    //   490: getfield mScrollState : I
    //   493: iconst_1
    //   494: if_icmpeq -> 645
    //   497: iload #14
    //   499: ifeq -> 550
    //   502: iload #5
    //   504: invokestatic abs : (I)I
    //   507: istore #6
    //   509: aload_0
    //   510: getfield mTouchSlop : I
    //   513: istore #7
    //   515: iload #6
    //   517: iload #7
    //   519: if_icmple -> 550
    //   522: iload #5
    //   524: ifle -> 537
    //   527: iload #5
    //   529: iload #7
    //   531: isub
    //   532: istore #5
    //   534: goto -> 544
    //   537: iload #5
    //   539: iload #7
    //   541: iadd
    //   542: istore #5
    //   544: iconst_1
    //   545: istore #6
    //   547: goto -> 553
    //   550: iconst_0
    //   551: istore #6
    //   553: iload #6
    //   555: istore #9
    //   557: iload #4
    //   559: istore #8
    //   561: iload #15
    //   563: ifeq -> 619
    //   566: iload #4
    //   568: invokestatic abs : (I)I
    //   571: istore #7
    //   573: aload_0
    //   574: getfield mTouchSlop : I
    //   577: istore #13
    //   579: iload #6
    //   581: istore #9
    //   583: iload #4
    //   585: istore #8
    //   587: iload #7
    //   589: iload #13
    //   591: if_icmple -> 619
    //   594: iload #4
    //   596: ifle -> 609
    //   599: iload #4
    //   601: iload #13
    //   603: isub
    //   604: istore #8
    //   606: goto -> 616
    //   609: iload #4
    //   611: iload #13
    //   613: iadd
    //   614: istore #8
    //   616: iconst_1
    //   617: istore #9
    //   619: iload #5
    //   621: istore #6
    //   623: iload #8
    //   625: istore #7
    //   627: iload #9
    //   629: ifeq -> 645
    //   632: aload_0
    //   633: iconst_1
    //   634: invokevirtual setScrollState : (I)V
    //   637: iload #8
    //   639: istore #7
    //   641: iload #5
    //   643: istore #6
    //   645: iload #10
    //   647: istore #4
    //   649: aload_0
    //   650: getfield mScrollState : I
    //   653: iconst_1
    //   654: if_icmpne -> 983
    //   657: aload_0
    //   658: getfield mScrollOffset : [I
    //   661: astore_1
    //   662: aload_0
    //   663: iload #11
    //   665: aload_1
    //   666: iconst_0
    //   667: iaload
    //   668: isub
    //   669: putfield mLastTouchX : I
    //   672: aload_0
    //   673: iload #12
    //   675: aload_1
    //   676: iconst_1
    //   677: iaload
    //   678: isub
    //   679: putfield mLastTouchY : I
    //   682: iload #14
    //   684: ifeq -> 694
    //   687: iload #6
    //   689: istore #4
    //   691: goto -> 697
    //   694: iconst_0
    //   695: istore #4
    //   697: iload #15
    //   699: ifeq -> 709
    //   702: iload #7
    //   704: istore #5
    //   706: goto -> 712
    //   709: iconst_0
    //   710: istore #5
    //   712: aload_0
    //   713: iload #4
    //   715: iload #5
    //   717: aload #16
    //   719: invokevirtual scrollByInternal : (IILandroid/view/MotionEvent;)Z
    //   722: ifeq -> 735
    //   725: aload_0
    //   726: invokevirtual getParent : ()Landroid/view/ViewParent;
    //   729: iconst_1
    //   730: invokeinterface requestDisallowInterceptTouchEvent : (Z)V
    //   735: iload #10
    //   737: istore #4
    //   739: aload_0
    //   740: getfield mGapWorker : Landroid/support/v7/widget/GapWorker;
    //   743: ifnull -> 983
    //   746: iload #6
    //   748: ifne -> 760
    //   751: iload #10
    //   753: istore #4
    //   755: iload #7
    //   757: ifeq -> 983
    //   760: aload_0
    //   761: getfield mGapWorker : Landroid/support/v7/widget/GapWorker;
    //   764: aload_0
    //   765: iload #6
    //   767: iload #7
    //   769: invokevirtual postFromTraversal : (Landroid/support/v7/widget/RecyclerView;II)V
    //   772: iload #10
    //   774: istore #4
    //   776: goto -> 983
    //   779: aload_0
    //   780: getfield mVelocityTracker : Landroid/view/VelocityTracker;
    //   783: aload #16
    //   785: invokevirtual addMovement : (Landroid/view/MotionEvent;)V
    //   788: aload_0
    //   789: getfield mVelocityTracker : Landroid/view/VelocityTracker;
    //   792: sipush #1000
    //   795: aload_0
    //   796: getfield mMaxFlingVelocity : I
    //   799: i2f
    //   800: invokevirtual computeCurrentVelocity : (IF)V
    //   803: iload #14
    //   805: ifeq -> 824
    //   808: aload_0
    //   809: getfield mVelocityTracker : Landroid/view/VelocityTracker;
    //   812: aload_0
    //   813: getfield mScrollPointerId : I
    //   816: invokevirtual getXVelocity : (I)F
    //   819: fneg
    //   820: fstore_2
    //   821: goto -> 826
    //   824: fconst_0
    //   825: fstore_2
    //   826: iload #15
    //   828: ifeq -> 847
    //   831: aload_0
    //   832: getfield mVelocityTracker : Landroid/view/VelocityTracker;
    //   835: aload_0
    //   836: getfield mScrollPointerId : I
    //   839: invokevirtual getYVelocity : (I)F
    //   842: fneg
    //   843: fstore_3
    //   844: goto -> 849
    //   847: fconst_0
    //   848: fstore_3
    //   849: fload_2
    //   850: fconst_0
    //   851: fcmpl
    //   852: ifne -> 861
    //   855: fload_3
    //   856: fconst_0
    //   857: fcmpl
    //   858: ifeq -> 872
    //   861: aload_0
    //   862: fload_2
    //   863: f2i
    //   864: fload_3
    //   865: f2i
    //   866: invokevirtual fling : (II)Z
    //   869: ifne -> 877
    //   872: aload_0
    //   873: iconst_0
    //   874: invokevirtual setScrollState : (I)V
    //   877: aload_0
    //   878: invokespecial resetTouch : ()V
    //   881: iconst_1
    //   882: istore #4
    //   884: goto -> 983
    //   887: aload_0
    //   888: aload_1
    //   889: iconst_0
    //   890: invokevirtual getPointerId : (I)I
    //   893: putfield mScrollPointerId : I
    //   896: aload_1
    //   897: invokevirtual getX : ()F
    //   900: ldc_w 0.5
    //   903: fadd
    //   904: f2i
    //   905: istore #4
    //   907: aload_0
    //   908: iload #4
    //   910: putfield mLastTouchX : I
    //   913: aload_0
    //   914: iload #4
    //   916: putfield mInitialTouchX : I
    //   919: aload_1
    //   920: invokevirtual getY : ()F
    //   923: ldc_w 0.5
    //   926: fadd
    //   927: f2i
    //   928: istore #4
    //   930: aload_0
    //   931: iload #4
    //   933: putfield mLastTouchY : I
    //   936: aload_0
    //   937: iload #4
    //   939: putfield mInitialTouchY : I
    //   942: iload #14
    //   944: ifeq -> 953
    //   947: iconst_1
    //   948: istore #4
    //   950: goto -> 956
    //   953: iconst_0
    //   954: istore #4
    //   956: iload #4
    //   958: istore #5
    //   960: iload #15
    //   962: ifeq -> 971
    //   965: iload #4
    //   967: iconst_2
    //   968: ior
    //   969: istore #5
    //   971: aload_0
    //   972: iload #5
    //   974: iconst_0
    //   975: invokevirtual startNestedScroll : (II)Z
    //   978: pop
    //   979: iload #10
    //   981: istore #4
    //   983: iload #4
    //   985: ifne -> 997
    //   988: aload_0
    //   989: getfield mVelocityTracker : Landroid/view/VelocityTracker;
    //   992: aload #16
    //   994: invokevirtual addMovement : (Landroid/view/MotionEvent;)V
    //   997: aload #16
    //   999: invokevirtual recycle : ()V
    //   1002: iconst_1
    //   1003: ireturn
    //   1004: iconst_0
    //   1005: ireturn }
  
  void postAnimationRunner() {
    if (!this.mPostedAnimatorRunner && this.mIsAttached) {
      ViewCompat.postOnAnimation(this, this.mItemAnimatorRunner);
      this.mPostedAnimatorRunner = true;
    } 
  }
  
  void processDataSetCompletelyChanged(boolean paramBoolean) {
    this.mDispatchItemsChangedEvent = paramBoolean | this.mDispatchItemsChangedEvent;
    this.mDataSetHasChangedAfterLayout = true;
    markKnownViewsInvalid();
  }
  
  void recordAnimationInfoIfBouncedHiddenView(ViewHolder paramViewHolder, ItemAnimator.ItemHolderInfo paramItemHolderInfo) {
    paramViewHolder.setFlags(0, 8192);
    if (this.mState.mTrackOldChangeHolders && paramViewHolder.isUpdated() && !paramViewHolder.isRemoved() && !paramViewHolder.shouldIgnore()) {
      long l = getChangedHolderKey(paramViewHolder);
      this.mViewInfoStore.addToOldChangeHolders(l, paramViewHolder);
    } 
    this.mViewInfoStore.addToPreLayout(paramViewHolder, paramItemHolderInfo);
  }
  
  void removeAndRecycleViews() {
    ItemAnimator itemAnimator = this.mItemAnimator;
    if (itemAnimator != null)
      itemAnimator.endAnimations(); 
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null) {
      layoutManager.removeAndRecycleAllViews(this.mRecycler);
      this.mLayout.removeAndRecycleScrapInt(this.mRecycler);
    } 
    this.mRecycler.clear();
  }
  
  boolean removeAnimatingView(View paramView) {
    startInterceptRequestLayout();
    boolean bool = this.mChildHelper.removeViewIfHidden(paramView);
    if (bool) {
      ViewHolder viewHolder = getChildViewHolderInt(paramView);
      this.mRecycler.unscrapView(viewHolder);
      this.mRecycler.recycleViewHolderInternal(viewHolder);
    } 
    stopInterceptRequestLayout(bool ^ true);
    return bool;
  }
  
  protected void removeDetachedView(View paramView, boolean paramBoolean) {
    StringBuilder stringBuilder;
    ViewHolder viewHolder = getChildViewHolderInt(paramView);
    if (viewHolder != null)
      if (viewHolder.isTmpDetached()) {
        viewHolder.clearTmpDetachFlag();
      } else if (!viewHolder.shouldIgnore()) {
        stringBuilder = new StringBuilder();
        stringBuilder.append("Called removeDetachedView with a view which is not flagged as tmp detached.");
        stringBuilder.append(viewHolder);
        stringBuilder.append(exceptionLabel());
        throw new IllegalArgumentException(stringBuilder.toString());
      }  
    stringBuilder.clearAnimation();
    dispatchChildDetached(stringBuilder);
    super.removeDetachedView(stringBuilder, paramBoolean);
  }
  
  public void removeItemDecoration(@NonNull ItemDecoration paramItemDecoration) {
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager != null)
      layoutManager.assertNotInLayoutOrScroll("Cannot remove item decoration during a scroll  or layout"); 
    this.mItemDecorations.remove(paramItemDecoration);
    if (this.mItemDecorations.isEmpty()) {
      boolean bool;
      if (getOverScrollMode() == 2) {
        bool = true;
      } else {
        bool = false;
      } 
      setWillNotDraw(bool);
    } 
    markItemDecorInsetsDirty();
    requestLayout();
  }
  
  public void removeItemDecorationAt(int paramInt) {
    int i = getItemDecorationCount();
    if (paramInt >= 0 && paramInt < i) {
      removeItemDecoration(getItemDecorationAt(paramInt));
      return;
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(paramInt);
    stringBuilder.append(" is an invalid index for size ");
    stringBuilder.append(i);
    throw new IndexOutOfBoundsException(stringBuilder.toString());
  }
  
  public void removeOnChildAttachStateChangeListener(@NonNull OnChildAttachStateChangeListener paramOnChildAttachStateChangeListener) {
    List list = this.mOnChildAttachStateListeners;
    if (list == null)
      return; 
    list.remove(paramOnChildAttachStateChangeListener);
  }
  
  public void removeOnItemTouchListener(@NonNull OnItemTouchListener paramOnItemTouchListener) {
    this.mOnItemTouchListeners.remove(paramOnItemTouchListener);
    if (this.mActiveOnItemTouchListener == paramOnItemTouchListener)
      this.mActiveOnItemTouchListener = null; 
  }
  
  public void removeOnScrollListener(@NonNull OnScrollListener paramOnScrollListener) {
    List list = this.mScrollListeners;
    if (list != null)
      list.remove(paramOnScrollListener); 
  }
  
  void repositionShadowingViews() {
    int i = this.mChildHelper.getChildCount();
    for (byte b = 0; b < i; b++) {
      View view = this.mChildHelper.getChildAt(b);
      ViewHolder viewHolder = getChildViewHolder(view);
      if (viewHolder != null && viewHolder.mShadowingHolder != null) {
        View view1 = viewHolder.mShadowingHolder.itemView;
        int j = view.getLeft();
        int k = view.getTop();
        if (j != view1.getLeft() || k != view1.getTop())
          view1.layout(j, k, view1.getWidth() + j, view1.getHeight() + k); 
      } 
    } 
  }
  
  public void requestChildFocus(View paramView1, View paramView2) {
    if (!this.mLayout.onRequestChildFocus(this, this.mState, paramView1, paramView2) && paramView2 != null)
      requestChildOnScreen(paramView1, paramView2); 
    super.requestChildFocus(paramView1, paramView2);
  }
  
  public boolean requestChildRectangleOnScreen(View paramView, Rect paramRect, boolean paramBoolean) { return this.mLayout.requestChildRectangleOnScreen(this, paramView, paramRect, paramBoolean); }
  
  public void requestDisallowInterceptTouchEvent(boolean paramBoolean) {
    int i = this.mOnItemTouchListeners.size();
    for (byte b = 0; b < i; b++)
      ((OnItemTouchListener)this.mOnItemTouchListeners.get(b)).onRequestDisallowInterceptTouchEvent(paramBoolean); 
    super.requestDisallowInterceptTouchEvent(paramBoolean);
  }
  
  public void requestLayout() {
    if (this.mInterceptRequestLayoutDepth == 0 && !this.mLayoutFrozen) {
      super.requestLayout();
      return;
    } 
    this.mLayoutWasDefered = true;
  }
  
  void saveOldPositions() {
    int i = this.mChildHelper.getUnfilteredChildCount();
    for (byte b = 0; b < i; b++) {
      ViewHolder viewHolder = getChildViewHolderInt(this.mChildHelper.getUnfilteredChildAt(b));
      if (!viewHolder.shouldIgnore())
        viewHolder.saveOldPosition(); 
    } 
  }
  
  public void scrollBy(int paramInt1, int paramInt2) {
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager == null) {
      Log.e("RecyclerView", "Cannot scroll without a LayoutManager set. Call setLayoutManager with a non-null argument.");
      return;
    } 
    if (this.mLayoutFrozen)
      return; 
    boolean bool1 = layoutManager.canScrollHorizontally();
    boolean bool2 = this.mLayout.canScrollVertically();
    if (bool1 || bool2) {
      if (!bool1)
        paramInt1 = 0; 
      if (!bool2)
        paramInt2 = 0; 
      scrollByInternal(paramInt1, paramInt2, null);
    } 
  }
  
  boolean scrollByInternal(int paramInt1, int paramInt2, MotionEvent paramMotionEvent) {
    byte b4;
    byte b3;
    byte b2;
    byte b1;
    int[] arrayOfInt;
    consumePendingUpdateOperations();
    Adapter adapter = this.mAdapter;
    boolean bool = false;
    if (adapter != null) {
      scrollStep(paramInt1, paramInt2, this.mScrollStepConsumed);
      int[] arrayOfInt1 = this.mScrollStepConsumed;
      b3 = arrayOfInt1[0];
      b4 = arrayOfInt1[1];
      b2 = b4;
      b1 = b3;
      b3 = paramInt1 - b3;
      b4 = paramInt2 - b4;
    } else {
      b2 = 0;
      b3 = 0;
      b4 = 0;
      b1 = 0;
    } 
    if (!this.mItemDecorations.isEmpty())
      invalidate(); 
    if (dispatchNestedScroll(b1, b2, b3, b4, this.mScrollOffset, 0)) {
      paramInt1 = this.mLastTouchX;
      int[] arrayOfInt1 = this.mScrollOffset;
      this.mLastTouchX = paramInt1 - arrayOfInt1[0];
      this.mLastTouchY -= arrayOfInt1[1];
      if (paramMotionEvent != null)
        paramMotionEvent.offsetLocation(arrayOfInt1[0], arrayOfInt1[1]); 
      arrayOfInt = this.mNestedOffsets;
      paramInt1 = arrayOfInt[0];
      arrayOfInt1 = this.mScrollOffset;
      arrayOfInt[0] = paramInt1 + arrayOfInt1[0];
      arrayOfInt[1] = arrayOfInt[1] + arrayOfInt1[1];
    } else if (getOverScrollMode() != 2) {
      if (arrayOfInt != null && !MotionEventCompat.isFromSource(arrayOfInt, 8194))
        pullGlows(arrayOfInt.getX(), b3, arrayOfInt.getY(), b4); 
      considerReleasingGlowsOnScroll(paramInt1, paramInt2);
    } 
    if (b1 != 0 || b2 != 0)
      dispatchOnScrolled(b1, b2); 
    if (!awakenScrollBars())
      invalidate(); 
    if (b1 != 0 || b2 != 0)
      bool = true; 
    return bool;
  }
  
  void scrollStep(int paramInt1, int paramInt2, @Nullable int[] paramArrayOfInt) {
    startInterceptRequestLayout();
    onEnterLayoutOrScroll();
    TraceCompat.beginSection("RV Scroll");
    fillRemainingScrollValues(this.mState);
    if (paramInt1 != 0) {
      paramInt1 = this.mLayout.scrollHorizontallyBy(paramInt1, this.mRecycler, this.mState);
    } else {
      paramInt1 = 0;
    } 
    if (paramInt2 != 0) {
      paramInt2 = this.mLayout.scrollVerticallyBy(paramInt2, this.mRecycler, this.mState);
    } else {
      paramInt2 = 0;
    } 
    TraceCompat.endSection();
    repositionShadowingViews();
    onExitLayoutOrScroll();
    stopInterceptRequestLayout(false);
    if (paramArrayOfInt != null) {
      paramArrayOfInt[0] = paramInt1;
      paramArrayOfInt[1] = paramInt2;
    } 
  }
  
  public void scrollTo(int paramInt1, int paramInt2) { Log.w("RecyclerView", "RecyclerView does not support scrolling to an absolute position. Use scrollToPosition instead"); }
  
  public void scrollToPosition(int paramInt) {
    if (this.mLayoutFrozen)
      return; 
    stopScroll();
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager == null) {
      Log.e("RecyclerView", "Cannot scroll to position a LayoutManager set. Call setLayoutManager with a non-null argument.");
      return;
    } 
    layoutManager.scrollToPosition(paramInt);
    awakenScrollBars();
  }
  
  public void sendAccessibilityEventUnchecked(AccessibilityEvent paramAccessibilityEvent) {
    if (shouldDeferAccessibilityEvent(paramAccessibilityEvent))
      return; 
    super.sendAccessibilityEventUnchecked(paramAccessibilityEvent);
  }
  
  public void setAccessibilityDelegateCompat(@Nullable RecyclerViewAccessibilityDelegate paramRecyclerViewAccessibilityDelegate) {
    this.mAccessibilityDelegate = paramRecyclerViewAccessibilityDelegate;
    ViewCompat.setAccessibilityDelegate(this, this.mAccessibilityDelegate);
  }
  
  public void setAdapter(@Nullable Adapter paramAdapter) {
    setLayoutFrozen(false);
    setAdapterInternal(paramAdapter, false, true);
    processDataSetCompletelyChanged(false);
    requestLayout();
  }
  
  public void setChildDrawingOrderCallback(@Nullable ChildDrawingOrderCallback paramChildDrawingOrderCallback) {
    boolean bool;
    if (paramChildDrawingOrderCallback == this.mChildDrawingOrderCallback)
      return; 
    this.mChildDrawingOrderCallback = paramChildDrawingOrderCallback;
    if (this.mChildDrawingOrderCallback != null) {
      bool = true;
    } else {
      bool = false;
    } 
    setChildrenDrawingOrderEnabled(bool);
  }
  
  @VisibleForTesting
  boolean setChildImportantForAccessibilityInternal(ViewHolder paramViewHolder, int paramInt) {
    if (isComputingLayout()) {
      paramViewHolder.mPendingAccessibilityState = paramInt;
      this.mPendingAccessibilityImportanceChange.add(paramViewHolder);
      return false;
    } 
    ViewCompat.setImportantForAccessibility(paramViewHolder.itemView, paramInt);
    return true;
  }
  
  public void setClipToPadding(boolean paramBoolean) {
    if (paramBoolean != this.mClipToPadding)
      invalidateGlows(); 
    this.mClipToPadding = paramBoolean;
    super.setClipToPadding(paramBoolean);
    if (this.mFirstLayoutComplete)
      requestLayout(); 
  }
  
  public void setEdgeEffectFactory(@NonNull EdgeEffectFactory paramEdgeEffectFactory) {
    Preconditions.checkNotNull(paramEdgeEffectFactory);
    this.mEdgeEffectFactory = paramEdgeEffectFactory;
    invalidateGlows();
  }
  
  public void setHasFixedSize(boolean paramBoolean) { this.mHasFixedSize = paramBoolean; }
  
  public void setItemAnimator(@Nullable ItemAnimator paramItemAnimator) {
    ItemAnimator itemAnimator = this.mItemAnimator;
    if (itemAnimator != null) {
      itemAnimator.endAnimations();
      this.mItemAnimator.setListener(null);
    } 
    this.mItemAnimator = paramItemAnimator;
    paramItemAnimator = this.mItemAnimator;
    if (paramItemAnimator != null)
      paramItemAnimator.setListener(this.mItemAnimatorListener); 
  }
  
  public void setItemViewCacheSize(int paramInt) { this.mRecycler.setViewCacheSize(paramInt); }
  
  public void setLayoutFrozen(boolean paramBoolean) {
    if (paramBoolean != this.mLayoutFrozen) {
      assertNotInLayoutOrScroll("Do not setLayoutFrozen in layout or scroll");
      if (!paramBoolean) {
        this.mLayoutFrozen = false;
        if (this.mLayoutWasDefered && this.mLayout != null && this.mAdapter != null)
          requestLayout(); 
        this.mLayoutWasDefered = false;
        return;
      } 
      long l = SystemClock.uptimeMillis();
      onTouchEvent(MotionEvent.obtain(l, l, 3, 0.0F, 0.0F, 0));
      this.mLayoutFrozen = true;
      this.mIgnoreMotionEventTillDown = true;
      stopScroll();
    } 
  }
  
  public void setLayoutManager(@Nullable LayoutManager paramLayoutManager) {
    if (paramLayoutManager == this.mLayout)
      return; 
    stopScroll();
    if (this.mLayout != null) {
      ItemAnimator itemAnimator = this.mItemAnimator;
      if (itemAnimator != null)
        itemAnimator.endAnimations(); 
      this.mLayout.removeAndRecycleAllViews(this.mRecycler);
      this.mLayout.removeAndRecycleScrapInt(this.mRecycler);
      this.mRecycler.clear();
      if (this.mIsAttached)
        this.mLayout.dispatchDetachedFromWindow(this, this.mRecycler); 
      this.mLayout.setRecyclerView(null);
      this.mLayout = null;
    } else {
      this.mRecycler.clear();
    } 
    this.mChildHelper.removeAllViewsUnfiltered();
    this.mLayout = paramLayoutManager;
    if (paramLayoutManager != null)
      if (paramLayoutManager.mRecyclerView == null) {
        this.mLayout.setRecyclerView(this);
        if (this.mIsAttached)
          this.mLayout.dispatchAttachedToWindow(this); 
      } else {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("LayoutManager ");
        stringBuilder.append(paramLayoutManager);
        stringBuilder.append(" is already attached to a RecyclerView:");
        stringBuilder.append(paramLayoutManager.mRecyclerView.exceptionLabel());
        throw new IllegalArgumentException(stringBuilder.toString());
      }  
    this.mRecycler.updateViewCacheSize();
    requestLayout();
  }
  
  public void setNestedScrollingEnabled(boolean paramBoolean) { getScrollingChildHelper().setNestedScrollingEnabled(paramBoolean); }
  
  public void setOnFlingListener(@Nullable OnFlingListener paramOnFlingListener) { this.mOnFlingListener = paramOnFlingListener; }
  
  @Deprecated
  public void setOnScrollListener(@Nullable OnScrollListener paramOnScrollListener) { this.mScrollListener = paramOnScrollListener; }
  
  public void setPreserveFocusAfterLayout(boolean paramBoolean) { this.mPreserveFocusAfterLayout = paramBoolean; }
  
  public void setRecycledViewPool(@Nullable RecycledViewPool paramRecycledViewPool) { this.mRecycler.setRecycledViewPool(paramRecycledViewPool); }
  
  public void setRecyclerListener(@Nullable RecyclerListener paramRecyclerListener) { this.mRecyclerListener = paramRecyclerListener; }
  
  void setScrollState(int paramInt) {
    if (paramInt == this.mScrollState)
      return; 
    this.mScrollState = paramInt;
    if (paramInt != 2)
      stopScrollersInternal(); 
    dispatchOnScrollStateChanged(paramInt);
  }
  
  public void setScrollingTouchSlop(int paramInt) {
    ViewConfiguration viewConfiguration = ViewConfiguration.get(getContext());
    if (paramInt != 0)
      if (paramInt != 1) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("setScrollingTouchSlop(): bad argument constant ");
        stringBuilder.append(paramInt);
        stringBuilder.append("; using default value");
        Log.w("RecyclerView", stringBuilder.toString());
      } else {
        this.mTouchSlop = viewConfiguration.getScaledPagingTouchSlop();
        return;
      }  
    this.mTouchSlop = viewConfiguration.getScaledTouchSlop();
  }
  
  public void setViewCacheExtension(@Nullable ViewCacheExtension paramViewCacheExtension) { this.mRecycler.setViewCacheExtension(paramViewCacheExtension); }
  
  boolean shouldDeferAccessibilityEvent(AccessibilityEvent paramAccessibilityEvent) {
    if (isComputingLayout()) {
      boolean bool;
      if (paramAccessibilityEvent != null) {
        bool = AccessibilityEventCompat.getContentChangeTypes(paramAccessibilityEvent);
      } else {
        bool = false;
      } 
      int i = bool;
      if (!bool)
        i = 0; 
      this.mEatenAccessibilityChangeFlags = i | this.mEatenAccessibilityChangeFlags;
      return true;
    } 
    return false;
  }
  
  public void smoothScrollBy(@Px int paramInt1, @Px int paramInt2) { smoothScrollBy(paramInt1, paramInt2, null); }
  
  public void smoothScrollBy(@Px int paramInt1, @Px int paramInt2, @Nullable Interpolator paramInterpolator) {
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager == null) {
      Log.e("RecyclerView", "Cannot smooth scroll without a LayoutManager set. Call setLayoutManager with a non-null argument.");
      return;
    } 
    if (this.mLayoutFrozen)
      return; 
    if (!layoutManager.canScrollHorizontally())
      paramInt1 = 0; 
    if (!this.mLayout.canScrollVertically())
      paramInt2 = 0; 
    if (paramInt1 != 0 || paramInt2 != 0)
      this.mViewFlinger.smoothScrollBy(paramInt1, paramInt2, paramInterpolator); 
  }
  
  public void smoothScrollToPosition(int paramInt) {
    if (this.mLayoutFrozen)
      return; 
    LayoutManager layoutManager = this.mLayout;
    if (layoutManager == null) {
      Log.e("RecyclerView", "Cannot smooth scroll without a LayoutManager set. Call setLayoutManager with a non-null argument.");
      return;
    } 
    layoutManager.smoothScrollToPosition(this, this.mState, paramInt);
  }
  
  void startInterceptRequestLayout() {
    this.mInterceptRequestLayoutDepth++;
    if (this.mInterceptRequestLayoutDepth == 1 && !this.mLayoutFrozen)
      this.mLayoutWasDefered = false; 
  }
  
  public boolean startNestedScroll(int paramInt) { return getScrollingChildHelper().startNestedScroll(paramInt); }
  
  public boolean startNestedScroll(int paramInt1, int paramInt2) { return getScrollingChildHelper().startNestedScroll(paramInt1, paramInt2); }
  
  void stopInterceptRequestLayout(boolean paramBoolean) {
    if (this.mInterceptRequestLayoutDepth < 1)
      this.mInterceptRequestLayoutDepth = 1; 
    if (!paramBoolean && !this.mLayoutFrozen)
      this.mLayoutWasDefered = false; 
    if (this.mInterceptRequestLayoutDepth == 1) {
      if (paramBoolean && this.mLayoutWasDefered && !this.mLayoutFrozen && this.mLayout != null && this.mAdapter != null)
        dispatchLayout(); 
      if (!this.mLayoutFrozen)
        this.mLayoutWasDefered = false; 
    } 
    this.mInterceptRequestLayoutDepth--;
  }
  
  public void stopNestedScroll() { getScrollingChildHelper().stopNestedScroll(); }
  
  public void stopNestedScroll(int paramInt) { getScrollingChildHelper().stopNestedScroll(paramInt); }
  
  public void stopScroll() {
    setScrollState(0);
    stopScrollersInternal();
  }
  
  public void swapAdapter(@Nullable Adapter paramAdapter, boolean paramBoolean) {
    setLayoutFrozen(false);
    setAdapterInternal(paramAdapter, true, paramBoolean);
    processDataSetCompletelyChanged(true);
    requestLayout();
  }
  
  void viewRangeUpdate(int paramInt1, int paramInt2, Object paramObject) {
    int i = this.mChildHelper.getUnfilteredChildCount();
    byte b;
    for (b = 0; b < i; b++) {
      View view = this.mChildHelper.getUnfilteredChildAt(b);
      ViewHolder viewHolder = getChildViewHolderInt(view);
      if (viewHolder != null && !viewHolder.shouldIgnore() && viewHolder.mPosition >= paramInt1 && viewHolder.mPosition < paramInt1 + paramInt2) {
        viewHolder.addFlags(2);
        viewHolder.addChangePayload(paramObject);
        ((LayoutParams)view.getLayoutParams()).mInsetsDirty = true;
      } 
    } 
    this.mRecycler.viewRangeUpdate(paramInt1, paramInt2);
  }
}

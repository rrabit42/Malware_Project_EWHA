package android.support.v4.widget;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RestrictTo;
import android.support.v4.util.Pools;
import android.support.v4.util.SimpleArrayMap;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

@RestrictTo({RestrictTo.Scope.LIBRARY})
public final class DirectedAcyclicGraph<T> extends Object {
  private final SimpleArrayMap<T, ArrayList<T>> mGraph = new SimpleArrayMap();
  
  private final Pools.Pool<ArrayList<T>> mListPool = new Pools.SimplePool(10);
  
  private final ArrayList<T> mSortResult = new ArrayList();
  
  private final HashSet<T> mSortTmpMarked = new HashSet();
  
  private void dfs(T paramT, ArrayList<T> paramArrayList, HashSet<T> paramHashSet) { // Byte code:
    //   0: aload_2
    //   1: aload_1
    //   2: invokevirtual contains : (Ljava/lang/Object;)Z
    //   5: ifeq -> 9
    //   8: return
    //   9: aload_3
    //   10: aload_1
    //   11: invokevirtual contains : (Ljava/lang/Object;)Z
    //   14: ifne -> 93
    //   17: aload_3
    //   18: aload_1
    //   19: invokevirtual add : (Ljava/lang/Object;)Z
    //   22: pop
    //   23: aload_0
    //   24: getfield mGraph : Landroid/support/v4/util/SimpleArrayMap;
    //   27: aload_1
    //   28: invokevirtual get : (Ljava/lang/Object;)Ljava/lang/Object;
    //   31: checkcast java/util/ArrayList
    //   34: astore #6
    //   36: aload #6
    //   38: ifnull -> 80
    //   41: iconst_0
    //   42: istore #4
    //   44: aload #6
    //   46: invokevirtual size : ()I
    //   49: istore #5
    //   51: iload #4
    //   53: iload #5
    //   55: if_icmpge -> 80
    //   58: aload_0
    //   59: aload #6
    //   61: iload #4
    //   63: invokevirtual get : (I)Ljava/lang/Object;
    //   66: aload_2
    //   67: aload_3
    //   68: invokespecial dfs : (Ljava/lang/Object;Ljava/util/ArrayList;Ljava/util/HashSet;)V
    //   71: iload #4
    //   73: iconst_1
    //   74: iadd
    //   75: istore #4
    //   77: goto -> 51
    //   80: aload_3
    //   81: aload_1
    //   82: invokevirtual remove : (Ljava/lang/Object;)Z
    //   85: pop
    //   86: aload_2
    //   87: aload_1
    //   88: invokevirtual add : (Ljava/lang/Object;)Z
    //   91: pop
    //   92: return
    //   93: new java/lang/RuntimeException
    //   96: dup
    //   97: ldc 'This graph contains cyclic dependencies'
    //   99: invokespecial <init> : (Ljava/lang/String;)V
    //   102: astore_1
    //   103: goto -> 108
    //   106: aload_1
    //   107: athrow
    //   108: goto -> 106 }
  
  @NonNull
  private ArrayList<T> getEmptyList() {
    ArrayList arrayList2 = (ArrayList)this.mListPool.acquire();
    ArrayList arrayList1 = arrayList2;
    if (arrayList2 == null)
      arrayList1 = new ArrayList(); 
    return arrayList1;
  }
  
  private void poolList(@NonNull ArrayList<T> paramArrayList) {
    paramArrayList.clear();
    this.mListPool.release(paramArrayList);
  }
  
  public void addEdge(@NonNull T paramT1, @NonNull T paramT2) {
    if (this.mGraph.containsKey(paramT1) && this.mGraph.containsKey(paramT2)) {
      ArrayList arrayList2 = (ArrayList)this.mGraph.get(paramT1);
      ArrayList arrayList1 = arrayList2;
      if (arrayList2 == null) {
        arrayList1 = getEmptyList();
        this.mGraph.put(paramT1, arrayList1);
      } 
      arrayList1.add(paramT2);
      return;
    } 
    throw new IllegalArgumentException("All nodes must be present in the graph before being added as an edge");
  }
  
  public void addNode(@NonNull T paramT) {
    if (!this.mGraph.containsKey(paramT))
      this.mGraph.put(paramT, null); 
  }
  
  public void clear() {
    int i = this.mGraph.size();
    for (byte b = 0; b < i; b++) {
      ArrayList arrayList = (ArrayList)this.mGraph.valueAt(b);
      if (arrayList != null)
        poolList(arrayList); 
    } 
    this.mGraph.clear();
  }
  
  public boolean contains(@NonNull T paramT) { return this.mGraph.containsKey(paramT); }
  
  @Nullable
  public List getIncomingEdges(@NonNull T paramT) { return (List)this.mGraph.get(paramT); }
  
  @Nullable
  public List<T> getOutgoingEdges(@NonNull T paramT) {
    int i = this.mGraph.size();
    ArrayList arrayList = null;
    byte b = 0;
    while (b < i) {
      ArrayList arrayList2 = (ArrayList)this.mGraph.valueAt(b);
      ArrayList arrayList1 = arrayList;
      if (arrayList2 != null) {
        arrayList1 = arrayList;
        if (arrayList2.contains(paramT)) {
          arrayList1 = arrayList;
          if (arrayList == null)
            arrayList1 = new ArrayList(); 
          arrayList1.add(this.mGraph.keyAt(b));
        } 
      } 
      b++;
      arrayList = arrayList1;
    } 
    return arrayList;
  }
  
  @NonNull
  public ArrayList<T> getSortedList() {
    this.mSortResult.clear();
    this.mSortTmpMarked.clear();
    int i = this.mGraph.size();
    for (byte b = 0; b < i; b++)
      dfs(this.mGraph.keyAt(b), this.mSortResult, this.mSortTmpMarked); 
    return this.mSortResult;
  }
  
  public boolean hasOutgoingEdges(@NonNull T paramT) {
    int i = this.mGraph.size();
    for (byte b = 0; b < i; b++) {
      ArrayList arrayList = (ArrayList)this.mGraph.valueAt(b);
      if (arrayList != null && arrayList.contains(paramT))
        return true; 
    } 
    return false;
  }
  
  int size() { return this.mGraph.size(); }
}

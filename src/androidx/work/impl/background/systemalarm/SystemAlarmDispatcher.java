package androidx.work.impl.background.systemalarm;

import android.content.Context;
import android.content.Intent;
import android.os.Handler;
import android.os.Looper;
import android.os.PowerManager;
import android.support.annotation.MainThread;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RestrictTo;
import android.support.annotation.VisibleForTesting;
import androidx.work.Logger;
import androidx.work.impl.ExecutionListener;
import androidx.work.impl.Processor;
import androidx.work.impl.WorkManagerImpl;
import androidx.work.impl.utils.WakeLocks;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class SystemAlarmDispatcher implements ExecutionListener {
  private static final int DEFAULT_START_ID = 0;
  
  private static final String KEY_START_ID = "KEY_START_ID";
  
  private static final String PROCESS_COMMAND_TAG = "ProcessCommand";
  
  static final String TAG = Logger.tagWithPrefix("SystemAlarmDispatcher");
  
  final CommandHandler mCommandHandler;
  
  @Nullable
  private CommandsCompletedListener mCompletedListener;
  
  final Context mContext;
  
  Intent mCurrentIntent;
  
  final List<Intent> mIntents;
  
  private final Handler mMainHandler;
  
  private final Processor mProcessor;
  
  private final WorkManagerImpl mWorkManager;
  
  private final WorkTimer mWorkTimer;
  
  SystemAlarmDispatcher(@NonNull Context paramContext) { this(paramContext, null, null); }
  
  @VisibleForTesting
  SystemAlarmDispatcher(@NonNull Context paramContext, @Nullable Processor paramProcessor, @Nullable WorkManagerImpl paramWorkManagerImpl) {
    this.mContext = paramContext.getApplicationContext();
    this.mCommandHandler = new CommandHandler(this.mContext);
    this.mWorkTimer = new WorkTimer();
    if (paramWorkManagerImpl == null)
      paramWorkManagerImpl = WorkManagerImpl.getInstance(); 
    this.mWorkManager = paramWorkManagerImpl;
    if (paramProcessor == null)
      paramProcessor = this.mWorkManager.getProcessor(); 
    this.mProcessor = paramProcessor;
    this.mProcessor.addExecutionListener(this);
    this.mIntents = new ArrayList();
    this.mCurrentIntent = null;
    this.mMainHandler = new Handler(Looper.getMainLooper());
  }
  
  private void assertMainThread() {
    if (this.mMainHandler.getLooper().getThread() == Thread.currentThread())
      return; 
    throw new IllegalStateException("Needs to be invoked on the main thread.");
  }
  
  @MainThread
  private boolean hasIntentWithAction(@NonNull String paramString) {
    assertMainThread();
    synchronized (this.mIntents) {
      Iterator iterator = this.mIntents.iterator();
      while (iterator.hasNext()) {
        if (paramString.equals(((Intent)iterator.next()).getAction()))
          return true; 
      } 
      return false;
    } 
  }
  
  @MainThread
  private void processCommand() {
    assertMainThread();
    wakeLock = WakeLocks.newWakeLock(this.mContext, "ProcessCommand");
    try {
      wakeLock.acquire();
      this.mWorkManager.getWorkTaskExecutor().executeOnBackgroundThread(new Object(this));
      return;
    } finally {
      wakeLock.release();
    } 
  }
  
  @MainThread
  public boolean add(@NonNull Intent paramIntent, int paramInt) { // Byte code:
    //   0: invokestatic get : ()Landroidx/work/Logger;
    //   3: astore #4
    //   5: getstatic androidx/work/impl/background/systemalarm/SystemAlarmDispatcher.TAG : Ljava/lang/String;
    //   8: astore #5
    //   10: iconst_0
    //   11: istore_3
    //   12: aload #4
    //   14: aload #5
    //   16: ldc 'Adding command %s (%s)'
    //   18: iconst_2
    //   19: anewarray java/lang/Object
    //   22: dup
    //   23: iconst_0
    //   24: aload_1
    //   25: aastore
    //   26: dup
    //   27: iconst_1
    //   28: iload_2
    //   29: invokestatic valueOf : (I)Ljava/lang/Integer;
    //   32: aastore
    //   33: invokestatic format : (Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
    //   36: iconst_0
    //   37: anewarray java/lang/Throwable
    //   40: invokevirtual debug : (Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Throwable;)V
    //   43: aload_0
    //   44: invokespecial assertMainThread : ()V
    //   47: aload_1
    //   48: invokevirtual getAction : ()Ljava/lang/String;
    //   51: astore #4
    //   53: aload #4
    //   55: invokestatic isEmpty : (Ljava/lang/CharSequence;)Z
    //   58: ifeq -> 78
    //   61: invokestatic get : ()Landroidx/work/Logger;
    //   64: getstatic androidx/work/impl/background/systemalarm/SystemAlarmDispatcher.TAG : Ljava/lang/String;
    //   67: ldc 'Unknown command. Ignoring'
    //   69: iconst_0
    //   70: anewarray java/lang/Throwable
    //   73: invokevirtual warning : (Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Throwable;)V
    //   76: iconst_0
    //   77: ireturn
    //   78: ldc 'ACTION_CONSTRAINTS_CHANGED'
    //   80: aload #4
    //   82: invokevirtual equals : (Ljava/lang/Object;)Z
    //   85: ifeq -> 99
    //   88: aload_0
    //   89: ldc 'ACTION_CONSTRAINTS_CHANGED'
    //   91: invokespecial hasIntentWithAction : (Ljava/lang/String;)Z
    //   94: ifeq -> 99
    //   97: iconst_0
    //   98: ireturn
    //   99: aload_1
    //   100: ldc 'KEY_START_ID'
    //   102: iload_2
    //   103: invokevirtual putExtra : (Ljava/lang/String;I)Landroid/content/Intent;
    //   106: pop
    //   107: aload_0
    //   108: getfield mIntents : Ljava/util/List;
    //   111: astore #4
    //   113: aload #4
    //   115: monitorenter
    //   116: iload_3
    //   117: istore_2
    //   118: aload_0
    //   119: getfield mIntents : Ljava/util/List;
    //   122: invokeinterface isEmpty : ()Z
    //   127: ifne -> 132
    //   130: iconst_1
    //   131: istore_2
    //   132: aload_0
    //   133: getfield mIntents : Ljava/util/List;
    //   136: aload_1
    //   137: invokeinterface add : (Ljava/lang/Object;)Z
    //   142: pop
    //   143: iload_2
    //   144: ifne -> 151
    //   147: aload_0
    //   148: invokespecial processCommand : ()V
    //   151: aload #4
    //   153: monitorexit
    //   154: iconst_1
    //   155: ireturn
    //   156: astore_1
    //   157: aload #4
    //   159: monitorexit
    //   160: aload_1
    //   161: athrow
    // Exception table:
    //   from	to	target	type
    //   118	130	156	finally
    //   132	143	156	finally
    //   147	151	156	finally
    //   151	154	156	finally
    //   157	160	156	finally }
  
  @MainThread
  void dequeueAndCheckForCompletion() {
    Logger.get().debug(TAG, "Checking if commands are complete.", new Throwable[0]);
    assertMainThread();
    synchronized (this.mIntents) {
      if (this.mCurrentIntent != null) {
        Logger.get().debug(TAG, String.format("Removing command %s", new Object[] { this.mCurrentIntent }), new Throwable[0]);
        if (((Intent)this.mIntents.remove(0)).equals(this.mCurrentIntent)) {
          this.mCurrentIntent = null;
        } else {
          throw new IllegalStateException("Dequeue-d command is not the first.");
        } 
      } 
      if (!this.mCommandHandler.hasPendingCommands() && this.mIntents.isEmpty()) {
        Logger.get().debug(TAG, "No more commands & intents.", new Throwable[0]);
        if (this.mCompletedListener != null)
          this.mCompletedListener.onAllCommandsCompleted(); 
      } else if (!this.mIntents.isEmpty()) {
        processCommand();
      } 
      return;
    } 
  }
  
  Processor getProcessor() { return this.mProcessor; }
  
  WorkManagerImpl getWorkManager() { return this.mWorkManager; }
  
  WorkTimer getWorkTimer() { return this.mWorkTimer; }
  
  void onDestroy() {
    this.mProcessor.removeExecutionListener(this);
    this.mCompletedListener = null;
  }
  
  public void onExecuted(@NonNull String paramString, boolean paramBoolean) { postOnMainThread(new AddRunnable(this, CommandHandler.createExecutionCompletedIntent(this.mContext, paramString, paramBoolean), 0)); }
  
  void postOnMainThread(@NonNull Runnable paramRunnable) { this.mMainHandler.post(paramRunnable); }
  
  void setCompletedListener(@NonNull CommandsCompletedListener paramCommandsCompletedListener) {
    if (this.mCompletedListener != null) {
      Logger.get().error(TAG, "A completion listener for SystemAlarmDispatcher already exists.", new Throwable[0]);
      return;
    } 
    this.mCompletedListener = paramCommandsCompletedListener;
  }
}

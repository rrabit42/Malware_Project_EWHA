package androidx.work.impl.utils;

import android.support.annotation.NonNull;
import android.support.annotation.RestrictTo;
import android.support.annotation.VisibleForTesting;
import android.text.TextUtils;
import androidx.work.Constraints;
import androidx.work.Data;
import androidx.work.ExistingWorkPolicy;
import androidx.work.Logger;
import androidx.work.Operation;
import androidx.work.WorkInfo;
import androidx.work.WorkRequest;
import androidx.work.impl.OperationImpl;
import androidx.work.impl.Schedulers;
import androidx.work.impl.WorkContinuationImpl;
import androidx.work.impl.WorkDatabase;
import androidx.work.impl.WorkManagerImpl;
import androidx.work.impl.model.DependencyDao;
import androidx.work.impl.model.WorkSpec;
import androidx.work.impl.model.WorkSpecDao;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class EnqueueRunnable implements Runnable {
  private static final String TAG = Logger.tagWithPrefix("EnqueueRunnable");
  
  private final OperationImpl mOperation;
  
  private final WorkContinuationImpl mWorkContinuation;
  
  public EnqueueRunnable(@NonNull WorkContinuationImpl paramWorkContinuationImpl) {
    this.mWorkContinuation = paramWorkContinuationImpl;
    this.mOperation = new OperationImpl();
  }
  
  private static boolean enqueueContinuation(@NonNull WorkContinuationImpl paramWorkContinuationImpl) {
    Set set = WorkContinuationImpl.prerequisitesFor(paramWorkContinuationImpl);
    boolean bool = enqueueWorkWithPrerequisites(paramWorkContinuationImpl.getWorkManagerImpl(), paramWorkContinuationImpl.getWork(), (String[])set.toArray(new String[0]), paramWorkContinuationImpl.getName(), paramWorkContinuationImpl.getExistingWorkPolicy());
    paramWorkContinuationImpl.markEnqueued();
    return bool;
  }
  
  private static boolean enqueueWorkWithPrerequisites(WorkManagerImpl paramWorkManagerImpl, @NonNull List<? extends WorkRequest> paramList, String[] paramArrayOfString, String paramString, ExistingWorkPolicy paramExistingWorkPolicy) {
    boolean bool1;
    long l = System.currentTimeMillis();
    WorkDatabase workDatabase = paramWorkManagerImpl.getWorkDatabase();
    if (paramArrayOfString != null && paramArrayOfString.length > 0) {
      b4 = 1;
    } else {
      b4 = 0;
    } 
    if (b4) {
      bool1 = paramArrayOfString.length;
      byte b11 = 0;
      byte b10 = 1;
      byte b9 = 0;
      boolean bool3 = false;
      while (true) {
        b3 = b10;
        b2 = b9;
        b1 = bool3;
        if (b11 < bool1) {
          String str = paramArrayOfString[b11];
          WorkSpec workSpec = workDatabase.workSpecDao().getWorkSpec(str);
          if (workSpec == null) {
            Logger.get().error(TAG, String.format("Prerequisite %s doesn't exist; not enqueuing", new Object[] { str }), new Throwable[0]);
            return false;
          } 
          WorkInfo.State state = workSpec.state;
          if (state == WorkInfo.State.SUCCEEDED) {
            b1 = 1;
          } else {
            b1 = 0;
          } 
          b10 &= b1;
          if (state == WorkInfo.State.FAILED) {
            b1 = 1;
          } else {
            b1 = b9;
            if (state == WorkInfo.State.CANCELLED) {
              bool3 = true;
              b1 = b9;
            } 
          } 
          b11++;
          b9 = b1;
          continue;
        } 
        break;
      } 
    } else {
      b3 = 1;
      b2 = 0;
      b1 = 0;
    } 
    boolean bool = TextUtils.isEmpty(paramString) ^ true;
    if (bool && !b4) {
      bool1 = true;
    } else {
      bool1 = false;
    } 
    idAndState2 = paramArrayOfString;
    byte b5 = b4;
    byte b6 = b3;
    byte b7 = b2;
    byte b8 = b1;
    if (bool1) {
      List list = workDatabase.workSpecDao().getWorkSpecIdAndStatesForName(paramString);
      idAndState2 = paramArrayOfString;
      b5 = b4;
      b6 = b3;
      b7 = b2;
      b8 = b1;
      if (!list.isEmpty()) {
        ArrayList arrayList;
        DependencyDao dependencyDao;
        if (paramExistingWorkPolicy == ExistingWorkPolicy.APPEND) {
          dependencyDao = workDatabase.dependencyDao();
          arrayList = new ArrayList();
          for (WorkSpec.IdAndState idAndState : list) {
            b6 = b3;
            b4 = b2;
            b5 = b1;
            if (!dependencyDao.hasDependents(idAndState.id)) {
              if (idAndState.state == WorkInfo.State.SUCCEEDED) {
                b5 = 1;
              } else {
                b5 = 0;
              } 
              if (idAndState.state == WorkInfo.State.FAILED) {
                b4 = 1;
              } else {
                b4 = b2;
                if (idAndState.state == WorkInfo.State.CANCELLED) {
                  b1 = 1;
                  b4 = b2;
                } 
              } 
              arrayList.add(idAndState.id);
              b6 = b5 & b3;
              b5 = b1;
            } 
            b3 = b6;
            b2 = b4;
            b1 = b5;
          } 
          idAndState2 = (String[])arrayList.toArray(paramArrayOfString);
          if (idAndState2.length > 0) {
            b5 = 1;
            b6 = b3;
            b7 = b2;
            b8 = b1;
          } else {
            b5 = 0;
            b6 = b3;
            b7 = b2;
            b8 = b1;
          } 
        } else {
          if (arrayList == ExistingWorkPolicy.KEEP)
            for (WorkSpec.IdAndState idAndState2 : idAndState) {
              if (idAndState2.state == WorkInfo.State.ENQUEUED || idAndState2.state == WorkInfo.State.RUNNING)
                return false; 
            }  
          CancelWorkRunnable.forName(paramString, dependencyDao, false).run();
          WorkSpecDao workSpecDao = workDatabase.workSpecDao();
          Iterator iterator2 = idAndState.iterator();
          while (iterator2.hasNext())
            workSpecDao.delete(((WorkSpec.IdAndState)iterator2.next()).id); 
          boolean bool3 = true;
          String[] arrayOfString = paramArrayOfString;
          Iterator iterator1 = paramList.iterator();
        } 
      } 
    } 
    boolean bool2 = false;
    byte b1 = b8;
    byte b2 = b7;
    byte b3 = b6;
    byte b4 = b5;
    WorkSpec.IdAndState idAndState1 = idAndState2;
    Iterator iterator = paramList.iterator();
  }
  
  private static boolean processContinuation(@NonNull WorkContinuationImpl paramWorkContinuationImpl) {
    List list = paramWorkContinuationImpl.getParents();
    boolean bool = false;
    if (list != null) {
      Iterator iterator = list.iterator();
      bool = false;
      while (iterator.hasNext()) {
        WorkContinuationImpl workContinuationImpl = (WorkContinuationImpl)iterator.next();
        if (!workContinuationImpl.isEnqueued()) {
          bool |= processContinuation(workContinuationImpl);
          continue;
        } 
        Logger.get().warning(TAG, String.format("Already enqueued work ids (%s).", new Object[] { TextUtils.join(", ", workContinuationImpl.getIds()) }), new Throwable[0]);
      } 
    } 
    return enqueueContinuation(paramWorkContinuationImpl) | bool;
  }
  
  private static void tryDelegateConstrainedWorkSpec(WorkSpec paramWorkSpec) {
    Constraints constraints = paramWorkSpec.constraints;
    if (constraints.requiresBatteryNotLow() || constraints.requiresStorageNotLow()) {
      String str = paramWorkSpec.workerClassName;
      Data.Builder builder = new Data.Builder();
      builder.putAll(paramWorkSpec.input).putString("androidx.work.impl.workers.ConstraintTrackingWorker.ARGUMENT_CLASS_NAME", str);
      paramWorkSpec.workerClassName = androidx.work.impl.workers.ConstraintTrackingWorker.class.getName();
      paramWorkSpec.input = builder.build();
    } 
  }
  
  @VisibleForTesting
  public boolean addToDatabase() {
    workDatabase = this.mWorkContinuation.getWorkManagerImpl().getWorkDatabase();
    workDatabase.beginTransaction();
    try {
      bool = processContinuation(this.mWorkContinuation);
      workDatabase.setTransactionSuccessful();
      return bool;
    } finally {
      workDatabase.endTransaction();
    } 
  }
  
  public Operation getOperation() { return this.mOperation; }
  
  public void run() {
    try {
      if (!this.mWorkContinuation.hasCycles()) {
        if (addToDatabase()) {
          PackageManagerHelper.setComponentEnabled(this.mWorkContinuation.getWorkManagerImpl().getApplicationContext(), androidx.work.impl.background.systemalarm.RescheduleReceiver.class, true);
          scheduleWorkInBackground();
        } 
        this.mOperation.setState(Operation.SUCCESS);
        return;
      } 
      throw new IllegalStateException(String.format("WorkContinuation has cycles (%s)", new Object[] { this.mWorkContinuation }));
    } catch (Throwable throwable) {
      this.mOperation.setState(new Operation.State.FAILURE(throwable));
      return;
    } 
  }
  
  @VisibleForTesting
  public void scheduleWorkInBackground() {
    WorkManagerImpl workManagerImpl = this.mWorkContinuation.getWorkManagerImpl();
    Schedulers.schedule(workManagerImpl.getConfiguration(), workManagerImpl.getWorkDatabase(), workManagerImpl.getSchedulers());
  }
}

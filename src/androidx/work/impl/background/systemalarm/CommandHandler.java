package androidx.work.impl.background.systemalarm;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RestrictTo;
import android.support.annotation.WorkerThread;
import androidx.work.Logger;
import androidx.work.impl.ExecutionListener;
import androidx.work.impl.WorkDatabase;
import java.util.HashMap;
import java.util.Map;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class CommandHandler implements ExecutionListener {
  static final String ACTION_CONSTRAINTS_CHANGED = "ACTION_CONSTRAINTS_CHANGED";
  
  static final String ACTION_DELAY_MET = "ACTION_DELAY_MET";
  
  static final String ACTION_EXECUTION_COMPLETED = "ACTION_EXECUTION_COMPLETED";
  
  static final String ACTION_RESCHEDULE = "ACTION_RESCHEDULE";
  
  static final String ACTION_SCHEDULE_WORK = "ACTION_SCHEDULE_WORK";
  
  static final String ACTION_STOP_WORK = "ACTION_STOP_WORK";
  
  private static final String KEY_NEEDS_RESCHEDULE = "KEY_NEEDS_RESCHEDULE";
  
  private static final String KEY_WORKSPEC_ID = "KEY_WORKSPEC_ID";
  
  private static final String TAG = Logger.tagWithPrefix("CommandHandler");
  
  static final long WORK_PROCESSING_TIME_IN_MS = 600000L;
  
  private final Context mContext;
  
  private final Object mLock;
  
  private final Map<String, ExecutionListener> mPendingDelayMet;
  
  CommandHandler(@NonNull Context paramContext) {
    this.mContext = paramContext;
    this.mPendingDelayMet = new HashMap();
    this.mLock = new Object();
  }
  
  static Intent createConstraintsChangedIntent(@NonNull Context paramContext) {
    Intent intent = new Intent(paramContext, SystemAlarmService.class);
    intent.setAction("ACTION_CONSTRAINTS_CHANGED");
    return intent;
  }
  
  static Intent createDelayMetIntent(@NonNull Context paramContext, @NonNull String paramString) {
    Intent intent = new Intent(paramContext, SystemAlarmService.class);
    intent.setAction("ACTION_DELAY_MET");
    intent.putExtra("KEY_WORKSPEC_ID", paramString);
    return intent;
  }
  
  static Intent createExecutionCompletedIntent(@NonNull Context paramContext, @NonNull String paramString, boolean paramBoolean) {
    Intent intent = new Intent(paramContext, SystemAlarmService.class);
    intent.setAction("ACTION_EXECUTION_COMPLETED");
    intent.putExtra("KEY_WORKSPEC_ID", paramString);
    intent.putExtra("KEY_NEEDS_RESCHEDULE", paramBoolean);
    return intent;
  }
  
  static Intent createRescheduleIntent(@NonNull Context paramContext) {
    Intent intent = new Intent(paramContext, SystemAlarmService.class);
    intent.setAction("ACTION_RESCHEDULE");
    return intent;
  }
  
  static Intent createScheduleWorkIntent(@NonNull Context paramContext, @NonNull String paramString) {
    Intent intent = new Intent(paramContext, SystemAlarmService.class);
    intent.setAction("ACTION_SCHEDULE_WORK");
    intent.putExtra("KEY_WORKSPEC_ID", paramString);
    return intent;
  }
  
  static Intent createStopWorkIntent(@NonNull Context paramContext, @NonNull String paramString) {
    Intent intent = new Intent(paramContext, SystemAlarmService.class);
    intent.setAction("ACTION_STOP_WORK");
    intent.putExtra("KEY_WORKSPEC_ID", paramString);
    return intent;
  }
  
  private void handleConstraintsChanged(@NonNull Intent paramIntent, int paramInt, @NonNull SystemAlarmDispatcher paramSystemAlarmDispatcher) {
    Logger.get().debug(TAG, String.format("Handling constraints changed %s", new Object[] { paramIntent }), new Throwable[0]);
    (new ConstraintsCommandHandler(this.mContext, paramInt, paramSystemAlarmDispatcher)).handleConstraintsChanged();
  }
  
  private void handleDelayMet(@NonNull Intent paramIntent, int paramInt, @NonNull SystemAlarmDispatcher paramSystemAlarmDispatcher) {
    Bundle bundle = paramIntent.getExtras();
    synchronized (this.mLock) {
      String str;
      Logger.get().debug(TAG, (str = bundle.getString("KEY_WORKSPEC_ID")).format("Handing delay met for %s", new Object[] { str }), new Throwable[0]);
      if (!this.mPendingDelayMet.containsKey(str)) {
        DelayMetCommandHandler delayMetCommandHandler = new DelayMetCommandHandler(this.mContext, paramInt, str, paramSystemAlarmDispatcher);
        this.mPendingDelayMet.put(str, delayMetCommandHandler);
        delayMetCommandHandler.handleProcessWork();
      } else {
        Logger.get().debug(TAG, String.format("WorkSpec %s is already being handled for ACTION_DELAY_MET", new Object[] { str }), new Throwable[0]);
      } 
      return;
    } 
  }
  
  private void handleExecutionCompleted(@NonNull Intent paramIntent, int paramInt, @NonNull SystemAlarmDispatcher paramSystemAlarmDispatcher) {
    Bundle bundle = paramIntent.getExtras();
    String str = bundle.getString("KEY_WORKSPEC_ID");
    boolean bool = bundle.getBoolean("KEY_NEEDS_RESCHEDULE");
    Logger.get().debug(TAG, String.format("Handling onExecutionCompleted %s, %s", new Object[] { paramIntent, Integer.valueOf(paramInt) }), new Throwable[0]);
    onExecuted(str, bool);
  }
  
  private void handleReschedule(@NonNull Intent paramIntent, int paramInt, @NonNull SystemAlarmDispatcher paramSystemAlarmDispatcher) {
    Logger.get().debug(TAG, String.format("Handling reschedule %s, %s", new Object[] { paramIntent, Integer.valueOf(paramInt) }), new Throwable[0]);
    paramSystemAlarmDispatcher.getWorkManager().rescheduleEligibleWork();
  }
  
  private void handleScheduleWorkIntent(@NonNull Intent paramIntent, int paramInt, @NonNull SystemAlarmDispatcher paramSystemAlarmDispatcher) {
    String str;
    Logger.get().debug(TAG, (str = paramIntent.getExtras().getString("KEY_WORKSPEC_ID")).format("Handling schedule work for %s", new Object[] { str }), new Throwable[0]);
    workDatabase = paramSystemAlarmDispatcher.getWorkManager().getWorkDatabase();
    workDatabase.beginTransaction();
    try {
      Logger logger;
      String str1 = workDatabase.workSpecDao().getWorkSpec(str);
      if (str1 == null) {
        logger = Logger.get();
        str1 = TAG;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Skipping scheduling ");
        stringBuilder.append(str);
        stringBuilder.append(" because it's no longer in the DB");
        logger.warning(str1, stringBuilder.toString(), new Throwable[0]);
        return;
      } 
      if (str1.state.isFinished()) {
        logger = Logger.get();
        str1 = TAG;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Skipping scheduling ");
        stringBuilder.append(str);
        stringBuilder.append("because it is finished.");
        logger.warning(str1, stringBuilder.toString(), new Throwable[0]);
        return;
      } 
      long l = str1.calculateNextRunTime();
      if (!str1.hasConstraints()) {
        Logger.get().debug(TAG, String.format("Setting up Alarms for %s at %s", new Object[] { str, Long.valueOf(l) }), new Throwable[0]);
        Alarms.setAlarm(this.mContext, logger.getWorkManager(), str, l);
      } else {
        Logger.get().debug(TAG, String.format("Opportunistically setting an alarm for %s at %s", new Object[] { str, Long.valueOf(l) }), new Throwable[0]);
        Alarms.setAlarm(this.mContext, logger.getWorkManager(), str, l);
        logger.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(logger, createConstraintsChangedIntent(this.mContext), paramInt));
      } 
      workDatabase.setTransactionSuccessful();
      return;
    } finally {
      workDatabase.endTransaction();
    } 
  }
  
  private void handleStopWork(@NonNull Intent paramIntent, int paramInt, @NonNull SystemAlarmDispatcher paramSystemAlarmDispatcher) {
    String str;
    Logger.get().debug(TAG, (str = paramIntent.getExtras().getString("KEY_WORKSPEC_ID")).format("Handing stopWork work for %s", new Object[] { str }), new Throwable[0]);
    paramSystemAlarmDispatcher.getWorkManager().stopWork(str);
    Alarms.cancelAlarm(this.mContext, paramSystemAlarmDispatcher.getWorkManager(), str);
    paramSystemAlarmDispatcher.onExecuted(str, false);
  }
  
  private static boolean hasKeys(@Nullable Bundle paramBundle, @NonNull String... paramVarArgs) {
    if (paramBundle != null) {
      if (paramBundle.isEmpty())
        return false; 
      int i = paramVarArgs.length;
      for (byte b = 0; b < i; b++) {
        if (paramBundle.get(paramVarArgs[b]) == null)
          return false; 
      } 
      return true;
    } 
    return false;
  }
  
  boolean hasPendingCommands() {
    synchronized (this.mLock) {
      if (!this.mPendingDelayMet.isEmpty())
        return true; 
    } 
    boolean bool = false;
    /* monitor exit ClassFileLocalVariableReferenceExpression{type=ObjectType{java/lang/Object}, name=SYNTHETIC_LOCAL_VARIABLE_2} */
    return bool;
  }
  
  public void onExecuted(@NonNull String paramString, boolean paramBoolean) {
    synchronized (this.mLock) {
      ExecutionListener executionListener = (ExecutionListener)this.mPendingDelayMet.remove(paramString);
      if (executionListener != null)
        executionListener.onExecuted(paramString, paramBoolean); 
      return;
    } 
  }
  
  @WorkerThread
  void onHandleIntent(@NonNull Intent paramIntent, int paramInt, @NonNull SystemAlarmDispatcher paramSystemAlarmDispatcher) {
    String str = paramIntent.getAction();
    if ("ACTION_CONSTRAINTS_CHANGED".equals(str)) {
      handleConstraintsChanged(paramIntent, paramInt, paramSystemAlarmDispatcher);
      return;
    } 
    if ("ACTION_RESCHEDULE".equals(str)) {
      handleReschedule(paramIntent, paramInt, paramSystemAlarmDispatcher);
      return;
    } 
    if (!hasKeys(paramIntent.getExtras(), new String[] { "KEY_WORKSPEC_ID" })) {
      Logger.get().error(TAG, String.format("Invalid request for %s, requires %s.", new Object[] { str, "KEY_WORKSPEC_ID" }), new Throwable[0]);
      return;
    } 
    if ("ACTION_SCHEDULE_WORK".equals(str)) {
      handleScheduleWorkIntent(paramIntent, paramInt, paramSystemAlarmDispatcher);
      return;
    } 
    if ("ACTION_DELAY_MET".equals(str)) {
      handleDelayMet(paramIntent, paramInt, paramSystemAlarmDispatcher);
      return;
    } 
    if ("ACTION_STOP_WORK".equals(str)) {
      handleStopWork(paramIntent, paramInt, paramSystemAlarmDispatcher);
      return;
    } 
    if ("ACTION_EXECUTION_COMPLETED".equals(str)) {
      handleExecutionCompleted(paramIntent, paramInt, paramSystemAlarmDispatcher);
      return;
    } 
    Logger.get().warning(TAG, String.format("Ignoring intent %s", new Object[] { paramIntent }), new Throwable[0]);
  }
}

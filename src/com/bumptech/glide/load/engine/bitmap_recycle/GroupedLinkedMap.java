package com.bumptech.glide.load.engine.bitmap_recycle;

import java.util.HashMap;
import java.util.Map;

class GroupedLinkedMap<K extends Poolable, V> extends Object {
  private final LinkedEntry<K, V> head = new LinkedEntry();
  
  private final Map<K, LinkedEntry<K, V>> keyToEntry = new HashMap();
  
  private void makeHead(LinkedEntry<K, V> paramLinkedEntry) {
    removeEntry(paramLinkedEntry);
    LinkedEntry linkedEntry = this.head;
    paramLinkedEntry.prev = linkedEntry;
    paramLinkedEntry.next = linkedEntry.next;
    updateEntry(paramLinkedEntry);
  }
  
  private void makeTail(LinkedEntry<K, V> paramLinkedEntry) {
    removeEntry(paramLinkedEntry);
    paramLinkedEntry.prev = this.head.prev;
    paramLinkedEntry.next = this.head;
    updateEntry(paramLinkedEntry);
  }
  
  private static <K, V> void removeEntry(LinkedEntry<K, V> paramLinkedEntry) {
    paramLinkedEntry.prev.next = paramLinkedEntry.next;
    paramLinkedEntry.next.prev = paramLinkedEntry.prev;
  }
  
  private static <K, V> void updateEntry(LinkedEntry<K, V> paramLinkedEntry) {
    paramLinkedEntry.next.prev = paramLinkedEntry;
    paramLinkedEntry.prev.next = paramLinkedEntry;
  }
  
  public V get(K paramK) {
    LinkedEntry linkedEntry = (LinkedEntry)this.keyToEntry.get(paramK);
    if (linkedEntry == null) {
      linkedEntry = new LinkedEntry(paramK);
      this.keyToEntry.put(paramK, linkedEntry);
      paramK = (K)linkedEntry;
    } else {
      paramK.offer();
      paramK = (K)linkedEntry;
    } 
    makeHead(paramK);
    return (V)paramK.removeLast();
  }
  
  public void put(K paramK, V paramV) {
    LinkedEntry linkedEntry = (LinkedEntry)this.keyToEntry.get(paramK);
    if (linkedEntry == null) {
      linkedEntry = new LinkedEntry(paramK);
      makeTail(linkedEntry);
      this.keyToEntry.put(paramK, linkedEntry);
      paramK = (K)linkedEntry;
    } else {
      paramK.offer();
      paramK = (K)linkedEntry;
    } 
    paramK.add(paramV);
  }
  
  public V removeLast() {
    for (LinkedEntry linkedEntry = this.head.prev; !linkedEntry.equals(this.head); linkedEntry = linkedEntry.prev) {
      Object object = linkedEntry.removeLast();
      if (object != null)
        return (V)object; 
      removeEntry(linkedEntry);
      this.keyToEntry.remove(LinkedEntry.access$000(linkedEntry));
      ((Poolable)LinkedEntry.access$000(linkedEntry)).offer();
    } 
    return null;
  }
  
  public String toString() {
    StringBuilder stringBuilder = new StringBuilder("GroupedLinkedMap( ");
    LinkedEntry linkedEntry = this.head.next;
    boolean bool = false;
    while (!linkedEntry.equals(this.head)) {
      bool = true;
      stringBuilder.append('{');
      stringBuilder.append(LinkedEntry.access$000(linkedEntry));
      stringBuilder.append(':');
      stringBuilder.append(linkedEntry.size());
      stringBuilder.append("}, ");
      linkedEntry = linkedEntry.next;
    } 
    if (bool)
      stringBuilder.delete(stringBuilder.length() - 2, stringBuilder.length()); 
    stringBuilder.append(" )");
    return stringBuilder.toString();
  }
}

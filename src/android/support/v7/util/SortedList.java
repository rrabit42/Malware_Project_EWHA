package android.support.v7.util;

import android.support.annotation.NonNull;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collection;

public class SortedList<T> extends Object {
  private static final int CAPACITY_GROWTH = 10;
  
  private static final int DELETION = 2;
  
  private static final int INSERTION = 1;
  
  public static final int INVALID_POSITION = -1;
  
  private static final int LOOKUP = 4;
  
  private static final int MIN_CAPACITY = 10;
  
  private BatchedCallback mBatchedCallback;
  
  private Callback mCallback;
  
  T[] mData;
  
  private int mNewDataStart;
  
  private T[] mOldData;
  
  private int mOldDataSize;
  
  private int mOldDataStart;
  
  private int mSize;
  
  private final Class<T> mTClass;
  
  public SortedList(@NonNull Class<T> paramClass, @NonNull Callback<T> paramCallback) { this(paramClass, paramCallback, 10); }
  
  public SortedList(@NonNull Class<T> paramClass, @NonNull Callback<T> paramCallback, int paramInt) {
    this.mTClass = paramClass;
    this.mData = (Object[])Array.newInstance(paramClass, paramInt);
    this.mCallback = paramCallback;
    this.mSize = 0;
  }
  
  private int add(T paramT, boolean paramBoolean) {
    int i;
    int j = findIndexOf(paramT, this.mData, 0, this.mSize, 1);
    if (j == -1) {
      i = 0;
    } else {
      i = j;
      if (j < this.mSize) {
        Object object = this.mData[j];
        i = j;
        if (this.mCallback.areItemsTheSame(object, paramT)) {
          if (this.mCallback.areContentsTheSame(object, paramT)) {
            this.mData[j] = paramT;
            return j;
          } 
          this.mData[j] = paramT;
          Callback callback = this.mCallback;
          callback.onChanged(j, 1, callback.getChangePayload(object, paramT));
          return j;
        } 
      } 
    } 
    addToData(i, paramT);
    if (paramBoolean)
      this.mCallback.onInserted(i, 1); 
    return i;
  }
  
  private void addAllInternal(T[] paramArrayOfT) {
    if (paramArrayOfT.length < 1)
      return; 
    int i = sortAndDedup(paramArrayOfT);
    if (this.mSize == 0) {
      this.mData = paramArrayOfT;
      this.mSize = i;
      this.mCallback.onInserted(0, i);
      return;
    } 
    merge(paramArrayOfT, i);
  }
  
  private void addToData(int paramInt, T paramT) { // Byte code:
    //   0: aload_0
    //   1: getfield mSize : I
    //   4: istore_3
    //   5: iload_1
    //   6: iload_3
    //   7: if_icmpgt -> 121
    //   10: aload_0
    //   11: getfield mData : [Ljava/lang/Object;
    //   14: astore #4
    //   16: iload_3
    //   17: aload #4
    //   19: arraylength
    //   20: if_icmpne -> 89
    //   23: aload_0
    //   24: getfield mTClass : Ljava/lang/Class;
    //   27: aload #4
    //   29: arraylength
    //   30: bipush #10
    //   32: iadd
    //   33: invokestatic newInstance : (Ljava/lang/Class;I)Ljava/lang/Object;
    //   36: checkcast [Ljava/lang/Object;
    //   39: checkcast [Ljava/lang/Object;
    //   42: astore #4
    //   44: aload_0
    //   45: getfield mData : [Ljava/lang/Object;
    //   48: iconst_0
    //   49: aload #4
    //   51: iconst_0
    //   52: iload_1
    //   53: invokestatic arraycopy : (Ljava/lang/Object;ILjava/lang/Object;II)V
    //   56: aload #4
    //   58: iload_1
    //   59: aload_2
    //   60: aastore
    //   61: aload_0
    //   62: getfield mData : [Ljava/lang/Object;
    //   65: iload_1
    //   66: aload #4
    //   68: iload_1
    //   69: iconst_1
    //   70: iadd
    //   71: aload_0
    //   72: getfield mSize : I
    //   75: iload_1
    //   76: isub
    //   77: invokestatic arraycopy : (Ljava/lang/Object;ILjava/lang/Object;II)V
    //   80: aload_0
    //   81: aload #4
    //   83: putfield mData : [Ljava/lang/Object;
    //   86: goto -> 110
    //   89: aload #4
    //   91: iload_1
    //   92: aload #4
    //   94: iload_1
    //   95: iconst_1
    //   96: iadd
    //   97: iload_3
    //   98: iload_1
    //   99: isub
    //   100: invokestatic arraycopy : (Ljava/lang/Object;ILjava/lang/Object;II)V
    //   103: aload_0
    //   104: getfield mData : [Ljava/lang/Object;
    //   107: iload_1
    //   108: aload_2
    //   109: aastore
    //   110: aload_0
    //   111: aload_0
    //   112: getfield mSize : I
    //   115: iconst_1
    //   116: iadd
    //   117: putfield mSize : I
    //   120: return
    //   121: new java/lang/StringBuilder
    //   124: dup
    //   125: invokespecial <init> : ()V
    //   128: astore_2
    //   129: aload_2
    //   130: ldc 'cannot add item to '
    //   132: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   135: pop
    //   136: aload_2
    //   137: iload_1
    //   138: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   141: pop
    //   142: aload_2
    //   143: ldc ' because size is '
    //   145: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   148: pop
    //   149: aload_2
    //   150: aload_0
    //   151: getfield mSize : I
    //   154: invokevirtual append : (I)Ljava/lang/StringBuilder;
    //   157: pop
    //   158: new java/lang/IndexOutOfBoundsException
    //   161: dup
    //   162: aload_2
    //   163: invokevirtual toString : ()Ljava/lang/String;
    //   166: invokespecial <init> : (Ljava/lang/String;)V
    //   169: athrow }
  
  private T[] copyArray(T[] paramArrayOfT) {
    Object[] arrayOfObject = (Object[])Array.newInstance(this.mTClass, paramArrayOfT.length);
    System.arraycopy(paramArrayOfT, 0, arrayOfObject, 0, paramArrayOfT.length);
    return (T[])arrayOfObject;
  }
  
  private int findIndexOf(T paramT, T[] paramArrayOfT, int paramInt1, int paramInt2, int paramInt3) {
    int i = paramInt1;
    while (i < paramInt2) {
      paramInt1 = (i + paramInt2) / 2;
      T t = paramArrayOfT[paramInt1];
      int j = this.mCallback.compare(t, paramT);
      if (j < 0) {
        i = paramInt1 + 1;
        continue;
      } 
      if (j == 0) {
        if (this.mCallback.areItemsTheSame(t, paramT))
          return paramInt1; 
        i = linearEqualitySearch(paramT, paramInt1, i, paramInt2);
        paramInt2 = i;
        if (paramInt3 == 1) {
          paramInt2 = i;
          if (i == -1)
            paramInt2 = paramInt1; 
        } 
        return paramInt2;
      } 
      paramInt2 = paramInt1;
    } 
    return (paramInt3 == 1) ? i : -1;
  }
  
  private int findSameItem(T paramT, T[] paramArrayOfT, int paramInt1, int paramInt2) {
    while (paramInt1 < paramInt2) {
      if (this.mCallback.areItemsTheSame(paramArrayOfT[paramInt1], paramT))
        return paramInt1; 
      paramInt1++;
    } 
    return -1;
  }
  
  private int linearEqualitySearch(T paramT, int paramInt1, int paramInt2, int paramInt3) {
    int i;
    int j = paramInt1 - 1;
    while (true) {
      i = paramInt1;
      if (j >= paramInt2) {
        Object object = this.mData[j];
        if (this.mCallback.compare(object, paramT) != 0) {
          i = paramInt1;
          break;
        } 
        if (this.mCallback.areItemsTheSame(object, paramT))
          return j; 
        j--;
        continue;
      } 
      break;
    } 
    while (true) {
      paramInt1 = i + 1;
      if (paramInt1 < paramInt3) {
        Object object = this.mData[paramInt1];
        if (this.mCallback.compare(object, paramT) != 0)
          break; 
        i = paramInt1;
        if (this.mCallback.areItemsTheSame(object, paramT))
          return paramInt1; 
        continue;
      } 
      break;
    } 
    return -1;
  }
  
  private void merge(T[] paramArrayOfT, int paramInt) {
    boolean bool;
    boolean bool1 = this.mCallback instanceof BatchedCallback;
    int i = 0;
    if (!bool1) {
      bool = true;
    } else {
      bool = false;
    } 
    if (bool)
      beginBatchedUpdates(); 
    this.mOldData = this.mData;
    this.mOldDataStart = 0;
    int j = this.mSize;
    this.mOldDataSize = j;
    this.mData = (Object[])Array.newInstance(this.mTClass, j + paramInt + 10);
    this.mNewDataStart = 0;
    while (true) {
      if (this.mOldDataStart < this.mOldDataSize || i < paramInt) {
        j = this.mOldDataStart;
        int k = this.mOldDataSize;
        if (j == k) {
          paramInt -= i;
          System.arraycopy(paramArrayOfT, i, this.mData, this.mNewDataStart, paramInt);
          this.mNewDataStart += paramInt;
          this.mSize += paramInt;
          this.mCallback.onInserted(this.mNewDataStart - paramInt, paramInt);
        } else if (i == paramInt) {
          paramInt = k - j;
          System.arraycopy(this.mOldData, j, this.mData, this.mNewDataStart, paramInt);
          this.mNewDataStart += paramInt;
        } else {
          Object[] arrayOfObject = this.mOldData[j];
          T t = paramArrayOfT[i];
          j = this.mCallback.compare(arrayOfObject, t);
          if (j > 0) {
            arrayOfObject = this.mData;
            j = this.mNewDataStart;
            this.mNewDataStart = j + 1;
            arrayOfObject[j] = t;
            this.mSize++;
            i++;
            this.mCallback.onInserted(this.mNewDataStart - 1, 1);
            continue;
          } 
          if (j == 0 && this.mCallback.areItemsTheSame(arrayOfObject, t)) {
            Object[] arrayOfObject1 = this.mData;
            j = this.mNewDataStart;
            this.mNewDataStart = j + 1;
            arrayOfObject1[j] = t;
            j = i + 1;
            this.mOldDataStart++;
            i = j;
            if (!this.mCallback.areContentsTheSame(arrayOfObject, t)) {
              Callback callback = this.mCallback;
              callback.onChanged(this.mNewDataStart - 1, 1, callback.getChangePayload(arrayOfObject, t));
              i = j;
            } 
            continue;
          } 
          t = (T)this.mData;
          j = this.mNewDataStart;
          this.mNewDataStart = j + 1;
          t[j] = arrayOfObject;
          this.mOldDataStart++;
          continue;
        } 
      } 
      this.mOldData = null;
      if (bool)
        endBatchedUpdates(); 
      return;
    } 
  }
  
  private boolean remove(T paramT, boolean paramBoolean) {
    int i = findIndexOf(paramT, this.mData, 0, this.mSize, 2);
    if (i == -1)
      return false; 
    removeItemAtIndex(i, paramBoolean);
    return true;
  }
  
  private void removeItemAtIndex(int paramInt, boolean paramBoolean) {
    Object[] arrayOfObject = this.mData;
    System.arraycopy(arrayOfObject, paramInt + 1, arrayOfObject, paramInt, this.mSize - paramInt - 1);
    this.mSize--;
    this.mData[this.mSize] = null;
    if (paramBoolean)
      this.mCallback.onRemoved(paramInt, 1); 
  }
  
  private void replaceAllInsert(T paramT) {
    Object[] arrayOfObject = this.mData;
    int i = this.mNewDataStart;
    arrayOfObject[i] = paramT;
    this.mNewDataStart = i + 1;
    this.mSize++;
    this.mCallback.onInserted(this.mNewDataStart - 1, 1);
  }
  
  private void replaceAllInternal(@NonNull T[] paramArrayOfT) {
    boolean bool;
    if (!(this.mCallback instanceof BatchedCallback)) {
      bool = true;
    } else {
      bool = false;
    } 
    if (bool)
      beginBatchedUpdates(); 
    this.mOldDataStart = 0;
    this.mOldDataSize = this.mSize;
    this.mOldData = this.mData;
    this.mNewDataStart = 0;
    int i = sortAndDedup(paramArrayOfT);
    this.mData = (Object[])Array.newInstance(this.mTClass, i);
    while (true) {
      if (this.mNewDataStart < i || this.mOldDataStart < this.mOldDataSize) {
        int j = this.mOldDataStart;
        int k = this.mOldDataSize;
        if (j >= k) {
          int m = this.mNewDataStart;
          i -= m;
          System.arraycopy(paramArrayOfT, m, this.mData, m, i);
          this.mNewDataStart += i;
          this.mSize += i;
          this.mCallback.onInserted(m, i);
        } else {
          int m = this.mNewDataStart;
          if (m >= i) {
            i = k - j;
            this.mSize -= i;
            this.mCallback.onRemoved(m, i);
          } else {
            Object object = this.mOldData[j];
            T t = paramArrayOfT[m];
            m = this.mCallback.compare(object, t);
            if (m < 0) {
              replaceAllRemove();
              continue;
            } 
            if (m > 0) {
              replaceAllInsert(t);
              continue;
            } 
            if (!this.mCallback.areItemsTheSame(object, t)) {
              replaceAllRemove();
              replaceAllInsert(t);
              continue;
            } 
            Object[] arrayOfObject = this.mData;
            m = this.mNewDataStart;
            arrayOfObject[m] = t;
            this.mOldDataStart++;
            this.mNewDataStart = m + 1;
            if (!this.mCallback.areContentsTheSame(object, t)) {
              Callback callback = this.mCallback;
              callback.onChanged(this.mNewDataStart - 1, 1, callback.getChangePayload(object, t));
            } 
            continue;
          } 
        } 
      } 
      this.mOldData = null;
      if (bool)
        endBatchedUpdates(); 
      return;
    } 
  }
  
  private void replaceAllRemove() {
    this.mSize--;
    this.mOldDataStart++;
    this.mCallback.onRemoved(this.mNewDataStart, 1);
  }
  
  private int sortAndDedup(@NonNull T[] paramArrayOfT) {
    if (paramArrayOfT.length == 0)
      return 0; 
    Arrays.sort(paramArrayOfT, this.mCallback);
    byte b2 = 1;
    byte b1 = 1;
    byte b3 = 0;
    while (b2 < paramArrayOfT.length) {
      T t = paramArrayOfT[b2];
      if (this.mCallback.compare(paramArrayOfT[b3], t) == 0) {
        int i = findSameItem(t, paramArrayOfT, b3, b1);
        if (i != -1) {
          paramArrayOfT[i] = t;
        } else {
          if (b1 != b2)
            paramArrayOfT[b1] = t; 
          b1++;
        } 
      } else {
        if (b1 != b2)
          paramArrayOfT[b1] = t; 
        b3 = b1;
        b1++;
      } 
      b2++;
    } 
    return b1;
  }
  
  private void throwIfInMutationOperation() {
    if (this.mOldData == null)
      return; 
    throw new IllegalStateException("Data cannot be mutated in the middle of a batch update operation such as addAll or replaceAll.");
  }
  
  public int add(T paramT) {
    throwIfInMutationOperation();
    return add(paramT, true);
  }
  
  public void addAll(@NonNull Collection<T> paramCollection) { addAll(paramCollection.toArray((Object[])Array.newInstance(this.mTClass, paramCollection.size())), true); }
  
  public void addAll(@NonNull T... paramVarArgs) { addAll(paramVarArgs, false); }
  
  public void addAll(@NonNull T[] paramArrayOfT, boolean paramBoolean) {
    throwIfInMutationOperation();
    if (paramArrayOfT.length == 0)
      return; 
    if (paramBoolean) {
      addAllInternal(paramArrayOfT);
      return;
    } 
    addAllInternal(copyArray(paramArrayOfT));
  }
  
  public void beginBatchedUpdates() {
    throwIfInMutationOperation();
    Callback callback = this.mCallback;
    if (callback instanceof BatchedCallback)
      return; 
    if (this.mBatchedCallback == null)
      this.mBatchedCallback = new BatchedCallback(callback); 
    this.mCallback = this.mBatchedCallback;
  }
  
  public void clear() {
    throwIfInMutationOperation();
    int i = this.mSize;
    if (i == 0)
      return; 
    Arrays.fill(this.mData, 0, i, null);
    this.mSize = 0;
    this.mCallback.onRemoved(0, i);
  }
  
  public void endBatchedUpdates() {
    throwIfInMutationOperation();
    Callback callback = this.mCallback;
    if (callback instanceof BatchedCallback)
      ((BatchedCallback)callback).dispatchLastEvent(); 
    callback = this.mCallback;
    BatchedCallback batchedCallback = this.mBatchedCallback;
    if (callback == batchedCallback)
      this.mCallback = batchedCallback.mWrappedCallback; 
  }
  
  public T get(int paramInt) throws IndexOutOfBoundsException {
    if (paramInt < this.mSize && paramInt >= 0) {
      Object[] arrayOfObject = this.mOldData;
      if (arrayOfObject != null) {
        int i = this.mNewDataStart;
        if (paramInt >= i)
          return (T)arrayOfObject[paramInt - i + this.mOldDataStart]; 
      } 
      return (T)this.mData[paramInt];
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("Asked to get item at ");
    stringBuilder.append(paramInt);
    stringBuilder.append(" but size is ");
    stringBuilder.append(this.mSize);
    throw new IndexOutOfBoundsException(stringBuilder.toString());
  }
  
  public int indexOf(T paramT) {
    if (this.mOldData != null) {
      int i = findIndexOf(paramT, this.mData, 0, this.mNewDataStart, 4);
      if (i != -1)
        return i; 
      i = findIndexOf(paramT, this.mOldData, this.mOldDataStart, this.mOldDataSize, 4);
      return (i != -1) ? (i - this.mOldDataStart + this.mNewDataStart) : -1;
    } 
    return findIndexOf(paramT, this.mData, 0, this.mSize, 4);
  }
  
  public void recalculatePositionOfItemAt(int paramInt) {
    throwIfInMutationOperation();
    Object object = get(paramInt);
    removeItemAtIndex(paramInt, false);
    int i = add(object, false);
    if (paramInt != i)
      this.mCallback.onMoved(paramInt, i); 
  }
  
  public boolean remove(T paramT) {
    throwIfInMutationOperation();
    return remove(paramT, true);
  }
  
  public T removeItemAt(int paramInt) throws IndexOutOfBoundsException {
    throwIfInMutationOperation();
    Object object = get(paramInt);
    removeItemAtIndex(paramInt, true);
    return (T)object;
  }
  
  public void replaceAll(@NonNull Collection<T> paramCollection) { replaceAll(paramCollection.toArray((Object[])Array.newInstance(this.mTClass, paramCollection.size())), true); }
  
  public void replaceAll(@NonNull T... paramVarArgs) { replaceAll(paramVarArgs, false); }
  
  public void replaceAll(@NonNull T[] paramArrayOfT, boolean paramBoolean) {
    throwIfInMutationOperation();
    if (paramBoolean) {
      replaceAllInternal(paramArrayOfT);
      return;
    } 
    replaceAllInternal(copyArray(paramArrayOfT));
  }
  
  public int size() { return this.mSize; }
  
  public void updateItemAt(int paramInt, T paramT) {
    throwIfInMutationOperation();
    Object object = get(paramInt);
    if (object == paramT || !this.mCallback.areContentsTheSame(object, paramT)) {
      i = 1;
    } else {
      i = 0;
    } 
    if (object != paramT && this.mCallback.compare(object, paramT) == 0) {
      this.mData[paramInt] = paramT;
      if (i) {
        Callback callback = this.mCallback;
        callback.onChanged(paramInt, 1, callback.getChangePayload(object, paramT));
      } 
      return;
    } 
    if (i) {
      Callback callback = this.mCallback;
      callback.onChanged(paramInt, 1, callback.getChangePayload(object, paramT));
    } 
    removeItemAtIndex(paramInt, false);
    int i = add(paramT, false);
    if (paramInt != i)
      this.mCallback.onMoved(paramInt, i); 
  }
}

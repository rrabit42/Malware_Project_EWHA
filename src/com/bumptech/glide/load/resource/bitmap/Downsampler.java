package com.bumptech.glide.load.resource.bitmap;

import android.annotation.TargetApi;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Build;
import android.util.Log;
import com.bumptech.glide.load.DecodeFormat;
import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
import com.bumptech.glide.util.ByteArrayPool;
import com.bumptech.glide.util.ExceptionCatchingInputStream;
import com.bumptech.glide.util.MarkEnforcingInputStream;
import com.bumptech.glide.util.Util;
import java.io.IOException;
import java.io.InputStream;
import java.util.EnumSet;
import java.util.Queue;
import java.util.Set;

public abstract class Downsampler extends Object implements BitmapDecoder<InputStream> {
  public static final Downsampler AT_LEAST;
  
  public static final Downsampler AT_MOST;
  
  private static final int MARK_POSITION = 5242880;
  
  public static final Downsampler NONE;
  
  private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE;
  
  private static final String TAG = "Downsampler";
  
  private static final Set<ImageHeaderParser.ImageType> TYPES_THAT_USE_POOL = EnumSet.of(ImageHeaderParser.ImageType.JPEG, ImageHeaderParser.ImageType.PNG_A, ImageHeaderParser.ImageType.PNG);
  
  static  {
    OPTIONS_QUEUE = Util.createQueue(0);
    AT_LEAST = new Object();
    AT_MOST = new Object();
    NONE = new Object();
  }
  
  private static Bitmap decodeStream(MarkEnforcingInputStream paramMarkEnforcingInputStream, RecyclableBufferedInputStream paramRecyclableBufferedInputStream, BitmapFactory.Options paramOptions) {
    if (paramOptions.inJustDecodeBounds) {
      paramMarkEnforcingInputStream.mark(5242880);
    } else {
      paramRecyclableBufferedInputStream.fixMarkLimit();
    } 
    Bitmap bitmap = BitmapFactory.decodeStream(paramMarkEnforcingInputStream, null, paramOptions);
    try {
      if (paramOptions.inJustDecodeBounds) {
        paramMarkEnforcingInputStream.reset();
        return bitmap;
      } 
    } catch (IOException paramMarkEnforcingInputStream) {
      if (Log.isLoggable("Downsampler", 6)) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Exception loading inDecodeBounds=");
        stringBuilder.append(paramOptions.inJustDecodeBounds);
        stringBuilder.append(" sample=");
        stringBuilder.append(paramOptions.inSampleSize);
        Log.e("Downsampler", stringBuilder.toString(), paramMarkEnforcingInputStream);
      } 
    } 
    return bitmap;
  }
  
  private Bitmap downsampleWithSize(MarkEnforcingInputStream paramMarkEnforcingInputStream, RecyclableBufferedInputStream paramRecyclableBufferedInputStream, BitmapFactory.Options paramOptions, BitmapPool paramBitmapPool, int paramInt1, int paramInt2, int paramInt3, DecodeFormat paramDecodeFormat) {
    Bitmap.Config config = getConfig(paramMarkEnforcingInputStream, paramDecodeFormat);
    paramOptions.inSampleSize = paramInt3;
    paramOptions.inPreferredConfig = config;
    if ((paramOptions.inSampleSize == 1 || 19 <= Build.VERSION.SDK_INT) && shouldUsePool(paramMarkEnforcingInputStream)) {
      double d2 = paramInt1;
      double d1 = paramInt3;
      Double.isNaN(d2);
      Double.isNaN(d1);
      paramInt1 = (int)Math.ceil(d2 / d1);
      d2 = paramInt2;
      Double.isNaN(d2);
      Double.isNaN(d1);
      setInBitmap(paramOptions, paramBitmapPool.getDirty(paramInt1, (int)Math.ceil(d2 / d1), config));
    } 
    return decodeStream(paramMarkEnforcingInputStream, paramRecyclableBufferedInputStream, paramOptions);
  }
  
  private static Bitmap.Config getConfig(InputStream paramInputStream, DecodeFormat paramDecodeFormat) { // Byte code:
    //   0: aload_1
    //   1: getstatic com/bumptech/glide/load/DecodeFormat.ALWAYS_ARGB_8888 : Lcom/bumptech/glide/load/DecodeFormat;
    //   4: if_acmpeq -> 199
    //   7: aload_1
    //   8: getstatic com/bumptech/glide/load/DecodeFormat.PREFER_ARGB_8888 : Lcom/bumptech/glide/load/DecodeFormat;
    //   11: if_acmpeq -> 199
    //   14: getstatic android/os/Build$VERSION.SDK_INT : I
    //   17: bipush #16
    //   19: if_icmpne -> 25
    //   22: goto -> 199
    //   25: iconst_0
    //   26: istore_2
    //   27: iconst_0
    //   28: istore #4
    //   30: aload_0
    //   31: sipush #1024
    //   34: invokevirtual mark : (I)V
    //   37: new com/bumptech/glide/load/resource/bitmap/ImageHeaderParser
    //   40: dup
    //   41: aload_0
    //   42: invokespecial <init> : (Ljava/io/InputStream;)V
    //   45: invokevirtual hasAlpha : ()Z
    //   48: istore_3
    //   49: aload_0
    //   50: invokevirtual reset : ()V
    //   53: iload_3
    //   54: istore_2
    //   55: goto -> 159
    //   58: astore_0
    //   59: iload_3
    //   60: istore_2
    //   61: ldc 'Downsampler'
    //   63: iconst_5
    //   64: invokestatic isLoggable : (Ljava/lang/String;I)Z
    //   67: ifeq -> 159
    //   70: iload_3
    //   71: istore_2
    //   72: ldc 'Downsampler'
    //   74: ldc 'Cannot reset the input stream'
    //   76: aload_0
    //   77: invokestatic w : (Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)I
    //   80: pop
    //   81: goto -> 159
    //   84: astore_1
    //   85: goto -> 171
    //   88: astore #5
    //   90: ldc 'Downsampler'
    //   92: iconst_5
    //   93: invokestatic isLoggable : (Ljava/lang/String;I)Z
    //   96: ifeq -> 136
    //   99: new java/lang/StringBuilder
    //   102: dup
    //   103: invokespecial <init> : ()V
    //   106: astore #6
    //   108: aload #6
    //   110: ldc 'Cannot determine whether the image has alpha or not from header for format '
    //   112: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   115: pop
    //   116: aload #6
    //   118: aload_1
    //   119: invokevirtual append : (Ljava/lang/Object;)Ljava/lang/StringBuilder;
    //   122: pop
    //   123: ldc 'Downsampler'
    //   125: aload #6
    //   127: invokevirtual toString : ()Ljava/lang/String;
    //   130: aload #5
    //   132: invokestatic w : (Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)I
    //   135: pop
    //   136: aload_0
    //   137: invokevirtual reset : ()V
    //   140: goto -> 159
    //   143: astore_0
    //   144: ldc 'Downsampler'
    //   146: iconst_5
    //   147: invokestatic isLoggable : (Ljava/lang/String;I)Z
    //   150: ifeq -> 159
    //   153: iload #4
    //   155: istore_2
    //   156: goto -> 72
    //   159: iload_2
    //   160: ifeq -> 167
    //   163: getstatic android/graphics/Bitmap$Config.ARGB_8888 : Landroid/graphics/Bitmap$Config;
    //   166: areturn
    //   167: getstatic android/graphics/Bitmap$Config.RGB_565 : Landroid/graphics/Bitmap$Config;
    //   170: areturn
    //   171: aload_0
    //   172: invokevirtual reset : ()V
    //   175: goto -> 197
    //   178: astore_0
    //   179: ldc 'Downsampler'
    //   181: iconst_5
    //   182: invokestatic isLoggable : (Ljava/lang/String;I)Z
    //   185: ifeq -> 197
    //   188: ldc 'Downsampler'
    //   190: ldc 'Cannot reset the input stream'
    //   192: aload_0
    //   193: invokestatic w : (Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)I
    //   196: pop
    //   197: aload_1
    //   198: athrow
    //   199: getstatic android/graphics/Bitmap$Config.ARGB_8888 : Landroid/graphics/Bitmap$Config;
    //   202: areturn
    // Exception table:
    //   from	to	target	type
    //   37	49	88	java/io/IOException
    //   37	49	84	finally
    //   49	53	58	java/io/IOException
    //   90	136	84	finally
    //   136	140	143	java/io/IOException
    //   171	175	178	java/io/IOException }
  
  @TargetApi(11)
  private static BitmapFactory.Options getDefaultOptions() { // Byte code:
    //   0: ldc com/bumptech/glide/load/resource/bitmap/Downsampler
    //   2: monitorenter
    //   3: getstatic com/bumptech/glide/load/resource/bitmap/Downsampler.OPTIONS_QUEUE : Ljava/util/Queue;
    //   6: astore_0
    //   7: aload_0
    //   8: monitorenter
    //   9: getstatic com/bumptech/glide/load/resource/bitmap/Downsampler.OPTIONS_QUEUE : Ljava/util/Queue;
    //   12: invokeinterface poll : ()Ljava/lang/Object;
    //   17: checkcast android/graphics/BitmapFactory$Options
    //   20: astore_1
    //   21: aload_0
    //   22: monitorexit
    //   23: aload_1
    //   24: astore_0
    //   25: aload_1
    //   26: ifnonnull -> 41
    //   29: new android/graphics/BitmapFactory$Options
    //   32: dup
    //   33: invokespecial <init> : ()V
    //   36: astore_0
    //   37: aload_0
    //   38: invokestatic resetOptions : (Landroid/graphics/BitmapFactory$Options;)V
    //   41: ldc com/bumptech/glide/load/resource/bitmap/Downsampler
    //   43: monitorexit
    //   44: aload_0
    //   45: areturn
    //   46: astore_1
    //   47: aload_0
    //   48: monitorexit
    //   49: aload_1
    //   50: athrow
    //   51: astore_0
    //   52: ldc com/bumptech/glide/load/resource/bitmap/Downsampler
    //   54: monitorexit
    //   55: aload_0
    //   56: athrow
    // Exception table:
    //   from	to	target	type
    //   3	9	51	finally
    //   9	23	46	finally
    //   29	41	51	finally
    //   47	49	46	finally
    //   49	51	51	finally }
  
  private int getRoundedSampleSize(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5) {
    int i = paramInt5;
    if (paramInt5 == Integer.MIN_VALUE)
      i = paramInt3; 
    paramInt5 = paramInt4;
    if (paramInt4 == Integer.MIN_VALUE)
      paramInt5 = paramInt2; 
    if (paramInt1 == 90 || paramInt1 == 270) {
      paramInt1 = getSampleSize(paramInt3, paramInt2, paramInt5, i);
    } else {
      paramInt1 = getSampleSize(paramInt2, paramInt3, paramInt5, i);
    } 
    if (paramInt1 == 0) {
      paramInt1 = 0;
    } else {
      paramInt1 = Integer.highestOneBit(paramInt1);
    } 
    return Math.max(1, paramInt1);
  }
  
  private static void releaseOptions(BitmapFactory.Options paramOptions) {
    resetOptions(paramOptions);
    synchronized (OPTIONS_QUEUE) {
      OPTIONS_QUEUE.offer(paramOptions);
      return;
    } 
  }
  
  @TargetApi(11)
  private static void resetOptions(BitmapFactory.Options paramOptions) {
    paramOptions.inTempStorage = null;
    paramOptions.inDither = false;
    paramOptions.inScaled = false;
    paramOptions.inSampleSize = 1;
    paramOptions.inPreferredConfig = null;
    paramOptions.inJustDecodeBounds = false;
    paramOptions.outWidth = 0;
    paramOptions.outHeight = 0;
    paramOptions.outMimeType = null;
    if (11 <= Build.VERSION.SDK_INT) {
      paramOptions.inBitmap = null;
      paramOptions.inMutable = true;
    } 
  }
  
  @TargetApi(11)
  private static void setInBitmap(BitmapFactory.Options paramOptions, Bitmap paramBitmap) {
    if (11 <= Build.VERSION.SDK_INT)
      paramOptions.inBitmap = paramBitmap; 
  }
  
  private static boolean shouldUsePool(InputStream paramInputStream) {
    BitmapFactory.Options options;
    if (19 <= Build.VERSION.SDK_INT)
      return true; 
    paramInputStream.mark(1024);
    try {
      options = (new ImageHeaderParser(paramInputStream)).getType();
      boolean bool = TYPES_THAT_USE_POOL.contains(options);
      try {
        paramInputStream.reset();
        return bool;
      } catch (IOException paramInputStream) {
        if (Log.isLoggable("Downsampler", 5))
          Log.w("Downsampler", "Cannot reset the input stream", paramInputStream); 
        return bool;
      } 
    } catch (IOException null) {
      if (Log.isLoggable("Downsampler", 5))
        Log.w("Downsampler", "Cannot determine the image type from header", options); 
      try {
        paramInputStream.reset();
      } catch (IOException paramInputStream) {
        if (Log.isLoggable("Downsampler", 5))
          Log.w("Downsampler", "Cannot reset the input stream", paramInputStream); 
      } 
      return false;
    } finally {}
    try {
      paramInputStream.reset();
    } catch (IOException paramInputStream) {
      if (Log.isLoggable("Downsampler", 5))
        Log.w("Downsampler", "Cannot reset the input stream", paramInputStream); 
    } 
    throw options;
  }
  
  public Bitmap decode(InputStream paramInputStream, BitmapPool paramBitmapPool, int paramInt1, int paramInt2, DecodeFormat paramDecodeFormat) {
    byteArrayPool = ByteArrayPool.get();
    arrayOfByte1 = byteArrayPool.getBytes();
    arrayOfByte2 = byteArrayPool.getBytes();
    options = getDefaultOptions();
    null = new RecyclableBufferedInputStream(paramInputStream, arrayOfByte2);
    exceptionCatchingInputStream = ExceptionCatchingInputStream.obtain(null);
    MarkEnforcingInputStream markEnforcingInputStream = new MarkEnforcingInputStream(exceptionCatchingInputStream);
    try {
      int i;
      exceptionCatchingInputStream.mark(5242880);
      try {
        i = (new ImageHeaderParser(exceptionCatchingInputStream)).getOrientation();
        try {
          exceptionCatchingInputStream.reset();
        } catch (IOException iOException) {
          if (Log.isLoggable("Downsampler", 5))
            Log.w("Downsampler", "Cannot reset the input stream", iOException); 
        } 
      } catch (IOException iOException) {
        if (Log.isLoggable("Downsampler", 5))
          Log.w("Downsampler", "Cannot determine the image orientation from header", iOException); 
        try {
          exceptionCatchingInputStream.reset();
        } catch (IOException iOException) {
          if (Log.isLoggable("Downsampler", 5))
            Log.w("Downsampler", "Cannot reset the input stream", iOException); 
        } 
      } finally {}
      options.inTempStorage = arrayOfByte1;
      int[] arrayOfInt = getDimensions(markEnforcingInputStream, null, options);
      int j = arrayOfInt[0];
      int k = arrayOfInt[1];
      Bitmap bitmap2 = downsampleWithSize(markEnforcingInputStream, null, options, paramBitmapPool, j, k, getRoundedSampleSize(TransformationUtils.getExifOrientationDegrees(i), j, k, paramInt1, paramInt2), paramDecodeFormat);
      bitmap1 = exceptionCatchingInputStream.getException();
      if (bitmap1 == null) {
        bitmap1 = null;
        if (bitmap2 != null) {
          Bitmap bitmap = TransformationUtils.rotateImageExif(bitmap2, paramBitmapPool, i);
          bitmap1 = bitmap;
          if (!bitmap2.equals(bitmap)) {
            bitmap1 = bitmap;
            if (!paramBitmapPool.put(bitmap2)) {
              bitmap2.recycle();
              bitmap1 = bitmap;
            } 
          } 
        } 
        return bitmap1;
      } 
      throw new RuntimeException(bitmap1);
    } finally {
      byteArrayPool.releaseBytes(arrayOfByte1);
      byteArrayPool.releaseBytes(arrayOfByte2);
      exceptionCatchingInputStream.release();
      releaseOptions(options);
    } 
  }
  
  public int[] getDimensions(MarkEnforcingInputStream paramMarkEnforcingInputStream, RecyclableBufferedInputStream paramRecyclableBufferedInputStream, BitmapFactory.Options paramOptions) {
    paramOptions.inJustDecodeBounds = true;
    decodeStream(paramMarkEnforcingInputStream, paramRecyclableBufferedInputStream, paramOptions);
    paramOptions.inJustDecodeBounds = false;
    return new int[] { paramOptions.outWidth, paramOptions.outHeight };
  }
  
  protected abstract int getSampleSize(int paramInt1, int paramInt2, int paramInt3, int paramInt4);
}

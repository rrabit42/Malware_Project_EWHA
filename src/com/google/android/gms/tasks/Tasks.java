package com.google.android.gms.tasks;

import android.support.annotation.NonNull;
import com.google.android.gms.common.internal.Preconditions;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public final class Tasks {
  public static <TResult> TResult await(@NonNull Task<TResult> paramTask) throws ExecutionException, InterruptedException {
    Preconditions.checkNotMainThread();
    Preconditions.checkNotNull(paramTask, "Task must not be null");
    if (paramTask.isComplete())
      return (TResult)zzb(paramTask); 
    zza zza = new zza(null);
    zza(paramTask, zza);
    zza.await();
    return (TResult)zzb(paramTask);
  }
  
  public static <TResult> TResult await(@NonNull Task<TResult> paramTask, long paramLong, @NonNull TimeUnit paramTimeUnit) throws ExecutionException, InterruptedException, TimeoutException {
    Preconditions.checkNotMainThread();
    Preconditions.checkNotNull(paramTask, "Task must not be null");
    Preconditions.checkNotNull(paramTimeUnit, "TimeUnit must not be null");
    if (paramTask.isComplete())
      return (TResult)zzb(paramTask); 
    zza zza = new zza(null);
    zza(paramTask, zza);
    if (zza.await(paramLong, paramTimeUnit))
      return (TResult)zzb(paramTask); 
    throw new TimeoutException("Timed out waiting for Task");
  }
  
  public static <TResult> Task<TResult> call(@NonNull Callable<TResult> paramCallable) { return call(TaskExecutors.MAIN_THREAD, paramCallable); }
  
  public static <TResult> Task<TResult> call(@NonNull Executor paramExecutor, @NonNull Callable<TResult> paramCallable) {
    Preconditions.checkNotNull(paramExecutor, "Executor must not be null");
    Preconditions.checkNotNull(paramCallable, "Callback must not be null");
    zzu zzu = new zzu();
    paramExecutor.execute(new zzv(zzu, paramCallable));
    return zzu;
  }
  
  public static <TResult> Task<TResult> forCanceled() {
    zzu zzu = new zzu();
    zzu.zza();
    return zzu;
  }
  
  public static <TResult> Task<TResult> forException(@NonNull Exception paramException) {
    zzu zzu = new zzu();
    zzu.setException(paramException);
    return zzu;
  }
  
  public static <TResult> Task<TResult> forResult(TResult paramTResult) {
    zzu zzu = new zzu();
    zzu.setResult(paramTResult);
    return zzu;
  }
  
  public static Task<Void> whenAll(Collection<? extends Task<?>> paramCollection) {
    if (paramCollection.isEmpty())
      return forResult(null); 
    Iterator iterator2 = paramCollection.iterator();
    while (iterator2.hasNext()) {
      if ((Task)iterator2.next() != null)
        continue; 
      throw new NullPointerException("null tasks are not accepted");
    } 
    zzu zzu = new zzu();
    zzc zzc = new zzc(paramCollection.size(), zzu);
    Iterator iterator1 = paramCollection.iterator();
    while (iterator1.hasNext())
      zza((Task)iterator1.next(), zzc); 
    return zzu;
  }
  
  public static Task<Void> whenAll(Task<?>... paramVarArgs) { return (paramVarArgs.length == 0) ? forResult(null) : whenAll(Arrays.asList(paramVarArgs)); }
  
  public static Task<List<Task<?>>> whenAllComplete(Collection<? extends Task<?>> paramCollection) { return whenAll(paramCollection).continueWithTask(new zzx(paramCollection)); }
  
  public static Task<List<Task<?>>> whenAllComplete(Task<?>... paramVarArgs) { return whenAllComplete(Arrays.asList(paramVarArgs)); }
  
  public static <TResult> Task<List<TResult>> whenAllSuccess(Collection<? extends Task<?>> paramCollection) { return whenAll(paramCollection).continueWith(new zzw(paramCollection)); }
  
  public static <TResult> Task<List<TResult>> whenAllSuccess(Task<?>... paramVarArgs) { return whenAllSuccess(Arrays.asList(paramVarArgs)); }
  
  private static void zza(Task<?> paramTask, zzb paramzzb) {
    paramTask.addOnSuccessListener(TaskExecutors.zzw, paramzzb);
    paramTask.addOnFailureListener(TaskExecutors.zzw, paramzzb);
    paramTask.addOnCanceledListener(TaskExecutors.zzw, paramzzb);
  }
  
  private static <TResult> TResult zzb(Task<TResult> paramTask) throws ExecutionException, InterruptedException {
    if (paramTask.isSuccessful())
      return (TResult)paramTask.getResult(); 
    if (paramTask.isCanceled())
      throw new CancellationException("Task is already canceled"); 
    throw new ExecutionException(paramTask.getException());
  }
}

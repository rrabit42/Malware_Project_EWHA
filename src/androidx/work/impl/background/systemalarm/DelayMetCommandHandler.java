package androidx.work.impl.background.systemalarm;

import android.content.Context;
import android.content.Intent;
import android.os.PowerManager;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RestrictTo;
import android.support.annotation.WorkerThread;
import androidx.work.Logger;
import androidx.work.impl.ExecutionListener;
import androidx.work.impl.constraints.WorkConstraintsCallback;
import androidx.work.impl.constraints.WorkConstraintsTracker;
import androidx.work.impl.model.WorkSpec;
import androidx.work.impl.utils.WakeLocks;
import java.util.Collections;
import java.util.List;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class DelayMetCommandHandler implements WorkConstraintsCallback, ExecutionListener, WorkTimer.TimeLimitExceededListener {
  private static final String TAG = Logger.tagWithPrefix("DelayMetCommandHandler");
  
  private final Context mContext;
  
  private final SystemAlarmDispatcher mDispatcher;
  
  private boolean mHasConstraints;
  
  private boolean mHasPendingStopWorkCommand;
  
  private final Object mLock;
  
  private final int mStartId;
  
  @Nullable
  private PowerManager.WakeLock mWakeLock;
  
  private final WorkConstraintsTracker mWorkConstraintsTracker;
  
  private final String mWorkSpecId;
  
  DelayMetCommandHandler(@NonNull Context paramContext, int paramInt, @NonNull String paramString, @NonNull SystemAlarmDispatcher paramSystemAlarmDispatcher) {
    this.mContext = paramContext;
    this.mStartId = paramInt;
    this.mDispatcher = paramSystemAlarmDispatcher;
    this.mWorkSpecId = paramString;
    this.mWorkConstraintsTracker = new WorkConstraintsTracker(this.mContext, this);
    this.mHasConstraints = false;
    this.mHasPendingStopWorkCommand = false;
    this.mLock = new Object();
  }
  
  private void cleanUp() {
    synchronized (this.mLock) {
      this.mWorkConstraintsTracker.reset();
      this.mDispatcher.getWorkTimer().stopTimer(this.mWorkSpecId);
      if (this.mWakeLock != null && this.mWakeLock.isHeld()) {
        Logger.get().debug(TAG, String.format("Releasing wakelock %s for WorkSpec %s", new Object[] { this.mWakeLock, this.mWorkSpecId }), new Throwable[0]);
        this.mWakeLock.release();
      } 
      return;
    } 
  }
  
  private void stopWork() {
    synchronized (this.mLock) {
      if (!this.mHasPendingStopWorkCommand) {
        Logger.get().debug(TAG, String.format("Stopping work for workspec %s", new Object[] { this.mWorkSpecId }), new Throwable[0]);
        Intent intent = CommandHandler.createStopWorkIntent(this.mContext, this.mWorkSpecId);
        this.mDispatcher.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(this.mDispatcher, intent, this.mStartId));
        if (this.mDispatcher.getProcessor().isEnqueued(this.mWorkSpecId)) {
          Logger.get().debug(TAG, String.format("WorkSpec %s needs to be rescheduled", new Object[] { this.mWorkSpecId }), new Throwable[0]);
          intent = CommandHandler.createScheduleWorkIntent(this.mContext, this.mWorkSpecId);
          this.mDispatcher.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(this.mDispatcher, intent, this.mStartId));
        } else {
          Logger.get().debug(TAG, String.format("Processor does not have WorkSpec %s. No need to reschedule ", new Object[] { this.mWorkSpecId }), new Throwable[0]);
        } 
        this.mHasPendingStopWorkCommand = true;
      } else {
        Logger.get().debug(TAG, String.format("Already stopped work for %s", new Object[] { this.mWorkSpecId }), new Throwable[0]);
      } 
      return;
    } 
  }
  
  @WorkerThread
  void handleProcessWork() {
    this.mWakeLock = WakeLocks.newWakeLock(this.mContext, String.format("%s (%s)", new Object[] { this.mWorkSpecId, Integer.valueOf(this.mStartId) }));
    Logger.get().debug(TAG, String.format("Acquiring wakelock %s for WorkSpec %s", new Object[] { this.mWakeLock, this.mWorkSpecId }), new Throwable[0]);
    this.mWakeLock.acquire();
    WorkSpec workSpec = this.mDispatcher.getWorkManager().getWorkDatabase().workSpecDao().getWorkSpec(this.mWorkSpecId);
    if (workSpec == null) {
      stopWork();
      return;
    } 
    this.mHasConstraints = workSpec.hasConstraints();
    if (!this.mHasConstraints) {
      Logger.get().debug(TAG, String.format("No constraints for %s", new Object[] { this.mWorkSpecId }), new Throwable[0]);
      onAllConstraintsMet(Collections.singletonList(this.mWorkSpecId));
      return;
    } 
    this.mWorkConstraintsTracker.replace(Collections.singletonList(workSpec));
  }
  
  public void onAllConstraintsMet(@NonNull List<String> paramList) {
    if (!paramList.contains(this.mWorkSpecId))
      return; 
    Logger.get().debug(TAG, String.format("onAllConstraintsMet for %s", new Object[] { this.mWorkSpecId }), new Throwable[0]);
    if (this.mDispatcher.getProcessor().startWork(this.mWorkSpecId)) {
      this.mDispatcher.getWorkTimer().startTimer(this.mWorkSpecId, 600000L, this);
      return;
    } 
    cleanUp();
  }
  
  public void onAllConstraintsNotMet(@NonNull List<String> paramList) { stopWork(); }
  
  public void onExecuted(@NonNull String paramString, boolean paramBoolean) {
    Logger.get().debug(TAG, String.format("onExecuted %s, %s", new Object[] { paramString, Boolean.valueOf(paramBoolean) }), new Throwable[0]);
    cleanUp();
    if (paramBoolean) {
      Intent intent = CommandHandler.createScheduleWorkIntent(this.mContext, this.mWorkSpecId);
      SystemAlarmDispatcher systemAlarmDispatcher = this.mDispatcher;
      systemAlarmDispatcher.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(systemAlarmDispatcher, intent, this.mStartId));
    } 
    if (this.mHasConstraints) {
      Intent intent = CommandHandler.createConstraintsChangedIntent(this.mContext);
      SystemAlarmDispatcher systemAlarmDispatcher = this.mDispatcher;
      systemAlarmDispatcher.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(systemAlarmDispatcher, intent, this.mStartId));
    } 
  }
  
  public void onTimeLimitExceeded(@NonNull String paramString) {
    Logger.get().debug(TAG, String.format("Exceeded time limits on execution for %s", new Object[] { paramString }), new Throwable[0]);
    stopWork();
  }
}

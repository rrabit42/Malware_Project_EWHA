package com.squareup.otto;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

final class AnnotatedHandlerFinder {
  private static final Map<Class<?>, Map<Class<?>, Method>> PRODUCERS_CACHE = new HashMap();
  
  private static final Map<Class<?>, Map<Class<?>, Set<Method>>> SUBSCRIBERS_CACHE = new HashMap();
  
  static Map<Class<?>, EventProducer> findAllProducers(Object paramObject) {
    Class clazz = paramObject.getClass();
    HashMap hashMap = new HashMap();
    if (!PRODUCERS_CACHE.containsKey(clazz))
      loadAnnotatedMethods(clazz); 
    Map map = (Map)PRODUCERS_CACHE.get(clazz);
    if (!map.isEmpty())
      for (Map.Entry entry : map.entrySet()) {
        EventProducer eventProducer = new EventProducer(paramObject, (Method)entry.getValue());
        hashMap.put(entry.getKey(), eventProducer);
      }  
    return hashMap;
  }
  
  static Map<Class<?>, Set<EventHandler>> findAllSubscribers(Object paramObject) {
    Class clazz = paramObject.getClass();
    HashMap hashMap = new HashMap();
    if (!SUBSCRIBERS_CACHE.containsKey(clazz))
      loadAnnotatedMethods(clazz); 
    Map map = (Map)SUBSCRIBERS_CACHE.get(clazz);
    if (!map.isEmpty())
      for (Map.Entry entry : map.entrySet()) {
        HashSet hashSet = new HashSet();
        Iterator iterator = ((Set)entry.getValue()).iterator();
        while (iterator.hasNext())
          hashSet.add(new EventHandler(paramObject, (Method)iterator.next())); 
        hashMap.put(entry.getKey(), hashSet);
      }  
    return hashMap;
  }
  
  private static void loadAnnotatedMethods(Class<?> paramClass) {
    StringBuilder stringBuilder;
    HashMap hashMap1 = new HashMap();
    HashMap hashMap2 = new HashMap();
    for (Method method : paramClass.getDeclaredMethods()) {
      if (!method.isBridge())
        if (method.isAnnotationPresent(Subscribe.class)) {
          Set set = method.getParameterTypes();
          if (set.length == 1) {
            Class clazz = set[0];
            if (!clazz.isInterface()) {
              if ((true & method.getModifiers()) != 0) {
                Set set1 = (Set)hashMap1.get(clazz);
                set = set1;
                if (set1 == null) {
                  set = new HashSet();
                  hashMap1.put(clazz, set);
                } 
                set.add(method);
              } else {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Method ");
                stringBuilder.append(method);
                stringBuilder.append(" has @Subscribe annotation on ");
                stringBuilder.append(clazz);
                stringBuilder.append(" but is not 'public'.");
                throw new IllegalArgumentException(stringBuilder.toString());
              } 
            } else {
              stringBuilder = new StringBuilder();
              stringBuilder.append("Method ");
              stringBuilder.append(method);
              stringBuilder.append(" has @Subscribe annotation on ");
              stringBuilder.append(clazz);
              stringBuilder.append(" which is an interface.  Subscription must be on a concrete class type.");
              throw new IllegalArgumentException(stringBuilder.toString());
            } 
          } else {
            stringBuilder = new StringBuilder();
            stringBuilder.append("Method ");
            stringBuilder.append(method);
            stringBuilder.append(" has @Subscribe annotation but requires ");
            stringBuilder.append(set.length);
            stringBuilder.append(" arguments.  Methods must require a single argument.");
            throw new IllegalArgumentException(stringBuilder.toString());
          } 
        } else if (method.isAnnotationPresent(Produce.class)) {
          Class clazz = method.getParameterTypes();
          if (clazz.length == 0) {
            if (method.getReturnType() != Void.class) {
              clazz = method.getReturnType();
              if (!clazz.isInterface()) {
                if (!clazz.equals(void.class)) {
                  if ((true & method.getModifiers()) != 0) {
                    if (!hashMap2.containsKey(clazz)) {
                      hashMap2.put(clazz, method);
                    } else {
                      stringBuilder = new StringBuilder();
                      stringBuilder.append("Producer for type ");
                      stringBuilder.append(clazz);
                      stringBuilder.append(" has already been registered.");
                      throw new IllegalArgumentException(stringBuilder.toString());
                    } 
                  } else {
                    stringBuilder = new StringBuilder();
                    stringBuilder.append("Method ");
                    stringBuilder.append(method);
                    stringBuilder.append(" has @Produce annotation on ");
                    stringBuilder.append(clazz);
                    stringBuilder.append(" but is not 'public'.");
                    throw new IllegalArgumentException(stringBuilder.toString());
                  } 
                } else {
                  stringBuilder = new StringBuilder();
                  stringBuilder.append("Method ");
                  stringBuilder.append(method);
                  stringBuilder.append(" has @Produce annotation but has no return type.");
                  throw new IllegalArgumentException(stringBuilder.toString());
                } 
              } else {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Method ");
                stringBuilder.append(method);
                stringBuilder.append(" has @Produce annotation on ");
                stringBuilder.append(clazz);
                stringBuilder.append(" which is an interface.  Producers must return a concrete class type.");
                throw new IllegalArgumentException(stringBuilder.toString());
              } 
            } else {
              stringBuilder = new StringBuilder();
              stringBuilder.append("Method ");
              stringBuilder.append(method);
              stringBuilder.append(" has a return type of void.  Must declare a non-void type.");
              throw new IllegalArgumentException(stringBuilder.toString());
            } 
          } else {
            stringBuilder = new StringBuilder();
            stringBuilder.append("Method ");
            stringBuilder.append(method);
            stringBuilder.append("has @Produce annotation but requires ");
            stringBuilder.append(clazz.length);
            stringBuilder.append(" arguments.  Methods must require zero arguments.");
            throw new IllegalArgumentException(stringBuilder.toString());
          } 
        }  
    } 
    PRODUCERS_CACHE.put(stringBuilder, hashMap2);
    SUBSCRIBERS_CACHE.put(stringBuilder, hashMap1);
  }
}

package android.arch.persistence.room;

import android.arch.core.executor.ArchTaskExecutor;
import android.arch.persistence.db.SimpleSQLiteQuery;
import android.arch.persistence.db.SupportSQLiteDatabase;
import android.arch.persistence.db.SupportSQLiteOpenHelper;
import android.arch.persistence.db.SupportSQLiteQuery;
import android.arch.persistence.db.SupportSQLiteStatement;
import android.database.Cursor;
import android.os.Build;
import android.support.annotation.CallSuper;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RestrictTo;
import android.support.annotation.WorkerThread;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public abstract class RoomDatabase {
  private static final String DB_IMPL_SUFFIX = "_Impl";
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public static final int MAX_BIND_PARAMETER_CNT = 999;
  
  private boolean mAllowMainThreadQueries;
  
  @Nullable
  protected List<Callback> mCallbacks;
  
  private final ReentrantLock mCloseLock = new ReentrantLock();
  
  private final InvalidationTracker mInvalidationTracker = createInvalidationTracker();
  
  private SupportSQLiteOpenHelper mOpenHelper;
  
  boolean mWriteAheadLoggingEnabled;
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public void assertNotMainThread() {
    if (this.mAllowMainThreadQueries)
      return; 
    if (!ArchTaskExecutor.getInstance().isMainThread())
      return; 
    throw new IllegalStateException("Cannot access database on the main thread since it may potentially lock the UI for a long period of time.");
  }
  
  public void beginTransaction() {
    assertNotMainThread();
    SupportSQLiteDatabase supportSQLiteDatabase = this.mOpenHelper.getWritableDatabase();
    this.mInvalidationTracker.syncTriggers(supportSQLiteDatabase);
    supportSQLiteDatabase.beginTransaction();
  }
  
  @WorkerThread
  public abstract void clearAllTables();
  
  public void close() {
    if (isOpen())
      try {
        this.mCloseLock.lock();
        this.mOpenHelper.close();
        return;
      } finally {
        this.mCloseLock.unlock();
      }  
  }
  
  public SupportSQLiteStatement compileStatement(@NonNull String paramString) {
    assertNotMainThread();
    return this.mOpenHelper.getWritableDatabase().compileStatement(paramString);
  }
  
  @NonNull
  protected abstract InvalidationTracker createInvalidationTracker();
  
  @NonNull
  protected abstract SupportSQLiteOpenHelper createOpenHelper(DatabaseConfiguration paramDatabaseConfiguration);
  
  public void endTransaction() {
    this.mOpenHelper.getWritableDatabase().endTransaction();
    if (!inTransaction())
      this.mInvalidationTracker.refreshVersionsAsync(); 
  }
  
  Lock getCloseLock() { return this.mCloseLock; }
  
  @NonNull
  public InvalidationTracker getInvalidationTracker() { return this.mInvalidationTracker; }
  
  @NonNull
  public SupportSQLiteOpenHelper getOpenHelper() { return this.mOpenHelper; }
  
  public boolean inTransaction() { return this.mOpenHelper.getWritableDatabase().inTransaction(); }
  
  @CallSuper
  public void init(@NonNull DatabaseConfiguration paramDatabaseConfiguration) {
    this.mOpenHelper = createOpenHelper(paramDatabaseConfiguration);
    int i = Build.VERSION.SDK_INT;
    int j = 0;
    byte b = 0;
    if (i >= 16) {
      j = b;
      if (paramDatabaseConfiguration.journalMode == JournalMode.WRITE_AHEAD_LOGGING)
        j = 1; 
      this.mOpenHelper.setWriteAheadLoggingEnabled(j);
    } 
    this.mCallbacks = paramDatabaseConfiguration.callbacks;
    this.mAllowMainThreadQueries = paramDatabaseConfiguration.allowMainThreadQueries;
    this.mWriteAheadLoggingEnabled = j;
  }
  
  protected void internalInitInvalidationTracker(@NonNull SupportSQLiteDatabase paramSupportSQLiteDatabase) { this.mInvalidationTracker.internalInit(paramSupportSQLiteDatabase); }
  
  public boolean isOpen() {
    SupportSQLiteDatabase supportSQLiteDatabase = this.mDatabase;
    return (supportSQLiteDatabase != null && supportSQLiteDatabase.isOpen());
  }
  
  public Cursor query(SupportSQLiteQuery paramSupportSQLiteQuery) {
    assertNotMainThread();
    return this.mOpenHelper.getWritableDatabase().query(paramSupportSQLiteQuery);
  }
  
  public Cursor query(String paramString, @Nullable Object[] paramArrayOfObject) { return this.mOpenHelper.getWritableDatabase().query(new SimpleSQLiteQuery(paramString, paramArrayOfObject)); }
  
  public <V> V runInTransaction(@NonNull Callable<V> paramCallable) {
    beginTransaction();
    try {
      Object object = paramCallable.call();
      setTransactionSuccessful();
      endTransaction();
      return (V)object;
    } catch (RuntimeException paramCallable) {
      throw paramCallable;
    } catch (Exception paramCallable) {
      throw new RuntimeException("Exception in transaction", paramCallable);
    } finally {}
    endTransaction();
    throw paramCallable;
  }
  
  public void runInTransaction(@NonNull Runnable paramRunnable) {
    beginTransaction();
    try {
      paramRunnable.run();
      setTransactionSuccessful();
      return;
    } finally {
      endTransaction();
    } 
  }
  
  public void setTransactionSuccessful() { this.mOpenHelper.getWritableDatabase().setTransactionSuccessful(); }
}

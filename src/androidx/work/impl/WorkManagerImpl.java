package androidx.work.impl;

import android.arch.lifecycle.LiveData;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RestrictTo;
import androidx.work.Configuration;
import androidx.work.ExistingPeriodicWorkPolicy;
import androidx.work.ExistingWorkPolicy;
import androidx.work.Logger;
import androidx.work.OneTimeWorkRequest;
import androidx.work.Operation;
import androidx.work.PeriodicWorkRequest;
import androidx.work.R;
import androidx.work.WorkContinuation;
import androidx.work.WorkInfo;
import androidx.work.WorkManager;
import androidx.work.WorkRequest;
import androidx.work.WorkerParameters;
import androidx.work.impl.background.greedy.GreedyScheduler;
import androidx.work.impl.background.systemjob.SystemJobScheduler;
import androidx.work.impl.model.WorkSpec;
import androidx.work.impl.utils.CancelWorkRunnable;
import androidx.work.impl.utils.ForceStopRunnable;
import androidx.work.impl.utils.LiveDataUtils;
import androidx.work.impl.utils.Preferences;
import androidx.work.impl.utils.PruneWorkRunnable;
import androidx.work.impl.utils.StartWorkRunnable;
import androidx.work.impl.utils.StatusRunnable;
import androidx.work.impl.utils.StopWorkRunnable;
import androidx.work.impl.utils.futures.SettableFuture;
import androidx.work.impl.utils.taskexecutor.TaskExecutor;
import androidx.work.impl.utils.taskexecutor.WorkManagerTaskExecutor;
import com.google.common.util.concurrent.ListenableFuture;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class WorkManagerImpl extends WorkManager {
  public static final int MAX_PRE_JOB_SCHEDULER_API_LEVEL = 22;
  
  public static final int MIN_JOB_SCHEDULER_API_LEVEL = 23;
  
  private static WorkManagerImpl sDefaultInstance;
  
  private static WorkManagerImpl sDelegatedInstance;
  
  private static final Object sLock = new Object();
  
  private Configuration mConfiguration;
  
  private Context mContext;
  
  private boolean mForceStopRunnableCompleted;
  
  private final WorkManagerLiveDataTracker mLiveDataTracker = new WorkManagerLiveDataTracker();
  
  private Preferences mPreferences;
  
  private Processor mProcessor;
  
  private BroadcastReceiver.PendingResult mRescheduleReceiverResult;
  
  private List<Scheduler> mSchedulers;
  
  private WorkDatabase mWorkDatabase;
  
  private TaskExecutor mWorkTaskExecutor;
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public WorkManagerImpl(@NonNull Context paramContext, @NonNull Configuration paramConfiguration, @NonNull TaskExecutor paramTaskExecutor) { this(paramContext, paramConfiguration, paramTaskExecutor, paramContext.getResources().getBoolean(R.bool.workmanager_test_configuration)); }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public WorkManagerImpl(@NonNull Context paramContext, @NonNull Configuration paramConfiguration, @NonNull TaskExecutor paramTaskExecutor, @NonNull WorkDatabase paramWorkDatabase, @NonNull List<Scheduler> paramList, @NonNull Processor paramProcessor) { internalInit(paramContext, paramConfiguration, paramTaskExecutor, paramWorkDatabase, paramList, paramProcessor); }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public WorkManagerImpl(@NonNull Context paramContext, @NonNull Configuration paramConfiguration, @NonNull TaskExecutor paramTaskExecutor, boolean paramBoolean) {
    Context context = paramContext.getApplicationContext();
    WorkDatabase workDatabase = WorkDatabase.create(context, paramBoolean);
    Logger.setLogger(new Logger.LogcatLogger(paramConfiguration.getMinimumLoggingLevel()));
    List list = createSchedulers(context);
    internalInit(paramContext, paramConfiguration, paramTaskExecutor, workDatabase, list, new Processor(paramContext, paramConfiguration, paramTaskExecutor, workDatabase, list));
  }
  
  private WorkContinuationImpl createWorkContinuationForUniquePeriodicWork(@NonNull String paramString, @NonNull ExistingPeriodicWorkPolicy paramExistingPeriodicWorkPolicy, @NonNull PeriodicWorkRequest paramPeriodicWorkRequest) {
    ExistingWorkPolicy existingWorkPolicy;
    if (paramExistingPeriodicWorkPolicy == ExistingPeriodicWorkPolicy.KEEP) {
      existingWorkPolicy = ExistingWorkPolicy.KEEP;
    } else {
      existingWorkPolicy = ExistingWorkPolicy.REPLACE;
    } 
    return new WorkContinuationImpl(this, paramString, existingWorkPolicy, Collections.singletonList(paramPeriodicWorkRequest));
  }
  
  @Nullable
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public static WorkManagerImpl getInstance() {
    synchronized (sLock) {
      if (sDelegatedInstance != null)
        return sDelegatedInstance; 
      return sDefaultInstance;
    } 
  }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public static void initialize(@NonNull Context paramContext, @NonNull Configuration paramConfiguration) {
    synchronized (sLock) {
      if (sDelegatedInstance == null || sDefaultInstance == null) {
        if (sDelegatedInstance == null) {
          paramContext = paramContext.getApplicationContext();
          if (sDefaultInstance == null)
            sDefaultInstance = new WorkManagerImpl(paramContext, paramConfiguration, new WorkManagerTaskExecutor()); 
          sDelegatedInstance = sDefaultInstance;
        } 
        return;
      } 
      throw new IllegalStateException("WorkManager is already initialized.  Did you try to initialize it manually without disabling WorkManagerInitializer? See WorkManager#initialize(Context, Configuration) or the class levelJavadoc for more information.");
    } 
  }
  
  private void internalInit(@NonNull Context paramContext, @NonNull Configuration paramConfiguration, @NonNull TaskExecutor paramTaskExecutor, @NonNull WorkDatabase paramWorkDatabase, @NonNull List<Scheduler> paramList, @NonNull Processor paramProcessor) {
    paramContext = paramContext.getApplicationContext();
    this.mContext = paramContext;
    this.mConfiguration = paramConfiguration;
    this.mWorkTaskExecutor = paramTaskExecutor;
    this.mWorkDatabase = paramWorkDatabase;
    this.mSchedulers = paramList;
    this.mProcessor = paramProcessor;
    this.mPreferences = new Preferences(this.mContext);
    this.mForceStopRunnableCompleted = false;
    this.mWorkTaskExecutor.executeOnBackgroundThread(new ForceStopRunnable(paramContext, this));
  }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public static void setDelegate(WorkManagerImpl paramWorkManagerImpl) {
    synchronized (sLock) {
      sDelegatedInstance = paramWorkManagerImpl;
      return;
    } 
  }
  
  @NonNull
  public WorkContinuation beginUniqueWork(@NonNull String paramString, @NonNull ExistingWorkPolicy paramExistingWorkPolicy, @NonNull List<OneTimeWorkRequest> paramList) {
    if (!paramList.isEmpty())
      return new WorkContinuationImpl(this, paramString, paramExistingWorkPolicy, paramList); 
    throw new IllegalArgumentException("beginUniqueWork needs at least one OneTimeWorkRequest.");
  }
  
  @NonNull
  public WorkContinuation beginWith(@NonNull List<OneTimeWorkRequest> paramList) {
    if (!paramList.isEmpty())
      return new WorkContinuationImpl(this, paramList); 
    throw new IllegalArgumentException("beginWith needs at least one OneTimeWorkRequest.");
  }
  
  @NonNull
  public Operation cancelAllWork() {
    CancelWorkRunnable cancelWorkRunnable = CancelWorkRunnable.forAll(this);
    this.mWorkTaskExecutor.executeOnBackgroundThread(cancelWorkRunnable);
    return cancelWorkRunnable.getOperation();
  }
  
  @NonNull
  public Operation cancelAllWorkByTag(@NonNull String paramString) {
    CancelWorkRunnable cancelWorkRunnable = CancelWorkRunnable.forTag(paramString, this);
    this.mWorkTaskExecutor.executeOnBackgroundThread(cancelWorkRunnable);
    return cancelWorkRunnable.getOperation();
  }
  
  @NonNull
  public Operation cancelUniqueWork(@NonNull String paramString) {
    CancelWorkRunnable cancelWorkRunnable = CancelWorkRunnable.forName(paramString, this, true);
    this.mWorkTaskExecutor.executeOnBackgroundThread(cancelWorkRunnable);
    return cancelWorkRunnable.getOperation();
  }
  
  @NonNull
  public Operation cancelWorkById(@NonNull UUID paramUUID) {
    CancelWorkRunnable cancelWorkRunnable = CancelWorkRunnable.forId(paramUUID, this);
    this.mWorkTaskExecutor.executeOnBackgroundThread(cancelWorkRunnable);
    return cancelWorkRunnable.getOperation();
  }
  
  @NonNull
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public List<Scheduler> createSchedulers(Context paramContext) { return Arrays.asList(new Scheduler[] { Schedulers.createBestAvailableBackgroundScheduler(paramContext, this), new GreedyScheduler(paramContext, this) }); }
  
  @NonNull
  public Operation enqueue(@NonNull List<? extends WorkRequest> paramList) {
    if (!paramList.isEmpty())
      return (new WorkContinuationImpl(this, paramList)).enqueue(); 
    throw new IllegalArgumentException("enqueue needs at least one WorkRequest.");
  }
  
  @NonNull
  public Operation enqueueUniquePeriodicWork(@NonNull String paramString, @NonNull ExistingPeriodicWorkPolicy paramExistingPeriodicWorkPolicy, @NonNull PeriodicWorkRequest paramPeriodicWorkRequest) { return createWorkContinuationForUniquePeriodicWork(paramString, paramExistingPeriodicWorkPolicy, paramPeriodicWorkRequest).enqueue(); }
  
  @NonNull
  public Operation enqueueUniqueWork(@NonNull String paramString, @NonNull ExistingWorkPolicy paramExistingWorkPolicy, @NonNull List<OneTimeWorkRequest> paramList) { return (new WorkContinuationImpl(this, paramString, paramExistingWorkPolicy, paramList)).enqueue(); }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public Context getApplicationContext() { return this.mContext; }
  
  @NonNull
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public Configuration getConfiguration() { return this.mConfiguration; }
  
  @NonNull
  public ListenableFuture<Long> getLastCancelAllTimeMillis() {
    SettableFuture settableFuture = SettableFuture.create();
    Preferences preferences = this.mPreferences;
    this.mWorkTaskExecutor.executeOnBackgroundThread(new Object(this, settableFuture, preferences));
    return settableFuture;
  }
  
  @NonNull
  public LiveData<Long> getLastCancelAllTimeMillisLiveData() { return this.mPreferences.getLastCancelAllTimeMillisLiveData(); }
  
  @NonNull
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public Preferences getPreferences() { return this.mPreferences; }
  
  @NonNull
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public Processor getProcessor() { return this.mProcessor; }
  
  @NonNull
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public List<Scheduler> getSchedulers() { return this.mSchedulers; }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public WorkDatabase getWorkDatabase() { return this.mWorkDatabase; }
  
  @NonNull
  public ListenableFuture<WorkInfo> getWorkInfoById(@NonNull UUID paramUUID) {
    StatusRunnable statusRunnable = StatusRunnable.forUUID(this, paramUUID);
    this.mWorkTaskExecutor.getBackgroundExecutor().execute(statusRunnable);
    return statusRunnable.getFuture();
  }
  
  @NonNull
  public LiveData<WorkInfo> getWorkInfoByIdLiveData(@NonNull UUID paramUUID) {
    LiveData liveData = LiveDataUtils.dedupedMappedLiveDataFor(this.mWorkDatabase.workSpecDao().getWorkStatusPojoLiveDataForIds(Collections.singletonList(paramUUID.toString())), new Object(this), this.mWorkTaskExecutor);
    return this.mLiveDataTracker.track(liveData);
  }
  
  LiveData<List<WorkInfo>> getWorkInfosById(@NonNull List<String> paramList) {
    LiveData liveData = LiveDataUtils.dedupedMappedLiveDataFor(this.mWorkDatabase.workSpecDao().getWorkStatusPojoLiveDataForIds(paramList), WorkSpec.WORK_INFO_MAPPER, this.mWorkTaskExecutor);
    return this.mLiveDataTracker.track(liveData);
  }
  
  @NonNull
  public ListenableFuture<List<WorkInfo>> getWorkInfosByTag(@NonNull String paramString) {
    StatusRunnable statusRunnable = StatusRunnable.forTag(this, paramString);
    this.mWorkTaskExecutor.getBackgroundExecutor().execute(statusRunnable);
    return statusRunnable.getFuture();
  }
  
  @NonNull
  public LiveData<List<WorkInfo>> getWorkInfosByTagLiveData(@NonNull String paramString) {
    LiveData liveData = LiveDataUtils.dedupedMappedLiveDataFor(this.mWorkDatabase.workSpecDao().getWorkStatusPojoLiveDataForTag(paramString), WorkSpec.WORK_INFO_MAPPER, this.mWorkTaskExecutor);
    return this.mLiveDataTracker.track(liveData);
  }
  
  @NonNull
  public ListenableFuture<List<WorkInfo>> getWorkInfosForUniqueWork(@NonNull String paramString) {
    StatusRunnable statusRunnable = StatusRunnable.forUniqueWork(this, paramString);
    this.mWorkTaskExecutor.getBackgroundExecutor().execute(statusRunnable);
    return statusRunnable.getFuture();
  }
  
  @NonNull
  public LiveData<List<WorkInfo>> getWorkInfosForUniqueWorkLiveData(@NonNull String paramString) {
    LiveData liveData = LiveDataUtils.dedupedMappedLiveDataFor(this.mWorkDatabase.workSpecDao().getWorkStatusPojoLiveDataForName(paramString), WorkSpec.WORK_INFO_MAPPER, this.mWorkTaskExecutor);
    return this.mLiveDataTracker.track(liveData);
  }
  
  @NonNull
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public TaskExecutor getWorkTaskExecutor() { return this.mWorkTaskExecutor; }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public void onForceStopRunnableCompleted() {
    synchronized (sLock) {
      this.mForceStopRunnableCompleted = true;
      if (this.mRescheduleReceiverResult != null) {
        this.mRescheduleReceiverResult.finish();
        this.mRescheduleReceiverResult = null;
      } 
      return;
    } 
  }
  
  @NonNull
  public Operation pruneWork() {
    PruneWorkRunnable pruneWorkRunnable = new PruneWorkRunnable(this);
    this.mWorkTaskExecutor.executeOnBackgroundThread(pruneWorkRunnable);
    return pruneWorkRunnable.getOperation();
  }
  
  public void rescheduleEligibleWork() {
    if (Build.VERSION.SDK_INT >= 23)
      SystemJobScheduler.jobSchedulerCancelAll(getApplicationContext()); 
    getWorkDatabase().workSpecDao().resetScheduledState();
    Schedulers.schedule(getConfiguration(), getWorkDatabase(), getSchedulers());
  }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public void setReschedulePendingResult(@NonNull BroadcastReceiver.PendingResult paramPendingResult) {
    synchronized (sLock) {
      this.mRescheduleReceiverResult = paramPendingResult;
      if (this.mForceStopRunnableCompleted) {
        this.mRescheduleReceiverResult.finish();
        this.mRescheduleReceiverResult = null;
      } 
      return;
    } 
  }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public void startWork(String paramString) { startWork(paramString, null); }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public void startWork(String paramString, WorkerParameters.RuntimeExtras paramRuntimeExtras) { this.mWorkTaskExecutor.executeOnBackgroundThread(new StartWorkRunnable(this, paramString, paramRuntimeExtras)); }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public void stopWork(String paramString) { this.mWorkTaskExecutor.executeOnBackgroundThread(new StopWorkRunnable(this, paramString)); }
}

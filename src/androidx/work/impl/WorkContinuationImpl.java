package androidx.work.impl;

import android.arch.lifecycle.LiveData;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RestrictTo;
import android.text.TextUtils;
import androidx.work.ExistingWorkPolicy;
import androidx.work.Logger;
import androidx.work.OneTimeWorkRequest;
import androidx.work.Operation;
import androidx.work.WorkContinuation;
import androidx.work.WorkInfo;
import androidx.work.WorkRequest;
import androidx.work.impl.utils.EnqueueRunnable;
import androidx.work.impl.utils.StatusRunnable;
import com.google.common.util.concurrent.ListenableFuture;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class WorkContinuationImpl extends WorkContinuation {
  private static final String TAG = Logger.tagWithPrefix("WorkContinuationImpl");
  
  private final List<String> mAllIds;
  
  private boolean mEnqueued;
  
  private final ExistingWorkPolicy mExistingWorkPolicy;
  
  private final List<String> mIds;
  
  private final String mName;
  
  private Operation mOperation;
  
  private final List<WorkContinuationImpl> mParents;
  
  private final List<? extends WorkRequest> mWork;
  
  private final WorkManagerImpl mWorkManagerImpl;
  
  WorkContinuationImpl(@NonNull WorkManagerImpl paramWorkManagerImpl, String paramString, ExistingWorkPolicy paramExistingWorkPolicy, @NonNull List<? extends WorkRequest> paramList) { this(paramWorkManagerImpl, paramString, paramExistingWorkPolicy, paramList, null); }
  
  WorkContinuationImpl(@NonNull WorkManagerImpl paramWorkManagerImpl, String paramString, ExistingWorkPolicy paramExistingWorkPolicy, @NonNull List<? extends WorkRequest> paramList1, @Nullable List<WorkContinuationImpl> paramList2) {
    this.mWorkManagerImpl = paramWorkManagerImpl;
    this.mName = paramString;
    this.mExistingWorkPolicy = paramExistingWorkPolicy;
    this.mWork = paramList1;
    this.mParents = paramList2;
    this.mIds = new ArrayList(this.mWork.size());
    this.mAllIds = new ArrayList();
    if (paramList2 != null)
      for (WorkContinuationImpl workContinuationImpl : paramList2)
        this.mAllIds.addAll(workContinuationImpl.mAllIds);  
    byte b;
    for (b = 0; b < paramList1.size(); b++) {
      String str = ((WorkRequest)paramList1.get(b)).getStringId();
      this.mIds.add(str);
      this.mAllIds.add(str);
    } 
  }
  
  WorkContinuationImpl(@NonNull WorkManagerImpl paramWorkManagerImpl, @NonNull List<? extends WorkRequest> paramList) { this(paramWorkManagerImpl, null, ExistingWorkPolicy.KEEP, paramList, null); }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  private static boolean hasCycles(@NonNull WorkContinuationImpl paramWorkContinuationImpl, @NonNull Set<String> paramSet) {
    paramSet.addAll(paramWorkContinuationImpl.getIds());
    Set set = prerequisitesFor(paramWorkContinuationImpl);
    Iterator iterator = paramSet.iterator();
    while (iterator.hasNext()) {
      if (set.contains((String)iterator.next()))
        return true; 
    } 
    List list = paramWorkContinuationImpl.getParents();
    if (list != null && !list.isEmpty()) {
      Iterator iterator1 = list.iterator();
      while (iterator1.hasNext()) {
        if (hasCycles((WorkContinuationImpl)iterator1.next(), paramSet))
          return true; 
      } 
    } 
    paramSet.removeAll(paramWorkContinuationImpl.getIds());
    return false;
  }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public static Set<String> prerequisitesFor(WorkContinuationImpl paramWorkContinuationImpl) {
    HashSet hashSet = new HashSet();
    List list = paramWorkContinuationImpl.getParents();
    if (list != null && !list.isEmpty()) {
      Iterator iterator = list.iterator();
      while (iterator.hasNext())
        hashSet.addAll(((WorkContinuationImpl)iterator.next()).getIds()); 
    } 
    return hashSet;
  }
  
  @NonNull
  protected WorkContinuation combineInternal(@NonNull List<WorkContinuation> paramList) {
    OneTimeWorkRequest oneTimeWorkRequest = (OneTimeWorkRequest)(new OneTimeWorkRequest.Builder(androidx.work.impl.workers.CombineContinuationsWorker.class)).setInputMerger(androidx.work.ArrayCreatingInputMerger.class).build();
    ArrayList arrayList = new ArrayList(paramList.size());
    Iterator iterator = paramList.iterator();
    while (iterator.hasNext())
      arrayList.add((WorkContinuationImpl)iterator.next()); 
    return new WorkContinuationImpl(this.mWorkManagerImpl, null, ExistingWorkPolicy.KEEP, Collections.singletonList(oneTimeWorkRequest), arrayList);
  }
  
  @NonNull
  public Operation enqueue() {
    if (!this.mEnqueued) {
      EnqueueRunnable enqueueRunnable = new EnqueueRunnable(this);
      this.mWorkManagerImpl.getWorkTaskExecutor().executeOnBackgroundThread(enqueueRunnable);
      this.mOperation = enqueueRunnable.getOperation();
    } else {
      Logger.get().warning(TAG, String.format("Already enqueued work ids (%s)", new Object[] { TextUtils.join(", ", this.mIds) }), new Throwable[0]);
    } 
    return this.mOperation;
  }
  
  public List<String> getAllIds() { return this.mAllIds; }
  
  public ExistingWorkPolicy getExistingWorkPolicy() { return this.mExistingWorkPolicy; }
  
  @NonNull
  public List<String> getIds() { return this.mIds; }
  
  @Nullable
  public String getName() { return this.mName; }
  
  public List<WorkContinuationImpl> getParents() { return this.mParents; }
  
  @NonNull
  public List<? extends WorkRequest> getWork() { return this.mWork; }
  
  @NonNull
  public ListenableFuture<List<WorkInfo>> getWorkInfos() {
    StatusRunnable statusRunnable = StatusRunnable.forStringIds(this.mWorkManagerImpl, this.mAllIds);
    this.mWorkManagerImpl.getWorkTaskExecutor().executeOnBackgroundThread(statusRunnable);
    return statusRunnable.getFuture();
  }
  
  @NonNull
  public LiveData<List<WorkInfo>> getWorkInfosLiveData() { return this.mWorkManagerImpl.getWorkInfosById(this.mAllIds); }
  
  @NonNull
  public WorkManagerImpl getWorkManagerImpl() { return this.mWorkManagerImpl; }
  
  @RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
  public boolean hasCycles() { return hasCycles(this, new HashSet()); }
  
  public boolean isEnqueued() { return this.mEnqueued; }
  
  public void markEnqueued() { this.mEnqueued = true; }
  
  @NonNull
  public WorkContinuation then(List<OneTimeWorkRequest> paramList) { return new WorkContinuationImpl(this.mWorkManagerImpl, this.mName, ExistingWorkPolicy.KEEP, paramList, Collections.singletonList(this)); }
}

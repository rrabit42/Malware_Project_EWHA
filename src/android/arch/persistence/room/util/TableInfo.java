package android.arch.persistence.room.util;

import android.arch.persistence.db.SupportSQLiteDatabase;
import android.database.Cursor;
import android.support.annotation.Nullable;
import android.support.annotation.RestrictTo;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
public class TableInfo {
  public final Map<String, Column> columns;
  
  public final Set<ForeignKey> foreignKeys;
  
  @Nullable
  public final Set<Index> indices;
  
  public final String name;
  
  public TableInfo(String paramString, Map<String, Column> paramMap, Set<ForeignKey> paramSet) { this(paramString, paramMap, paramSet, Collections.emptySet()); }
  
  public TableInfo(String paramString, Map<String, Column> paramMap, Set<ForeignKey> paramSet1, Set<Index> paramSet2) {
    this.name = paramString;
    this.columns = Collections.unmodifiableMap(paramMap);
    this.foreignKeys = Collections.unmodifiableSet(paramSet1);
    if (paramSet2 == null) {
      paramString = null;
    } else {
      set = Collections.unmodifiableSet(paramSet2);
    } 
    this.indices = set;
  }
  
  public static TableInfo read(SupportSQLiteDatabase paramSupportSQLiteDatabase, String paramString) { return new TableInfo(paramString, readColumns(paramSupportSQLiteDatabase, paramString), readForeignKeys(paramSupportSQLiteDatabase, paramString), readIndices(paramSupportSQLiteDatabase, paramString)); }
  
  private static Map<String, Column> readColumns(SupportSQLiteDatabase paramSupportSQLiteDatabase, String paramString) {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("PRAGMA table_info(`");
    stringBuilder.append(paramString);
    stringBuilder.append("`)");
    cursor = paramSupportSQLiteDatabase.query(stringBuilder.toString());
    null = new HashMap();
    try {
      if (cursor.getColumnCount() > 0) {
        int i = cursor.getColumnIndex("name");
        int j = cursor.getColumnIndex("type");
        int k = cursor.getColumnIndex("notnull");
        int m = cursor.getColumnIndex("pk");
        while (true) {
          if (cursor.moveToNext()) {
            boolean bool;
            String str1 = cursor.getString(i);
            String str2 = cursor.getString(j);
            if (cursor.getInt(k) != 0) {
              bool = true;
            } else {
              bool = false;
            } 
            null.put(str1, new Column(str1, str2, bool, cursor.getInt(m)));
            continue;
          } 
          return null;
        } 
      } 
      return null;
    } finally {
      cursor.close();
    } 
  }
  
  private static List<ForeignKeyWithSequence> readForeignKeyFieldMappings(Cursor paramCursor) {
    int i = paramCursor.getColumnIndex("id");
    int j = paramCursor.getColumnIndex("seq");
    int k = paramCursor.getColumnIndex("from");
    int m = paramCursor.getColumnIndex("to");
    int n = paramCursor.getCount();
    ArrayList arrayList = new ArrayList();
    for (byte b = 0; b < n; b++) {
      paramCursor.moveToPosition(b);
      arrayList.add(new ForeignKeyWithSequence(paramCursor.getInt(i), paramCursor.getInt(j), paramCursor.getString(k), paramCursor.getString(m)));
    } 
    Collections.sort(arrayList);
    return arrayList;
  }
  
  private static Set<ForeignKey> readForeignKeys(SupportSQLiteDatabase paramSupportSQLiteDatabase, String paramString) {
    hashSet = new HashSet();
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("PRAGMA foreign_key_list(`");
    stringBuilder.append(paramString);
    stringBuilder.append("`)");
    cursor = paramSupportSQLiteDatabase.query(stringBuilder.toString());
    try {
      int i = cursor.getColumnIndex("id");
      int j = cursor.getColumnIndex("seq");
      int k = cursor.getColumnIndex("table");
      int m = cursor.getColumnIndex("on_delete");
      int n = cursor.getColumnIndex("on_update");
      List list = readForeignKeyFieldMappings(cursor);
      int i1 = cursor.getCount();
      for (byte b = 0; b < i1; b++) {
        cursor.moveToPosition(b);
        if (cursor.getInt(j) == 0) {
          int i2 = cursor.getInt(i);
          ArrayList arrayList1 = new ArrayList();
          ArrayList arrayList2 = new ArrayList();
          for (ForeignKeyWithSequence foreignKeyWithSequence : list) {
            if (foreignKeyWithSequence.mId == i2) {
              arrayList1.add(foreignKeyWithSequence.mFrom);
              arrayList2.add(foreignKeyWithSequence.mTo);
            } 
          } 
          hashSet.add(new ForeignKey(cursor.getString(k), cursor.getString(m), cursor.getString(n), arrayList1, arrayList2));
        } 
      } 
      return hashSet;
    } finally {
      cursor.close();
    } 
  }
  
  @Nullable
  private static Index readIndex(SupportSQLiteDatabase paramSupportSQLiteDatabase, String paramString, boolean paramBoolean) {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("PRAGMA index_xinfo(`");
    stringBuilder.append(paramString);
    stringBuilder.append("`)");
    cursor = paramSupportSQLiteDatabase.query(stringBuilder.toString());
    try {
      int i = cursor.getColumnIndex("seqno");
      int j = cursor.getColumnIndex("cid");
      int k = cursor.getColumnIndex("name");
      if (i == -1 || j == -1 || k == -1)
        return null; 
      TreeMap treeMap = new TreeMap();
      while (cursor.moveToNext()) {
        if (cursor.getInt(j) < 0)
          continue; 
        treeMap.put(Integer.valueOf(cursor.getInt(i)), cursor.getString(k));
      } 
      ArrayList arrayList = new ArrayList(treeMap.size());
      arrayList.addAll(treeMap.values());
      return new Index(paramString, paramBoolean, arrayList);
    } finally {
      cursor.close();
    } 
  }
  
  @Nullable
  private static Set<Index> readIndices(SupportSQLiteDatabase paramSupportSQLiteDatabase, String paramString) {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("PRAGMA index_list(`");
    stringBuilder.append(paramString);
    stringBuilder.append("`)");
    cursor = paramSupportSQLiteDatabase.query(stringBuilder.toString());
    try {
      int i = cursor.getColumnIndex("name");
      int j = cursor.getColumnIndex("origin");
      int k = cursor.getColumnIndex("unique");
      if (i == -1 || j == -1 || k == -1)
        return null; 
      hashSet = new HashSet();
      while (true) {
        if (cursor.moveToNext()) {
          if (!"c".equals(cursor.getString(j)))
            continue; 
          String str = cursor.getString(i);
          int m = cursor.getInt(k);
          boolean bool = true;
          if (m != 1)
            bool = false; 
          Index index = readIndex(paramSupportSQLiteDatabase, str, bool);
          if (index == null)
            return null; 
          hashSet.add(index);
          continue;
        } 
        return hashSet;
      } 
    } finally {
      cursor.close();
    } 
  }
  
  public boolean equals(Object paramObject) {
    if (this == paramObject)
      return true; 
    if (paramObject != null) {
      if (getClass() != paramObject.getClass())
        return false; 
      paramObject = (TableInfo)paramObject;
      String str = this.name;
      if (str != null) {
        if (!str.equals(paramObject.name))
          return false; 
      } else if (paramObject.name != null) {
        return false;
      } 
      Map map = this.columns;
      if (map != null) {
        if (!map.equals(paramObject.columns))
          return false; 
      } else if (paramObject.columns != null) {
        return false;
      } 
      Set set = this.foreignKeys;
      if (set != null) {
        if (!set.equals(paramObject.foreignKeys))
          return false; 
      } else if (paramObject.foreignKeys != null) {
        return false;
      } 
      set = this.indices;
      if (set != null) {
        paramObject = paramObject.indices;
        return (paramObject == null) ? true : set.equals(paramObject);
      } 
      return true;
    } 
    return false;
  }
  
  public int hashCode() {
    byte b;
    boolean bool;
    String str = this.name;
    int i = 0;
    if (str != null) {
      bool = str.hashCode();
    } else {
      bool = false;
    } 
    Map map = this.columns;
    if (map != null) {
      b = map.hashCode();
    } else {
      b = 0;
    } 
    Set set = this.foreignKeys;
    if (set != null)
      i = set.hashCode(); 
    return (bool * 31 + b) * 31 + i;
  }
  
  public String toString() {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("TableInfo{name='");
    stringBuilder.append(this.name);
    stringBuilder.append('\'');
    stringBuilder.append(", columns=");
    stringBuilder.append(this.columns);
    stringBuilder.append(", foreignKeys=");
    stringBuilder.append(this.foreignKeys);
    stringBuilder.append(", indices=");
    stringBuilder.append(this.indices);
    stringBuilder.append('}');
    return stringBuilder.toString();
  }
}

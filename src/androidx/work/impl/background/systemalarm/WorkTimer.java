package androidx.work.impl.background.systemalarm;

import android.support.annotation.NonNull;
import android.support.annotation.RestrictTo;
import android.support.annotation.VisibleForTesting;
import androidx.work.Logger;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

@RestrictTo({RestrictTo.Scope.LIBRARY_GROUP})
class WorkTimer {
  private static final String TAG = Logger.tagWithPrefix("WorkTimer");
  
  private final ThreadFactory mBackgroundThreadFactory = new Object(this);
  
  private final ScheduledExecutorService mExecutorService = Executors.newSingleThreadScheduledExecutor(this.mBackgroundThreadFactory);
  
  final Map<String, TimeLimitExceededListener> mListeners = new HashMap();
  
  final Object mLock = new Object();
  
  final Map<String, WorkTimerRunnable> mTimerMap = new HashMap();
  
  @VisibleForTesting
  Map<String, TimeLimitExceededListener> getListeners() { // Byte code:
    //   0: aload_0
    //   1: monitorenter
    //   2: aload_0
    //   3: getfield mListeners : Ljava/util/Map;
    //   6: astore_1
    //   7: aload_0
    //   8: monitorexit
    //   9: aload_1
    //   10: areturn
    //   11: astore_1
    //   12: aload_0
    //   13: monitorexit
    //   14: aload_1
    //   15: athrow
    // Exception table:
    //   from	to	target	type
    //   2	7	11	finally }
  
  @VisibleForTesting
  Map<String, WorkTimerRunnable> getTimerMap() { // Byte code:
    //   0: aload_0
    //   1: monitorenter
    //   2: aload_0
    //   3: getfield mTimerMap : Ljava/util/Map;
    //   6: astore_1
    //   7: aload_0
    //   8: monitorexit
    //   9: aload_1
    //   10: areturn
    //   11: astore_1
    //   12: aload_0
    //   13: monitorexit
    //   14: aload_1
    //   15: athrow
    // Exception table:
    //   from	to	target	type
    //   2	7	11	finally }
  
  void startTimer(@NonNull String paramString, long paramLong, @NonNull TimeLimitExceededListener paramTimeLimitExceededListener) {
    synchronized (this.mLock) {
      Logger.get().debug(TAG, String.format("Starting timer for %s", new Object[] { paramString }), new Throwable[0]);
      stopTimer(paramString);
      WorkTimerRunnable workTimerRunnable = new WorkTimerRunnable(this, paramString);
      this.mTimerMap.put(paramString, workTimerRunnable);
      this.mListeners.put(paramString, paramTimeLimitExceededListener);
      this.mExecutorService.schedule(workTimerRunnable, paramLong, TimeUnit.MILLISECONDS);
      return;
    } 
  }
  
  void stopTimer(@NonNull String paramString) {
    synchronized (this.mLock) {
      if ((WorkTimerRunnable)this.mTimerMap.remove(paramString) != null) {
        Logger.get().debug(TAG, String.format("Stopping timer for %s", new Object[] { paramString }), new Throwable[0]);
        this.mListeners.remove(paramString);
      } 
      return;
    } 
  }
}

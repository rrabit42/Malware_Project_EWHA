package android.support.v7.util;

import android.support.annotation.NonNull;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

public class DiffUtil {
  private static final Comparator<Snake> SNAKE_COMPARATOR = new Object();
  
  @NonNull
  public static DiffResult calculateDiff(@NonNull Callback paramCallback) { return calculateDiff(paramCallback, true); }
  
  @NonNull
  public static DiffResult calculateDiff(@NonNull Callback paramCallback, boolean paramBoolean) {
    int i = paramCallback.getOldListSize();
    int j = paramCallback.getNewListSize();
    ArrayList arrayList1 = new ArrayList();
    ArrayList arrayList2 = new ArrayList();
    arrayList2.add(new Range(0, i, 0, j));
    i = Math.abs(i - j) + i + j;
    j = i * 2;
    int[] arrayOfInt1 = new int[j];
    int[] arrayOfInt2 = new int[j];
    ArrayList arrayList3 = new ArrayList();
    while (!arrayList2.isEmpty()) {
      Range range = (Range)arrayList2.remove(arrayList2.size() - 1);
      Snake snake = diffPartial(paramCallback, range.oldListStart, range.oldListEnd, range.newListStart, range.newListEnd, arrayOfInt1, arrayOfInt2, i);
      if (snake != null) {
        Range range1;
        if (snake.size > 0)
          arrayList1.add(snake); 
        snake.x += range.oldListStart;
        snake.y += range.newListStart;
        if (arrayList3.isEmpty()) {
          range1 = new Range();
        } else {
          range1 = (Range)arrayList3.remove(arrayList3.size() - 1);
        } 
        range1.oldListStart = range.oldListStart;
        range1.newListStart = range.newListStart;
        if (snake.reverse) {
          range1.oldListEnd = snake.x;
          range1.newListEnd = snake.y;
        } else if (snake.removal) {
          range1.oldListEnd = snake.x - 1;
          range1.newListEnd = snake.y;
        } else {
          range1.oldListEnd = snake.x;
          range1.newListEnd = snake.y - 1;
        } 
        arrayList2.add(range1);
        if (snake.reverse) {
          if (snake.removal) {
            range.oldListStart = snake.x + snake.size + 1;
            range.newListStart = snake.y + snake.size;
          } else {
            range.oldListStart = snake.x + snake.size;
            range.newListStart = snake.y + snake.size + 1;
          } 
        } else {
          range.oldListStart = snake.x + snake.size;
          range.newListStart = snake.y + snake.size;
        } 
        arrayList2.add(range);
        continue;
      } 
      arrayList3.add(range);
    } 
    Collections.sort(arrayList1, SNAKE_COMPARATOR);
    return new DiffResult(paramCallback, arrayList1, arrayOfInt1, arrayOfInt2, paramBoolean);
  }
  
  private static Snake diffPartial(Callback paramCallback, int paramInt1, int paramInt2, int paramInt3, int paramInt4, int[] paramArrayOfInt1, int[] paramArrayOfInt2, int paramInt5) {
    paramInt2 -= paramInt1;
    int j = paramInt4 - paramInt3;
    if (paramInt2 < 1 || j < 1)
      return null; 
    int k = paramInt2 - j;
    int m = (paramInt2 + j + 1) / 2;
    paramInt4 = paramInt5 - m - 1;
    int i = paramInt5 + m + 1;
    Arrays.fill(paramArrayOfInt1, paramInt4, i, 0);
    Arrays.fill(paramArrayOfInt2, paramInt4 + k, i + k, paramInt2);
    if (k % 2 != 0) {
      i = 1;
    } else {
      i = 0;
    } 
    byte b;
    for (b = 0; b <= m; b++) {
      byte b1 = -b;
      byte b2 = b1;
      while (true)
        b2 += 2; 
      b2 = b1;
      while (true)
        b2 += 2; 
      continue;
    } 
    throw new IllegalStateException("DiffUtil hit an unexpected case while trying to calculate the optimal path. Please make sure your data is not changing during the diff calculation.");
  }
}

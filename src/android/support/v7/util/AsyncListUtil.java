package android.support.v7.util;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.util.Log;
import android.util.SparseIntArray;

public class AsyncListUtil<T> extends Object {
  static final boolean DEBUG = false;
  
  static final String TAG = "AsyncListUtil";
  
  boolean mAllowScrollHints;
  
  private final ThreadUtil.BackgroundCallback<T> mBackgroundCallback = new Object(this);
  
  final ThreadUtil.BackgroundCallback<T> mBackgroundProxy;
  
  final DataCallback<T> mDataCallback;
  
  int mDisplayedGeneration = 0;
  
  int mItemCount = 0;
  
  private final ThreadUtil.MainThreadCallback<T> mMainThreadCallback = new Object(this);
  
  final ThreadUtil.MainThreadCallback<T> mMainThreadProxy;
  
  final SparseIntArray mMissingPositions = new SparseIntArray();
  
  final int[] mPrevRange = new int[2];
  
  int mRequestedGeneration = this.mDisplayedGeneration;
  
  private int mScrollHint = 0;
  
  final Class<T> mTClass;
  
  final TileList<T> mTileList;
  
  final int mTileSize;
  
  final int[] mTmpRange = new int[2];
  
  final int[] mTmpRangeExtended = new int[2];
  
  final ViewCallback mViewCallback;
  
  public AsyncListUtil(@NonNull Class<T> paramClass, int paramInt, @NonNull DataCallback<T> paramDataCallback, @NonNull ViewCallback paramViewCallback) {
    this.mTClass = paramClass;
    this.mTileSize = paramInt;
    this.mDataCallback = paramDataCallback;
    this.mViewCallback = paramViewCallback;
    this.mTileList = new TileList(this.mTileSize);
    MessageThreadUtil messageThreadUtil = new MessageThreadUtil();
    this.mMainThreadProxy = messageThreadUtil.getMainThreadProxy(this.mMainThreadCallback);
    this.mBackgroundProxy = messageThreadUtil.getBackgroundProxy(this.mBackgroundCallback);
    refresh();
  }
  
  private boolean isRefreshPending() { return (this.mRequestedGeneration != this.mDisplayedGeneration); }
  
  @Nullable
  public T getItem(int paramInt) {
    if (paramInt >= 0 && paramInt < this.mItemCount) {
      Object object = this.mTileList.getItemAt(paramInt);
      if (object == null && !isRefreshPending())
        this.mMissingPositions.put(paramInt, 0); 
      return (T)object;
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(paramInt);
    stringBuilder.append(" is not within 0 and ");
    stringBuilder.append(this.mItemCount);
    throw new IndexOutOfBoundsException(stringBuilder.toString());
  }
  
  public int getItemCount() { return this.mItemCount; }
  
  void log(String paramString, Object... paramVarArgs) {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("[MAIN] ");
    stringBuilder.append(String.format(paramString, paramVarArgs));
    Log.d("AsyncListUtil", stringBuilder.toString());
  }
  
  public void onRangeChanged() {
    if (isRefreshPending())
      return; 
    updateRange();
    this.mAllowScrollHints = true;
  }
  
  public void refresh() {
    this.mMissingPositions.clear();
    ThreadUtil.BackgroundCallback backgroundCallback = this.mBackgroundProxy;
    int i = this.mRequestedGeneration + 1;
    this.mRequestedGeneration = i;
    backgroundCallback.refresh(i);
  }
  
  void updateRange() {
    this.mViewCallback.getItemRangeInto(this.mTmpRange);
    int[] arrayOfInt = this.mTmpRange;
    if (arrayOfInt[0] <= arrayOfInt[1]) {
      if (arrayOfInt[0] < 0)
        return; 
      if (arrayOfInt[1] >= this.mItemCount)
        return; 
      if (!this.mAllowScrollHints) {
        this.mScrollHint = 0;
      } else {
        int k = arrayOfInt[0];
        int[] arrayOfInt2 = this.mPrevRange;
        if (k > arrayOfInt2[1] || arrayOfInt2[0] > arrayOfInt[1]) {
          this.mScrollHint = 0;
        } else if (arrayOfInt[0] < arrayOfInt2[0]) {
          this.mScrollHint = 1;
        } else if (arrayOfInt[0] > arrayOfInt2[0]) {
          this.mScrollHint = 2;
        } 
      } 
      arrayOfInt = this.mPrevRange;
      int[] arrayOfInt1 = this.mTmpRange;
      arrayOfInt[0] = arrayOfInt1[0];
      arrayOfInt[1] = arrayOfInt1[1];
      this.mViewCallback.extendRangeInto(arrayOfInt1, this.mTmpRangeExtended, this.mScrollHint);
      arrayOfInt = this.mTmpRangeExtended;
      arrayOfInt[0] = Math.min(this.mTmpRange[0], Math.max(arrayOfInt[0], 0));
      arrayOfInt = this.mTmpRangeExtended;
      arrayOfInt[1] = Math.max(this.mTmpRange[1], Math.min(arrayOfInt[1], this.mItemCount - 1));
      ThreadUtil.BackgroundCallback backgroundCallback = this.mBackgroundProxy;
      arrayOfInt1 = this.mTmpRange;
      int i = arrayOfInt1[0];
      int j = arrayOfInt1[1];
      arrayOfInt1 = this.mTmpRangeExtended;
      backgroundCallback.updateRange(i, j, arrayOfInt1[0], arrayOfInt1[1], this.mScrollHint);
    } 
  }
}
